#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_functions.h"
#include "ps2_recompiled_stubs.h"

#include "ps2_syscalls.h"
#include "ps2_stubs.h"

#ifdef _DEBUG
#include "ps2_log.h"
#endif

// Function: Stage2BossMove
// Address: 0x177cc0 - 0x17cbdc
void Stage2BossMove_0x177cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
#ifdef _DEBUG
    PS_LOG_ENTRY("Stage2BossMove_0x177cc0");
#endif

    ctx->pc = 0x177cc0u;

    // 0x177cc0: 0x27bdffc0  addiu       $sp, $sp, -0x40
    ctx->pc = 0x177cc0u;
    SET_GPR_S32(ctx, 29, (int32_t)ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x177cc4: 0x3c02c049  lui         $v0, 0xC049
    ctx->pc = 0x177cc4u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)49225 << 16));
    // 0x177cc8: 0xffbf0020  sd          $ra, 0x20($sp)
    ctx->pc = 0x177cc8u;
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 31));
    // 0x177ccc: 0x34420fdb  ori         $v0, $v0, 0xFDB
    ctx->pc = 0x177cccu;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)4059u)));
    // 0x177cd0: 0x7fb10010  sq          $s1, 0x10($sp)
    ctx->pc = 0x177cd0u;
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x177cd4: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177cd4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177cd8: 0x7fb00000  sq          $s0, 0x0($sp)
    ctx->pc = 0x177cd8u;
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x177cdc: 0x80882d  daddu       $s1, $a0, $zero
    ctx->pc = 0x177cdcu;
    SET_GPR_U64(ctx, 17, (uint64_t)GPR_U64(ctx, 4) + (uint64_t)GPR_U64(ctx, 0));
    // 0x177ce0: 0x8c830000  lw          $v1, 0x0($a0)
    ctx->pc = 0x177ce0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x177ce4: 0xc48200d0  lwc1        $f2, 0xD0($a0)
    ctx->pc = 0x177ce4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 4), 208)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[2] = f; }
    // 0x177ce8: 0xc4610120  lwc1        $f1, 0x120($v1)
    ctx->pc = 0x177ce8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 3), 288)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177cec: 0x46020840  add.s       $f1, $f1, $f2
    ctx->pc = 0x177cecu;
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x177cf0: 0xe4610120  swc1        $f1, 0x120($v1)
    ctx->pc = 0x177cf0u;
    { float f = ctx->f[1]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 3), 288), bits); }
    // 0x177cf4: 0x8c820000  lw          $v0, 0x0($a0)
    ctx->pc = 0x177cf4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x177cf8: 0xc48200d4  lwc1        $f2, 0xD4($a0)
    ctx->pc = 0x177cf8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 4), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[2] = f; }
    // 0x177cfc: 0xc4410124  lwc1        $f1, 0x124($v0)
    ctx->pc = 0x177cfcu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 292)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177d00: 0x46020840  add.s       $f1, $f1, $f2
    ctx->pc = 0x177d00u;
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x177d04: 0xe4410124  swc1        $f1, 0x124($v0)
    ctx->pc = 0x177d04u;
    { float f = ctx->f[1]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 2), 292), bits); }
    // 0x177d08: 0x8c820000  lw          $v0, 0x0($a0)
    ctx->pc = 0x177d08u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x177d0c: 0xc48200e4  lwc1        $f2, 0xE4($a0)
    ctx->pc = 0x177d0cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 4), 228)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[2] = f; }
    // 0x177d10: 0xc4410114  lwc1        $f1, 0x114($v0)
    ctx->pc = 0x177d10u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 276)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177d14: 0x46020840  add.s       $f1, $f1, $f2
    ctx->pc = 0x177d14u;
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x177d18: 0xe4410114  swc1        $f1, 0x114($v0)
    ctx->pc = 0x177d18u;
    { float f = ctx->f[1]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 2), 276), bits); }
    // 0x177d1c: 0x8c820000  lw          $v0, 0x0($a0)
    ctx->pc = 0x177d1cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x177d20: 0xc48200e0  lwc1        $f2, 0xE0($a0)
    ctx->pc = 0x177d20u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 4), 224)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[2] = f; }
    // 0x177d24: 0xc4410110  lwc1        $f1, 0x110($v0)
    ctx->pc = 0x177d24u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 272)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177d28: 0x46020840  add.s       $f1, $f1, $f2
    ctx->pc = 0x177d28u;
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x177d2c: 0xe4410110  swc1        $f1, 0x110($v0)
    ctx->pc = 0x177d2cu;
    { float f = ctx->f[1]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 2), 272), bits); }
    // 0x177d30: 0x8c820000  lw          $v0, 0x0($a0)
    ctx->pc = 0x177d30u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x177d34: 0xc4410114  lwc1        $f1, 0x114($v0)
    ctx->pc = 0x177d34u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 276)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177d38: 0x46000834  c.lt.s      $f1, $f0
    ctx->pc = 0x177d38u;
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177d3c: 0x45000008  bc1f        . + 4 + (0x8 << 2)
    ctx->pc = 0x177D3Cu;
    {
        const bool branch_taken_0x177d3c = (!(ctx->fcr31 & 0x800000));
        ctx->pc = 0x177D40u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177D3Cu;
            // 0x177d40: 0x24430114  addiu       $v1, $v0, 0x114 (Delay Slot)
        SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 2), 276));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177d3c) {
            ctx->pc = 0x177D60u;
            goto label_177d60;
        }
    }
    ctx->pc = 0x177D44u;
    // 0x177d44: 0x3c0240c9  lui         $v0, 0x40C9
    ctx->pc = 0x177d44u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16585 << 16));
    // 0x177d48: 0x34420fdb  ori         $v0, $v0, 0xFDB
    ctx->pc = 0x177d48u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)4059u)));
    // 0x177d4c: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177d4cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177d50: 0x0  nop
    ctx->pc = 0x177d50u;
    // NOP
    // 0x177d54: 0x46000800  add.s       $f0, $f1, $f0
    ctx->pc = 0x177d54u;
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x177d58: 0xe4600000  swc1        $f0, 0x0($v1)
    ctx->pc = 0x177d58u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 3), 0), bits); }
    // 0x177d5c: 0x0  nop
    ctx->pc = 0x177d5cu;
    // NOP
label_177d60:
    // 0x177d60: 0x8e230000  lw          $v1, 0x0($s1)
    ctx->pc = 0x177d60u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x177d64: 0x3c024049  lui         $v0, 0x4049
    ctx->pc = 0x177d64u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16457 << 16));
    // 0x177d68: 0x34420fdb  ori         $v0, $v0, 0xFDB
    ctx->pc = 0x177d68u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)4059u)));
    // 0x177d6c: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177d6cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177d70: 0xc4610114  lwc1        $f1, 0x114($v1)
    ctx->pc = 0x177d70u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 3), 276)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177d74: 0x46000836  c.le.s      $f1, $f0
    ctx->pc = 0x177d74u;
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177d78: 0x45010007  bc1t        . + 4 + (0x7 << 2)
    ctx->pc = 0x177D78u;
    {
        const bool branch_taken_0x177d78 = ((ctx->fcr31 & 0x800000));
        ctx->pc = 0x177D7Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177D78u;
            // 0x177d7c: 0x24640114  addiu       $a0, $v1, 0x114 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 276));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177d78) {
            ctx->pc = 0x177D98u;
            goto label_177d98;
        }
    }
    ctx->pc = 0x177D80u;
    // 0x177d80: 0x3c0240c9  lui         $v0, 0x40C9
    ctx->pc = 0x177d80u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16585 << 16));
    // 0x177d84: 0x34420fdb  ori         $v0, $v0, 0xFDB
    ctx->pc = 0x177d84u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)4059u)));
    // 0x177d88: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177d88u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177d8c: 0x0  nop
    ctx->pc = 0x177d8cu;
    // NOP
    // 0x177d90: 0x46000801  sub.s       $f0, $f1, $f0
    ctx->pc = 0x177d90u;
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x177d94: 0xe4800000  swc1        $f0, 0x0($a0)
    ctx->pc = 0x177d94u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 4), 0), bits); }
label_177d98:
    // 0x177d98: 0x8e230000  lw          $v1, 0x0($s1)
    ctx->pc = 0x177d98u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x177d9c: 0x3c02c049  lui         $v0, 0xC049
    ctx->pc = 0x177d9cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)49225 << 16));
    // 0x177da0: 0x34420fdb  ori         $v0, $v0, 0xFDB
    ctx->pc = 0x177da0u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)4059u)));
    // 0x177da4: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177da4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177da8: 0xc4610110  lwc1        $f1, 0x110($v1)
    ctx->pc = 0x177da8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 3), 272)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177dac: 0x46000834  c.lt.s      $f1, $f0
    ctx->pc = 0x177dacu;
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177db0: 0x45000007  bc1f        . + 4 + (0x7 << 2)
    ctx->pc = 0x177DB0u;
    {
        const bool branch_taken_0x177db0 = (!(ctx->fcr31 & 0x800000));
        ctx->pc = 0x177DB4u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177DB0u;
            // 0x177db4: 0x24640110  addiu       $a0, $v1, 0x110 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 272));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177db0) {
            ctx->pc = 0x177DD0u;
            goto label_177dd0;
        }
    }
    ctx->pc = 0x177DB8u;
    // 0x177db8: 0x3c0240c9  lui         $v0, 0x40C9
    ctx->pc = 0x177db8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16585 << 16));
    // 0x177dbc: 0x34420fdb  ori         $v0, $v0, 0xFDB
    ctx->pc = 0x177dbcu;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)4059u)));
    // 0x177dc0: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177dc0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177dc4: 0x0  nop
    ctx->pc = 0x177dc4u;
    // NOP
    // 0x177dc8: 0x46000800  add.s       $f0, $f1, $f0
    ctx->pc = 0x177dc8u;
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x177dcc: 0xe4800000  swc1        $f0, 0x0($a0)
    ctx->pc = 0x177dccu;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 4), 0), bits); }
label_177dd0:
    // 0x177dd0: 0x8e230000  lw          $v1, 0x0($s1)
    ctx->pc = 0x177dd0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x177dd4: 0x3c024049  lui         $v0, 0x4049
    ctx->pc = 0x177dd4u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16457 << 16));
    // 0x177dd8: 0x34420fdb  ori         $v0, $v0, 0xFDB
    ctx->pc = 0x177dd8u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)4059u)));
    // 0x177ddc: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177ddcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177de0: 0xc4610110  lwc1        $f1, 0x110($v1)
    ctx->pc = 0x177de0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 3), 272)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177de4: 0x46000836  c.le.s      $f1, $f0
    ctx->pc = 0x177de4u;
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177de8: 0x45010007  bc1t        . + 4 + (0x7 << 2)
    ctx->pc = 0x177DE8u;
    {
        const bool branch_taken_0x177de8 = ((ctx->fcr31 & 0x800000));
        ctx->pc = 0x177DECu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177DE8u;
            // 0x177dec: 0x24640110  addiu       $a0, $v1, 0x110 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 272));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177de8) {
            ctx->pc = 0x177E08u;
            goto label_177e08;
        }
    }
    ctx->pc = 0x177DF0u;
    // 0x177df0: 0x3c0240c9  lui         $v0, 0x40C9
    ctx->pc = 0x177df0u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16585 << 16));
    // 0x177df4: 0x34420fdb  ori         $v0, $v0, 0xFDB
    ctx->pc = 0x177df4u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)4059u)));
    // 0x177df8: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177df8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177dfc: 0x0  nop
    ctx->pc = 0x177dfcu;
    // NOP
    // 0x177e00: 0x46000801  sub.s       $f0, $f1, $f0
    ctx->pc = 0x177e00u;
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x177e04: 0xe4800000  swc1        $f0, 0x0($a0)
    ctx->pc = 0x177e04u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 4), 0), bits); }
label_177e08:
    // 0x177e08: 0x8e220000  lw          $v0, 0x0($s1)
    ctx->pc = 0x177e08u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x177e0c: 0x27a4003c  addiu       $a0, $sp, 0x3C
    ctx->pc = 0x177e0cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 29), 60));
    // 0x177e10: 0xc44c0120  lwc1        $f12, 0x120($v0)
    ctx->pc = 0x177e10u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 288)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[12] = f; }
    // 0x177e14: 0xc44d0124  lwc1        $f13, 0x124($v0)
    ctx->pc = 0x177e14u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 292)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[13] = f; }
    // 0x177e18: 0xc05f3cc  jal         func_17CF30
    ctx->pc = 0x177E18u;
    SET_GPR_U32(ctx, 31, 0x177E20u);
    ctx->pc = 0x177E1Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x177E18u;
            // 0x177e1c: 0x27a50038  addiu       $a1, $sp, 0x38 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 29), 56));
        ctx->in_delay_slot = false;
    ctx->pc = 0x17CF30u;
    if (runtime->hasFunction(0x17CF30u)) {
        auto targetFn = runtime->lookupFunction(0x17CF30u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177E20u; }
        if (ctx->pc != 0x177E20u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Trans3Dto2D_0x17cf30(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177E20u; }
        if (ctx->pc != 0x177E20u) { return; }
    }
    ctx->pc = 0x177E20u;
    // 0x177e20: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x177e20u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x177e24: 0xae22001c  sw          $v0, 0x1C($s1)
    ctx->pc = 0x177e24u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 2));
    // 0x177e28: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x177e28u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x177e2c: 0xae220020  sw          $v0, 0x20($s1)
    ctx->pc = 0x177e2cu;
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    // 0x177e30: 0x8e220028  lw          $v0, 0x28($s1)
    ctx->pc = 0x177e30u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 40)));
    // 0x177e34: 0x2c41000a  sltiu       $at, $v0, 0xA
    ctx->pc = 0x177e34u;
    SET_GPR_U64(ctx, 1, ((uint64_t)GPR_U64(ctx, 2) < (uint64_t)(int64_t)(int32_t)10) ? 1 : 0);
    // 0x177e38: 0x10201215  beqz        $at, . + 4 + (0x1215 << 2)
    ctx->pc = 0x177E38u;
    {
        const bool branch_taken_0x177e38 = (GPR_U64(ctx, 1) == GPR_U64(ctx, 0));
        ctx->pc = 0x177E3Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177E38u;
            // 0x177e3c: 0x3c030022  lui         $v1, 0x22 (Delay Slot)
        SET_GPR_S32(ctx, 3, (int32_t)((uint32_t)34 << 16));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177e38) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x177E40u;
    // 0x177e40: 0x21080  sll         $v0, $v0, 2
    ctx->pc = 0x177e40u;
    SET_GPR_S32(ctx, 2, (int32_t)SLL32(GPR_U32(ctx, 2), 2));
    // 0x177e44: 0x24631d80  addiu       $v1, $v1, 0x1D80
    ctx->pc = 0x177e44u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 7552));
    // 0x177e48: 0x431021  addu        $v0, $v0, $v1
    ctx->pc = 0x177e48u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x177e4c: 0x8c420000  lw          $v0, 0x0($v0)
    ctx->pc = 0x177e4cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x177e50: 0x400008  jr          $v0
    ctx->pc = 0x177E50u;
    {
        uint32_t jumpTarget = GPR_U32(ctx, 2);
        ctx->pc = jumpTarget;
        switch (jumpTarget) {
            case 0x177E58u: goto label_177e58;
            case 0x177EA0u: goto label_177ea0;
            case 0x177ED8u: goto label_177ed8;
            case 0x177F38u: goto label_177f38;
            case 0x17A618u: goto label_17a618;
            case 0x17A648u: goto label_17a648;
            case 0x17C178u: goto label_17c178;
            case 0x17C470u: goto label_17c470;
            case 0x17C5E0u: goto label_17c5e0;
            case 0x17C650u: goto label_17c650;
            default: break;
        }
        return;
    }
    ctx->pc = 0x177E58u;
label_177e58:
    // 0x177e58: 0x3c023d23  lui         $v0, 0x3D23
    ctx->pc = 0x177e58u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)15651 << 16));
    // 0x177e5c: 0xc62100d4  lwc1        $f1, 0xD4($s1)
    ctx->pc = 0x177e5cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177e60: 0x3442d70a  ori         $v0, $v0, 0xD70A
    ctx->pc = 0x177e60u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)55050u)));
    // 0x177e64: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177e64u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177e68: 0x0  nop
    ctx->pc = 0x177e68u;
    // NOP
    // 0x177e6c: 0x46000836  c.le.s      $f1, $f0
    ctx->pc = 0x177e6cu;
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177e70: 0x45010007  bc1t        . + 4 + (0x7 << 2)
    ctx->pc = 0x177E70u;
    {
        const bool branch_taken_0x177e70 = ((ctx->fcr31 & 0x800000));
        ctx->pc = 0x177E74u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177E70u;
            // 0x177e74: 0x3c023f7d  lui         $v0, 0x3F7D (Delay Slot)
        SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16253 << 16));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177e70) {
            ctx->pc = 0x177E90u;
            goto label_177e90;
        }
    }
    ctx->pc = 0x177E78u;
    // 0x177e78: 0x344270a4  ori         $v0, $v0, 0x70A4
    ctx->pc = 0x177e78u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)28836u)));
    // 0x177e7c: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177e7cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177e80: 0x0  nop
    ctx->pc = 0x177e80u;
    // NOP
    // 0x177e84: 0x46000802  mul.s       $f0, $f1, $f0
    ctx->pc = 0x177e84u;
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x177e88: 0x10001201  b           . + 4 + (0x1201 << 2)
    ctx->pc = 0x177E88u;
    {
        const bool branch_taken_0x177e88 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x177E8Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177E88u;
            // 0x177e8c: 0xe62000d4  swc1        $f0, 0xD4($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 212), bits); }
        ctx->in_delay_slot = false;
        if (branch_taken_0x177e88) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x177E90u;
label_177e90:
    // 0x177e90: 0x24020001  addiu       $v0, $zero, 0x1
    ctx->pc = 0x177e90u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
    // 0x177e94: 0xae220028  sw          $v0, 0x28($s1)
    ctx->pc = 0x177e94u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 2));
    // 0x177e98: 0x100011fd  b           . + 4 + (0x11FD << 2)
    ctx->pc = 0x177E98u;
    {
        const bool branch_taken_0x177e98 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x177E9Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177E98u;
            // 0x177e9c: 0xae200024  sw          $zero, 0x24($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177e98) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x177EA0u;
label_177ea0:
    // 0x177ea0: 0x3c023a37  lui         $v0, 0x3A37
    ctx->pc = 0x177ea0u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)14903 << 16));
    // 0x177ea4: 0xc62100d4  lwc1        $f1, 0xD4($s1)
    ctx->pc = 0x177ea4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177ea8: 0x34428034  ori         $v0, $v0, 0x8034
    ctx->pc = 0x177ea8u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)32820u)));
    // 0x177eac: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177eacu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177eb0: 0x0  nop
    ctx->pc = 0x177eb0u;
    // NOP
    // 0x177eb4: 0x46000801  sub.s       $f0, $f1, $f0
    ctx->pc = 0x177eb4u;
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x177eb8: 0xe62000d4  swc1        $f0, 0xD4($s1)
    ctx->pc = 0x177eb8u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 212), bits); }
    // 0x177ebc: 0x8e220024  lw          $v0, 0x24($s1)
    ctx->pc = 0x177ebcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x177ec0: 0x284100b5  slti        $at, $v0, 0xB5
    ctx->pc = 0x177ec0u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)181) ? 1 : 0);
    // 0x177ec4: 0x142011f2  bnez        $at, . + 4 + (0x11F2 << 2)
    ctx->pc = 0x177EC4u;
    {
        const bool branch_taken_0x177ec4 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        ctx->pc = 0x177EC8u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177EC4u;
            // 0x177ec8: 0x24020002  addiu       $v0, $zero, 0x2 (Delay Slot)
        SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 2));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177ec4) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x177ECCu;
    // 0x177ecc: 0xae220028  sw          $v0, 0x28($s1)
    ctx->pc = 0x177eccu;
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 2));
    // 0x177ed0: 0x100011ef  b           . + 4 + (0x11EF << 2)
    ctx->pc = 0x177ED0u;
    {
        const bool branch_taken_0x177ed0 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x177ED4u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177ED0u;
            // 0x177ed4: 0xae200024  sw          $zero, 0x24($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177ed0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x177ED8u;
label_177ed8:
    // 0x177ed8: 0x8e220024  lw          $v0, 0x24($s1)
    ctx->pc = 0x177ed8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x177edc: 0x28410079  slti        $at, $v0, 0x79
    ctx->pc = 0x177edcu;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)121) ? 1 : 0);
    // 0x177ee0: 0x142011eb  bnez        $at, . + 4 + (0x11EB << 2)
    ctx->pc = 0x177EE0u;
    {
        const bool branch_taken_0x177ee0 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x177ee0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x177EE8u;
    // 0x177ee8: 0xc050ba4  jal         func_142E90
    ctx->pc = 0x177EE8u;
    SET_GPR_U32(ctx, 31, 0x177EF0u);
    ctx->pc = 0x142E90u;
    if (runtime->hasFunction(0x142E90u)) {
        auto targetFn = runtime->lookupFunction(0x142E90u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177EF0u; }
        if (ctx->pc != 0x177EF0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsRandf_0x142e90(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177EF0u; }
        if (ctx->pc != 0x177EF0u) { return; }
    }
    ctx->pc = 0x177EF0u;
    // 0x177ef0: 0x3c023dcc  lui         $v0, 0x3DCC
    ctx->pc = 0x177ef0u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)15820 << 16));
    // 0x177ef4: 0x3442cccd  ori         $v0, $v0, 0xCCCD
    ctx->pc = 0x177ef4u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)52429u)));
    // 0x177ef8: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x177ef8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x177efc: 0x0  nop
    ctx->pc = 0x177efcu;
    // NOP
    // 0x177f00: 0x46000802  mul.s       $f0, $f1, $f0
    ctx->pc = 0x177f00u;
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x177f04: 0xc050ba4  jal         func_142E90
    ctx->pc = 0x177F04u;
    SET_GPR_U32(ctx, 31, 0x177F0Cu);
    ctx->pc = 0x177F08u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x177F04u;
            // 0x177f08: 0xe62000d0  swc1        $f0, 0xD0($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 208), bits); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x142E90u;
    if (runtime->hasFunction(0x142E90u)) {
        auto targetFn = runtime->lookupFunction(0x142E90u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177F0Cu; }
        if (ctx->pc != 0x177F0Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsRandf_0x142e90(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177F0Cu; }
        if (ctx->pc != 0x177F0Cu) { return; }
    }
    ctx->pc = 0x177F0Cu;
    // 0x177f0c: 0x3c033dcc  lui         $v1, 0x3DCC
    ctx->pc = 0x177f0cu;
    SET_GPR_S32(ctx, 3, (int32_t)((uint32_t)15820 << 16));
    // 0x177f10: 0x24020003  addiu       $v0, $zero, 0x3
    ctx->pc = 0x177f10u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
    // 0x177f14: 0x3463cccd  ori         $v1, $v1, 0xCCCD
    ctx->pc = 0x177f14u;
    SET_GPR_VEC(ctx, 3, PS2_POR(GPR_VEC(ctx, 3), _mm_cvtsi32_si128((int)52429u)));
    // 0x177f18: 0x44830800  mtc1        $v1, $f1
    ctx->pc = 0x177f18u;
    { uint32_t bits = GPR_U32(ctx, 3); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x177f1c: 0x0  nop
    ctx->pc = 0x177f1cu;
    // NOP
    // 0x177f20: 0x46000802  mul.s       $f0, $f1, $f0
    ctx->pc = 0x177f20u;
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x177f24: 0xe62000d4  swc1        $f0, 0xD4($s1)
    ctx->pc = 0x177f24u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 212), bits); }
    // 0x177f28: 0xae220028  sw          $v0, 0x28($s1)
    ctx->pc = 0x177f28u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 2));
    // 0x177f2c: 0x100011d8  b           . + 4 + (0x11D8 << 2)
    ctx->pc = 0x177F2Cu;
    {
        const bool branch_taken_0x177f2c = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x177F30u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177F2Cu;
            // 0x177f30: 0xae200024  sw          $zero, 0x24($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177f2c) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x177F34u;
    // 0x177f34: 0x0  nop
    ctx->pc = 0x177f34u;
    // NOP
label_177f38:
    // 0x177f38: 0xc05b994  jal         func_16E650
    ctx->pc = 0x177F38u;
    SET_GPR_U32(ctx, 31, 0x177F40u);
    ctx->pc = 0x177F3Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x177F38u;
            // 0x177f3c: 0x220202d  daddu       $a0, $s1, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x16E650u;
    if (runtime->hasFunction(0x16E650u)) {
        auto targetFn = runtime->lookupFunction(0x16E650u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177F40u; }
        if (ctx->pc != 0x177F40u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Enemy_BloadCast_Child_DeadEnd_0x16e650(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177F40u; }
        if (ctx->pc != 0x177F40u) { return; }
    }
    ctx->pc = 0x177F40u;
    // 0x177f40: 0xc62100d0  lwc1        $f1, 0xD0($s1)
    ctx->pc = 0x177f40u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 208)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177f44: 0x40802d  daddu       $s0, $v0, $zero
    ctx->pc = 0x177f44u;
    SET_GPR_U64(ctx, 16, (uint64_t)GPR_U64(ctx, 2) + (uint64_t)GPR_U64(ctx, 0));
    // 0x177f48: 0x3c023ca3  lui         $v0, 0x3CA3
    ctx->pc = 0x177f48u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)15523 << 16));
    // 0x177f4c: 0x3442d70a  ori         $v0, $v0, 0xD70A
    ctx->pc = 0x177f4cu;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)55050u)));
    // 0x177f50: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177f50u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177f54: 0x0  nop
    ctx->pc = 0x177f54u;
    // NOP
    // 0x177f58: 0x46000834  c.lt.s      $f1, $f0
    ctx->pc = 0x177f58u;
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177f5c: 0x4500000c  bc1f        . + 4 + (0xC << 2)
    ctx->pc = 0x177F5Cu;
    {
        const bool branch_taken_0x177f5c = (!(ctx->fcr31 & 0x800000));
        if (branch_taken_0x177f5c) {
            ctx->pc = 0x177F90u;
            goto label_177f90;
        }
    }
    ctx->pc = 0x177F64u;
    // 0x177f64: 0x3c02bca3  lui         $v0, 0xBCA3
    ctx->pc = 0x177f64u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)48291 << 16));
    // 0x177f68: 0x3442d70a  ori         $v0, $v0, 0xD70A
    ctx->pc = 0x177f68u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)55050u)));
    // 0x177f6c: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177f6cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177f70: 0x0  nop
    ctx->pc = 0x177f70u;
    // NOP
    // 0x177f74: 0x46000836  c.le.s      $f1, $f0
    ctx->pc = 0x177f74u;
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177f78: 0x45010005  bc1t        . + 4 + (0x5 << 2)
    ctx->pc = 0x177F78u;
    {
        const bool branch_taken_0x177f78 = ((ctx->fcr31 & 0x800000));
        ctx->pc = 0x177F7Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177F78u;
            // 0x177f7c: 0x220202d  daddu       $a0, $s1, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177f78) {
            ctx->pc = 0x177F90u;
            goto label_177f90;
        }
    }
    ctx->pc = 0x177F80u;
    // 0x177f80: 0xc05f2f8  jal         func_17CBE0
    ctx->pc = 0x177F80u;
    SET_GPR_U32(ctx, 31, 0x177F88u);
    ctx->pc = 0x17CBE0u;
    if (runtime->hasFunction(0x17CBE0u)) {
        auto targetFn = runtime->lookupFunction(0x17CBE0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177F88u; }
        if (ctx->pc != 0x177F88u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        BossAddingVector_0x17cbe0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177F88u; }
        if (ctx->pc != 0x177F88u) { return; }
    }
    ctx->pc = 0x177F88u;
    // 0x177f88: 0x1000001d  b           . + 4 + (0x1D << 2)
    ctx->pc = 0x177F88u;
    {
        const bool branch_taken_0x177f88 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x177f88) {
            ctx->pc = 0x178000u;
            goto label_178000;
        }
    }
    ctx->pc = 0x177F90u;
label_177f90:
    // 0x177f90: 0x3c023c23  lui         $v0, 0x3C23
    ctx->pc = 0x177f90u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)15395 << 16));
    // 0x177f94: 0xc62100d4  lwc1        $f1, 0xD4($s1)
    ctx->pc = 0x177f94u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x177f98: 0x3442d70a  ori         $v0, $v0, 0xD70A
    ctx->pc = 0x177f98u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)55050u)));
    // 0x177f9c: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177f9cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177fa0: 0x0  nop
    ctx->pc = 0x177fa0u;
    // NOP
    // 0x177fa4: 0x46000834  c.lt.s      $f1, $f0
    ctx->pc = 0x177fa4u;
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177fa8: 0x4500000b  bc1f        . + 4 + (0xB << 2)
    ctx->pc = 0x177FA8u;
    {
        const bool branch_taken_0x177fa8 = (!(ctx->fcr31 & 0x800000));
        ctx->pc = 0x177FACu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177FA8u;
            // 0x177fac: 0x3c02bc23  lui         $v0, 0xBC23 (Delay Slot)
        SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)48163 << 16));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177fa8) {
            ctx->pc = 0x177FD8u;
            goto label_177fd8;
        }
    }
    ctx->pc = 0x177FB0u;
    // 0x177fb0: 0x3442d70a  ori         $v0, $v0, 0xD70A
    ctx->pc = 0x177fb0u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)55050u)));
    // 0x177fb4: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x177fb4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x177fb8: 0x0  nop
    ctx->pc = 0x177fb8u;
    // NOP
    // 0x177fbc: 0x46000836  c.le.s      $f1, $f0
    ctx->pc = 0x177fbcu;
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177fc0: 0x45010005  bc1t        . + 4 + (0x5 << 2)
    ctx->pc = 0x177FC0u;
    {
        const bool branch_taken_0x177fc0 = ((ctx->fcr31 & 0x800000));
        ctx->pc = 0x177FC4u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x177FC0u;
            // 0x177fc4: 0x220202d  daddu       $a0, $s1, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
        if (branch_taken_0x177fc0) {
            ctx->pc = 0x177FD8u;
            goto label_177fd8;
        }
    }
    ctx->pc = 0x177FC8u;
    // 0x177fc8: 0xc05f2f8  jal         func_17CBE0
    ctx->pc = 0x177FC8u;
    SET_GPR_U32(ctx, 31, 0x177FD0u);
    ctx->pc = 0x17CBE0u;
    if (runtime->hasFunction(0x17CBE0u)) {
        auto targetFn = runtime->lookupFunction(0x17CBE0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177FD0u; }
        if (ctx->pc != 0x177FD0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        BossAddingVector_0x17cbe0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x177FD0u; }
        if (ctx->pc != 0x177FD0u) { return; }
    }
    ctx->pc = 0x177FD0u;
    // 0x177fd0: 0x1000000b  b           . + 4 + (0xB << 2)
    ctx->pc = 0x177FD0u;
    {
        const bool branch_taken_0x177fd0 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x177fd0) {
            ctx->pc = 0x178000u;
            goto label_178000;
        }
    }
    ctx->pc = 0x177FD8u;
label_177fd8:
    // 0x177fd8: 0x3c023f7d  lui         $v0, 0x3F7D
    ctx->pc = 0x177fd8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16253 << 16));
    // 0x177fdc: 0xc62000d0  lwc1        $f0, 0xD0($s1)
    ctx->pc = 0x177fdcu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 208)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x177fe0: 0x344270a4  ori         $v0, $v0, 0x70A4
    ctx->pc = 0x177fe0u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)28836u)));
    // 0x177fe4: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x177fe4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x177fe8: 0x0  nop
    ctx->pc = 0x177fe8u;
    // NOP
    // 0x177fec: 0x46010002  mul.s       $f0, $f0, $f1
    ctx->pc = 0x177fecu;
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x177ff0: 0xe62000d0  swc1        $f0, 0xD0($s1)
    ctx->pc = 0x177ff0u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 208), bits); }
    // 0x177ff4: 0xc62000d4  lwc1        $f0, 0xD4($s1)
    ctx->pc = 0x177ff4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x177ff8: 0x46010002  mul.s       $f0, $f0, $f1
    ctx->pc = 0x177ff8u;
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x177ffc: 0xe62000d4  swc1        $f0, 0xD4($s1)
    ctx->pc = 0x177ffcu;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 212), bits); }
label_178000:
    // 0x178000: 0x8e220000  lw          $v0, 0x0($s1)
    ctx->pc = 0x178000u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x178004: 0x27a4003c  addiu       $a0, $sp, 0x3C
    ctx->pc = 0x178004u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 29), 60));
    // 0x178008: 0xc44c0120  lwc1        $f12, 0x120($v0)
    ctx->pc = 0x178008u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 288)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[12] = f; }
    // 0x17800c: 0xc44d0124  lwc1        $f13, 0x124($v0)
    ctx->pc = 0x17800cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 292)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[13] = f; }
    // 0x178010: 0xc05f3cc  jal         func_17CF30
    ctx->pc = 0x178010u;
    SET_GPR_U32(ctx, 31, 0x178018u);
    ctx->pc = 0x178014u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178010u;
            // 0x178014: 0x27a50038  addiu       $a1, $sp, 0x38 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 29), 56));
        ctx->in_delay_slot = false;
    ctx->pc = 0x17CF30u;
    if (runtime->hasFunction(0x17CF30u)) {
        auto targetFn = runtime->lookupFunction(0x17CF30u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178018u; }
        if (ctx->pc != 0x178018u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Trans3Dto2D_0x17cf30(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178018u; }
        if (ctx->pc != 0x178018u) { return; }
    }
    ctx->pc = 0x178018u;
    // 0x178018: 0x24020004  addiu       $v0, $zero, 0x4
    ctx->pc = 0x178018u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 4));
    // 0x17801c: 0x1202066a  beq         $s0, $v0, . + 4 + (0x66A << 2)
    ctx->pc = 0x17801Cu;
    {
        const bool branch_taken_0x17801c = (GPR_U64(ctx, 16) == GPR_U64(ctx, 2));
        ctx->pc = 0x178020u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17801Cu;
            // 0x178020: 0x24020003  addiu       $v0, $zero, 0x3 (Delay Slot)
        SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17801c) {
            ctx->pc = 0x1799C8u;
            goto label_1799c8;
        }
    }
    ctx->pc = 0x178024u;
    // 0x178024: 0x120203c0  beq         $s0, $v0, . + 4 + (0x3C0 << 2)
    ctx->pc = 0x178024u;
    {
        const bool branch_taken_0x178024 = (GPR_U64(ctx, 16) == GPR_U64(ctx, 2));
        if (branch_taken_0x178024) {
            ctx->pc = 0x178F28u;
            goto label_178f28;
        }
    }
    ctx->pc = 0x17802Cu;
    // 0x17802c: 0x24020002  addiu       $v0, $zero, 0x2
    ctx->pc = 0x17802cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 2));
    // 0x178030: 0x12020147  beq         $s0, $v0, . + 4 + (0x147 << 2)
    ctx->pc = 0x178030u;
    {
        const bool branch_taken_0x178030 = (GPR_U64(ctx, 16) == GPR_U64(ctx, 2));
        ctx->pc = 0x178034u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x178030u;
            // 0x178034: 0x24020001  addiu       $v0, $zero, 0x1 (Delay Slot)
        SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
        ctx->in_delay_slot = false;
        if (branch_taken_0x178030) {
            ctx->pc = 0x178550u;
            goto label_178550;
        }
    }
    ctx->pc = 0x178038u;
    // 0x178038: 0x12020145  beq         $s0, $v0, . + 4 + (0x145 << 2)
    ctx->pc = 0x178038u;
    {
        const bool branch_taken_0x178038 = (GPR_U64(ctx, 16) == GPR_U64(ctx, 2));
        if (branch_taken_0x178038) {
            ctx->pc = 0x178550u;
            goto label_178550;
        }
    }
    ctx->pc = 0x178040u;
    // 0x178040: 0x12000003  beqz        $s0, . + 4 + (0x3 << 2)
    ctx->pc = 0x178040u;
    {
        const bool branch_taken_0x178040 = (GPR_U64(ctx, 16) == GPR_U64(ctx, 0));
        if (branch_taken_0x178040) {
            ctx->pc = 0x178050u;
            goto label_178050;
        }
    }
    ctx->pc = 0x178048u;
    // 0x178048: 0x10000969  b           . + 4 + (0x969 << 2)
    ctx->pc = 0x178048u;
    {
        const bool branch_taken_0x178048 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x178048) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x178050u;
label_178050:
    // 0x178050: 0xc065d00  jal         func_197400
    ctx->pc = 0x178050u;
    SET_GPR_U32(ctx, 31, 0x178058u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178058u; }
        if (ctx->pc != 0x178058u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178058u; }
        if (ctx->pc != 0x178058u) { return; }
    }
    ctx->pc = 0x178058u;
    // 0x178058: 0x28410002  slti        $at, $v0, 0x2
    ctx->pc = 0x178058u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)2) ? 1 : 0);
    // 0x17805c: 0x1420008e  bnez        $at, . + 4 + (0x8E << 2)
    ctx->pc = 0x17805Cu;
    {
        const bool branch_taken_0x17805c = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x17805c) {
            ctx->pc = 0x178298u;
            goto label_178298;
        }
    }
    ctx->pc = 0x178064u;
    // 0x178064: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178064u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178068: 0x240200b4  addiu       $v0, $zero, 0xB4
    ctx->pc = 0x178068u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 180));
    // 0x17806c: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x17806cu;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x178070: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178070u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178074: 0x0  nop
    ctx->pc = 0x178074u;
    // NOP
    // 0x178078: 0x0  nop
    ctx->pc = 0x178078u;
    // NOP
    // 0x17807c: 0x1010  mfhi        $v0
    ctx->pc = 0x17807cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178080: 0x14400035  bnez        $v0, . + 4 + (0x35 << 2)
    ctx->pc = 0x178080u;
    {
        const bool branch_taken_0x178080 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178080) {
            ctx->pc = 0x178158u;
            goto label_178158;
        }
    }
    ctx->pc = 0x178088u;
    // 0x178088: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178088u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17808c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17808cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178090: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x178090u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x178094: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x178094u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x178098: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178098u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17809c: 0x0  nop
    ctx->pc = 0x17809cu;
    // NOP
    // 0x1780a0: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1780a0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1780a4: 0xc05d080  jal         func_174200
    ctx->pc = 0x1780A4u;
    SET_GPR_U32(ctx, 31, 0x1780ACu);
    ctx->pc = 0x1780A8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1780A4u;
            // 0x1780a8: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1780ACu; }
        if (ctx->pc != 0x1780ACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1780ACu; }
        if (ctx->pc != 0x1780ACu) { return; }
    }
    ctx->pc = 0x1780ACu;
    // 0x1780ac: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1780acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1780b0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1780b0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1780b4: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x1780b4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x1780b8: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x1780b8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x1780bc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1780bcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1780c0: 0x0  nop
    ctx->pc = 0x1780c0u;
    // NOP
    // 0x1780c4: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1780c4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1780c8: 0xc05d080  jal         func_174200
    ctx->pc = 0x1780C8u;
    SET_GPR_U32(ctx, 31, 0x1780D0u);
    ctx->pc = 0x1780CCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1780C8u;
            // 0x1780cc: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1780D0u; }
        if (ctx->pc != 0x1780D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1780D0u; }
        if (ctx->pc != 0x1780D0u) { return; }
    }
    ctx->pc = 0x1780D0u;
    // 0x1780d0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1780d0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1780d4: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x1780d4u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1780d8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1780D8u;
    SET_GPR_U32(ctx, 31, 0x1780E0u);
    ctx->pc = 0x1780DCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1780D8u;
            // 0x1780dc: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1780E0u; }
        if (ctx->pc != 0x1780E0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1780E0u; }
        if (ctx->pc != 0x1780E0u) { return; }
    }
    ctx->pc = 0x1780E0u;
    // 0x1780e0: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x1780e0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1780e4: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x1780e4u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x1780e8: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x1780e8u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1780ec: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x1780ecu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x1780f0: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x1780f0u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x1780f4: 0xc065480  jal         func_195200
    ctx->pc = 0x1780F4u;
    SET_GPR_U32(ctx, 31, 0x1780FCu);
    ctx->pc = 0x1780F8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1780F4u;
            // 0x1780f8: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1780FCu; }
        if (ctx->pc != 0x1780FCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1780FCu; }
        if (ctx->pc != 0x1780FCu) { return; }
    }
    ctx->pc = 0x1780FCu;
    // 0x1780fc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1780fcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178100: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178100u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178104: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x178104u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x178108: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178108u;
    SET_GPR_U32(ctx, 31, 0x178110u);
    ctx->pc = 0x17810Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178108u;
            // 0x17810c: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178110u; }
        if (ctx->pc != 0x178110u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178110u; }
        if (ctx->pc != 0x178110u) { return; }
    }
    ctx->pc = 0x178110u;
    // 0x178110: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178110u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178114: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178114u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178118: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178118u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17811c: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x17811cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x178120: 0xc065508  jal         func_195420
    ctx->pc = 0x178120u;
    SET_GPR_U32(ctx, 31, 0x178128u);
    ctx->pc = 0x178124u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178120u;
            // 0x178124: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178128u; }
        if (ctx->pc != 0x178128u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178128u; }
        if (ctx->pc != 0x178128u) { return; }
    }
    ctx->pc = 0x178128u;
    // 0x178128: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178128u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17812c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17812cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178130: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x178130u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x178134: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178134u;
    SET_GPR_U32(ctx, 31, 0x17813Cu);
    ctx->pc = 0x178138u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178134u;
            // 0x178138: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17813Cu; }
        if (ctx->pc != 0x17813Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17813Cu; }
        if (ctx->pc != 0x17813Cu) { return; }
    }
    ctx->pc = 0x17813Cu;
    // 0x17813c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17813cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178140: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178140u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178144: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178144u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178148: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x178148u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x17814c: 0xc065508  jal         func_195420
    ctx->pc = 0x17814Cu;
    SET_GPR_U32(ctx, 31, 0x178154u);
    ctx->pc = 0x178150u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17814Cu;
            // 0x178150: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178154u; }
        if (ctx->pc != 0x178154u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178154u; }
        if (ctx->pc != 0x178154u) { return; }
    }
    ctx->pc = 0x178154u;
    // 0x178154: 0x0  nop
    ctx->pc = 0x178154u;
    // NOP
label_178158:
    // 0x178158: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178158u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17815c: 0x24020078  addiu       $v0, $zero, 0x78
    ctx->pc = 0x17815cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 120));
    // 0x178160: 0x2463000a  addiu       $v1, $v1, 0xA
    ctx->pc = 0x178160u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 10));
    // 0x178164: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178164u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178168: 0x0  nop
    ctx->pc = 0x178168u;
    // NOP
    // 0x17816c: 0x0  nop
    ctx->pc = 0x17816cu;
    // NOP
    // 0x178170: 0x1010  mfhi        $v0
    ctx->pc = 0x178170u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178174: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x178174u;
    {
        const bool branch_taken_0x178174 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178174) {
            ctx->pc = 0x178220u;
            goto label_178220;
        }
    }
    ctx->pc = 0x17817Cu;
    // 0x17817c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17817cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178180: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178180u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178184: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178184u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178188: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x178188u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17818c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17818cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178190: 0x0  nop
    ctx->pc = 0x178190u;
    // NOP
    // 0x178194: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178194u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178198: 0xc05d080  jal         func_174200
    ctx->pc = 0x178198u;
    SET_GPR_U32(ctx, 31, 0x1781A0u);
    ctx->pc = 0x17819Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178198u;
            // 0x17819c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1781A0u; }
        if (ctx->pc != 0x1781A0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1781A0u; }
        if (ctx->pc != 0x1781A0u) { return; }
    }
    ctx->pc = 0x1781A0u;
    // 0x1781a0: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1781a0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1781a4: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1781a4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1781a8: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1781a8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1781ac: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x1781acu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x1781b0: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1781b0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1781b4: 0x0  nop
    ctx->pc = 0x1781b4u;
    // NOP
    // 0x1781b8: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1781b8u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1781bc: 0xc05d080  jal         func_174200
    ctx->pc = 0x1781BCu;
    SET_GPR_U32(ctx, 31, 0x1781C4u);
    ctx->pc = 0x1781C0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1781BCu;
            // 0x1781c0: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1781C4u; }
        if (ctx->pc != 0x1781C4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1781C4u; }
        if (ctx->pc != 0x1781C4u) { return; }
    }
    ctx->pc = 0x1781C4u;
    // 0x1781c4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1781c4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1781c8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1781c8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1781cc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x1781ccu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x1781d0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1781D0u;
    SET_GPR_U32(ctx, 31, 0x1781D8u);
    ctx->pc = 0x1781D4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1781D0u;
            // 0x1781d4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1781D8u; }
        if (ctx->pc != 0x1781D8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1781D8u; }
        if (ctx->pc != 0x1781D8u) { return; }
    }
    ctx->pc = 0x1781D8u;
    // 0x1781d8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1781d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1781dc: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x1781dcu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x1781e0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1781e0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1781e4: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x1781e4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x1781e8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x1781E8u;
    SET_GPR_U32(ctx, 31, 0x1781F0u);
    ctx->pc = 0x1781ECu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1781E8u;
            // 0x1781ec: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1781F0u; }
        if (ctx->pc != 0x1781F0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1781F0u; }
        if (ctx->pc != 0x1781F0u) { return; }
    }
    ctx->pc = 0x1781F0u;
    // 0x1781f0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1781f0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1781f4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1781f4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1781f8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x1781f8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x1781fc: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1781FCu;
    SET_GPR_U32(ctx, 31, 0x178204u);
    ctx->pc = 0x178200u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1781FCu;
            // 0x178200: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178204u; }
        if (ctx->pc != 0x178204u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178204u; }
        if (ctx->pc != 0x178204u) { return; }
    }
    ctx->pc = 0x178204u;
    // 0x178204: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178204u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178208: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178208u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17820c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17820cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178210: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178210u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178214: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178214u;
    SET_GPR_U32(ctx, 31, 0x17821Cu);
    ctx->pc = 0x178218u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178214u;
            // 0x178218: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17821Cu; }
        if (ctx->pc != 0x17821Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17821Cu; }
        if (ctx->pc != 0x17821Cu) { return; }
    }
    ctx->pc = 0x17821Cu;
    // 0x17821c: 0x0  nop
    ctx->pc = 0x17821cu;
    // NOP
label_178220:
    // 0x178220: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178220u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178224: 0x2402003c  addiu       $v0, $zero, 0x3C
    ctx->pc = 0x178224u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 60));
    // 0x178228: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178228u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17822c: 0x0  nop
    ctx->pc = 0x17822cu;
    // NOP
    // 0x178230: 0x0  nop
    ctx->pc = 0x178230u;
    // NOP
    // 0x178234: 0x1010  mfhi        $v0
    ctx->pc = 0x178234u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178238: 0x144008ed  bnez        $v0, . + 4 + (0x8ED << 2)
    ctx->pc = 0x178238u;
    {
        const bool branch_taken_0x178238 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178238) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x178240u;
    // 0x178240: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178240u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178244: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178244u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178248: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x178248u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x17824c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17824Cu;
    SET_GPR_U32(ctx, 31, 0x178254u);
    ctx->pc = 0x178250u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17824Cu;
            // 0x178250: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178254u; }
        if (ctx->pc != 0x178254u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178254u; }
        if (ctx->pc != 0x178254u) { return; }
    }
    ctx->pc = 0x178254u;
    // 0x178254: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178254u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178258: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178258u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17825c: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x17825cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x178260: 0xc06560c  jal         func_195830
    ctx->pc = 0x178260u;
    SET_GPR_U32(ctx, 31, 0x178268u);
    ctx->pc = 0x178264u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178260u;
            // 0x178264: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178268u; }
        if (ctx->pc != 0x178268u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178268u; }
        if (ctx->pc != 0x178268u) { return; }
    }
    ctx->pc = 0x178268u;
    // 0x178268: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178268u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17826c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17826cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178270: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x178270u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x178274: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178274u;
    SET_GPR_U32(ctx, 31, 0x17827Cu);
    ctx->pc = 0x178278u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178274u;
            // 0x178278: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17827Cu; }
        if (ctx->pc != 0x17827Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17827Cu; }
        if (ctx->pc != 0x17827Cu) { return; }
    }
    ctx->pc = 0x17827Cu;
    // 0x17827c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17827cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178280: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178280u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178284: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x178284u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x178288: 0xc06560c  jal         func_195830
    ctx->pc = 0x178288u;
    SET_GPR_U32(ctx, 31, 0x178290u);
    ctx->pc = 0x17828Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178288u;
            // 0x17828c: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178290u; }
        if (ctx->pc != 0x178290u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178290u; }
        if (ctx->pc != 0x178290u) { return; }
    }
    ctx->pc = 0x178290u;
    // 0x178290: 0x100008d7  b           . + 4 + (0x8D7 << 2)
    ctx->pc = 0x178290u;
    {
        const bool branch_taken_0x178290 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x178290) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x178298u;
label_178298:
    // 0x178298: 0xc065d00  jal         func_197400
    ctx->pc = 0x178298u;
    SET_GPR_U32(ctx, 31, 0x1782A0u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1782A0u; }
        if (ctx->pc != 0x1782A0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1782A0u; }
        if (ctx->pc != 0x1782A0u) { return; }
    }
    ctx->pc = 0x1782A0u;
    // 0x1782a0: 0x1840008d  blez        $v0, . + 4 + (0x8D << 2)
    ctx->pc = 0x1782A0u;
    {
        const bool branch_taken_0x1782a0 = (GPR_S32(ctx, 2) <= 0);
        if (branch_taken_0x1782a0) {
            ctx->pc = 0x1784D8u;
            goto label_1784d8;
        }
    }
    ctx->pc = 0x1782A8u;
    // 0x1782a8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1782a8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1782ac: 0x24020104  addiu       $v0, $zero, 0x104
    ctx->pc = 0x1782acu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 260));
    // 0x1782b0: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x1782b0u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x1782b4: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1782b4u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1782b8: 0x0  nop
    ctx->pc = 0x1782b8u;
    // NOP
    // 0x1782bc: 0x0  nop
    ctx->pc = 0x1782bcu;
    // NOP
    // 0x1782c0: 0x1010  mfhi        $v0
    ctx->pc = 0x1782c0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1782c4: 0x14400034  bnez        $v0, . + 4 + (0x34 << 2)
    ctx->pc = 0x1782C4u;
    {
        const bool branch_taken_0x1782c4 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1782c4) {
            ctx->pc = 0x178398u;
            goto label_178398;
        }
    }
    ctx->pc = 0x1782CCu;
    // 0x1782cc: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1782ccu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1782d0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1782d0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1782d4: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x1782d4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x1782d8: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x1782d8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x1782dc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1782dcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1782e0: 0x0  nop
    ctx->pc = 0x1782e0u;
    // NOP
    // 0x1782e4: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1782e4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1782e8: 0xc05d080  jal         func_174200
    ctx->pc = 0x1782E8u;
    SET_GPR_U32(ctx, 31, 0x1782F0u);
    ctx->pc = 0x1782ECu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1782E8u;
            // 0x1782ec: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1782F0u; }
        if (ctx->pc != 0x1782F0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1782F0u; }
        if (ctx->pc != 0x1782F0u) { return; }
    }
    ctx->pc = 0x1782F0u;
    // 0x1782f0: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1782f0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1782f4: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1782f4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1782f8: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x1782f8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x1782fc: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x1782fcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x178300: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178300u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178304: 0x0  nop
    ctx->pc = 0x178304u;
    // NOP
    // 0x178308: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178308u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17830c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17830Cu;
    SET_GPR_U32(ctx, 31, 0x178314u);
    ctx->pc = 0x178310u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17830Cu;
            // 0x178310: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178314u; }
        if (ctx->pc != 0x178314u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178314u; }
        if (ctx->pc != 0x178314u) { return; }
    }
    ctx->pc = 0x178314u;
    // 0x178314: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178314u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178318: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x178318u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17831c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17831Cu;
    SET_GPR_U32(ctx, 31, 0x178324u);
    ctx->pc = 0x178320u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17831Cu;
            // 0x178320: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178324u; }
        if (ctx->pc != 0x178324u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178324u; }
        if (ctx->pc != 0x178324u) { return; }
    }
    ctx->pc = 0x178324u;
    // 0x178324: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x178324u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178328: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x178328u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x17832c: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x17832cu;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178330: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x178330u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x178334: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178334u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178338: 0xc065480  jal         func_195200
    ctx->pc = 0x178338u;
    SET_GPR_U32(ctx, 31, 0x178340u);
    ctx->pc = 0x17833Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178338u;
            // 0x17833c: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178340u; }
        if (ctx->pc != 0x178340u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178340u; }
        if (ctx->pc != 0x178340u) { return; }
    }
    ctx->pc = 0x178340u;
    // 0x178340: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178340u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178344: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178344u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178348: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x178348u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x17834c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17834Cu;
    SET_GPR_U32(ctx, 31, 0x178354u);
    ctx->pc = 0x178350u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17834Cu;
            // 0x178350: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178354u; }
        if (ctx->pc != 0x178354u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178354u; }
        if (ctx->pc != 0x178354u) { return; }
    }
    ctx->pc = 0x178354u;
    // 0x178354: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178354u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178358: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178358u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17835c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17835cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178360: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x178360u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x178364: 0xc065508  jal         func_195420
    ctx->pc = 0x178364u;
    SET_GPR_U32(ctx, 31, 0x17836Cu);
    ctx->pc = 0x178368u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178364u;
            // 0x178368: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17836Cu; }
        if (ctx->pc != 0x17836Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17836Cu; }
        if (ctx->pc != 0x17836Cu) { return; }
    }
    ctx->pc = 0x17836Cu;
    // 0x17836c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17836cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178370: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178370u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178374: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x178374u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x178378: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178378u;
    SET_GPR_U32(ctx, 31, 0x178380u);
    ctx->pc = 0x17837Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178378u;
            // 0x17837c: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178380u; }
        if (ctx->pc != 0x178380u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178380u; }
        if (ctx->pc != 0x178380u) { return; }
    }
    ctx->pc = 0x178380u;
    // 0x178380: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178380u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178384: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178384u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178388: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178388u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17838c: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x17838cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x178390: 0xc065508  jal         func_195420
    ctx->pc = 0x178390u;
    SET_GPR_U32(ctx, 31, 0x178398u);
    ctx->pc = 0x178394u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178390u;
            // 0x178394: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178398u; }
        if (ctx->pc != 0x178398u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178398u; }
        if (ctx->pc != 0x178398u) { return; }
    }
    ctx->pc = 0x178398u;
label_178398:
    // 0x178398: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178398u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17839c: 0x24020078  addiu       $v0, $zero, 0x78
    ctx->pc = 0x17839cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 120));
    // 0x1783a0: 0x2463000a  addiu       $v1, $v1, 0xA
    ctx->pc = 0x1783a0u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 10));
    // 0x1783a4: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1783a4u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1783a8: 0x0  nop
    ctx->pc = 0x1783a8u;
    // NOP
    // 0x1783ac: 0x0  nop
    ctx->pc = 0x1783acu;
    // NOP
    // 0x1783b0: 0x1010  mfhi        $v0
    ctx->pc = 0x1783b0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1783b4: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x1783B4u;
    {
        const bool branch_taken_0x1783b4 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1783b4) {
            ctx->pc = 0x178460u;
            goto label_178460;
        }
    }
    ctx->pc = 0x1783BCu;
    // 0x1783bc: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1783bcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1783c0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1783c0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1783c4: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1783c4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1783c8: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x1783c8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x1783cc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1783ccu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1783d0: 0x0  nop
    ctx->pc = 0x1783d0u;
    // NOP
    // 0x1783d4: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1783d4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1783d8: 0xc05d080  jal         func_174200
    ctx->pc = 0x1783D8u;
    SET_GPR_U32(ctx, 31, 0x1783E0u);
    ctx->pc = 0x1783DCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1783D8u;
            // 0x1783dc: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1783E0u; }
        if (ctx->pc != 0x1783E0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1783E0u; }
        if (ctx->pc != 0x1783E0u) { return; }
    }
    ctx->pc = 0x1783E0u;
    // 0x1783e0: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1783e0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1783e4: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1783e4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1783e8: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1783e8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1783ec: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x1783ecu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x1783f0: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1783f0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1783f4: 0x0  nop
    ctx->pc = 0x1783f4u;
    // NOP
    // 0x1783f8: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1783f8u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1783fc: 0xc05d080  jal         func_174200
    ctx->pc = 0x1783FCu;
    SET_GPR_U32(ctx, 31, 0x178404u);
    ctx->pc = 0x178400u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1783FCu;
            // 0x178400: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178404u; }
        if (ctx->pc != 0x178404u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178404u; }
        if (ctx->pc != 0x178404u) { return; }
    }
    ctx->pc = 0x178404u;
    // 0x178404: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178404u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178408: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178408u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17840c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17840cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178410: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178410u;
    SET_GPR_U32(ctx, 31, 0x178418u);
    ctx->pc = 0x178414u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178410u;
            // 0x178414: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178418u; }
        if (ctx->pc != 0x178418u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178418u; }
        if (ctx->pc != 0x178418u) { return; }
    }
    ctx->pc = 0x178418u;
    // 0x178418: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178418u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17841c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17841cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178420: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178420u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178424: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178424u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178428: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178428u;
    SET_GPR_U32(ctx, 31, 0x178430u);
    ctx->pc = 0x17842Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178428u;
            // 0x17842c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178430u; }
        if (ctx->pc != 0x178430u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178430u; }
        if (ctx->pc != 0x178430u) { return; }
    }
    ctx->pc = 0x178430u;
    // 0x178430: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178430u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178434: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178434u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178438: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178438u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17843c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17843Cu;
    SET_GPR_U32(ctx, 31, 0x178444u);
    ctx->pc = 0x178440u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17843Cu;
            // 0x178440: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178444u; }
        if (ctx->pc != 0x178444u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178444u; }
        if (ctx->pc != 0x178444u) { return; }
    }
    ctx->pc = 0x178444u;
    // 0x178444: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178444u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178448: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178448u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17844c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17844cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178450: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178450u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178454: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178454u;
    SET_GPR_U32(ctx, 31, 0x17845Cu);
    ctx->pc = 0x178458u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178454u;
            // 0x178458: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17845Cu; }
        if (ctx->pc != 0x17845Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17845Cu; }
        if (ctx->pc != 0x17845Cu) { return; }
    }
    ctx->pc = 0x17845Cu;
    // 0x17845c: 0x0  nop
    ctx->pc = 0x17845cu;
    // NOP
label_178460:
    // 0x178460: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178460u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178464: 0x24020078  addiu       $v0, $zero, 0x78
    ctx->pc = 0x178464u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 120));
    // 0x178468: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178468u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17846c: 0x0  nop
    ctx->pc = 0x17846cu;
    // NOP
    // 0x178470: 0x0  nop
    ctx->pc = 0x178470u;
    // NOP
    // 0x178474: 0x1010  mfhi        $v0
    ctx->pc = 0x178474u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178478: 0x1440085d  bnez        $v0, . + 4 + (0x85D << 2)
    ctx->pc = 0x178478u;
    {
        const bool branch_taken_0x178478 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178478) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x178480u;
    // 0x178480: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178480u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178484: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178484u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178488: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x178488u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x17848c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17848Cu;
    SET_GPR_U32(ctx, 31, 0x178494u);
    ctx->pc = 0x178490u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17848Cu;
            // 0x178490: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178494u; }
        if (ctx->pc != 0x178494u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178494u; }
        if (ctx->pc != 0x178494u) { return; }
    }
    ctx->pc = 0x178494u;
    // 0x178494: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178494u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178498: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178498u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17849c: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x17849cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x1784a0: 0xc06560c  jal         func_195830
    ctx->pc = 0x1784A0u;
    SET_GPR_U32(ctx, 31, 0x1784A8u);
    ctx->pc = 0x1784A4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1784A0u;
            // 0x1784a4: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1784A8u; }
        if (ctx->pc != 0x1784A8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1784A8u; }
        if (ctx->pc != 0x1784A8u) { return; }
    }
    ctx->pc = 0x1784A8u;
    // 0x1784a8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1784a8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1784ac: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1784acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1784b0: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x1784b0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x1784b4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1784B4u;
    SET_GPR_U32(ctx, 31, 0x1784BCu);
    ctx->pc = 0x1784B8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1784B4u;
            // 0x1784b8: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1784BCu; }
        if (ctx->pc != 0x1784BCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1784BCu; }
        if (ctx->pc != 0x1784BCu) { return; }
    }
    ctx->pc = 0x1784BCu;
    // 0x1784bc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1784bcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1784c0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1784c0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1784c4: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x1784c4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x1784c8: 0xc06560c  jal         func_195830
    ctx->pc = 0x1784C8u;
    SET_GPR_U32(ctx, 31, 0x1784D0u);
    ctx->pc = 0x1784CCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1784C8u;
            // 0x1784cc: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1784D0u; }
        if (ctx->pc != 0x1784D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1784D0u; }
        if (ctx->pc != 0x1784D0u) { return; }
    }
    ctx->pc = 0x1784D0u;
    // 0x1784d0: 0x10000847  b           . + 4 + (0x847 << 2)
    ctx->pc = 0x1784D0u;
    {
        const bool branch_taken_0x1784d0 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x1784d0) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x1784D8u;
label_1784d8:
    // 0x1784d8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1784d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1784dc: 0x24020078  addiu       $v0, $zero, 0x78
    ctx->pc = 0x1784dcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 120));
    // 0x1784e0: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1784e0u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1784e4: 0x0  nop
    ctx->pc = 0x1784e4u;
    // NOP
    // 0x1784e8: 0x0  nop
    ctx->pc = 0x1784e8u;
    // NOP
    // 0x1784ec: 0x1010  mfhi        $v0
    ctx->pc = 0x1784ecu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1784f0: 0x1440083f  bnez        $v0, . + 4 + (0x83F << 2)
    ctx->pc = 0x1784F0u;
    {
        const bool branch_taken_0x1784f0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1784f0) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x1784F8u;
    // 0x1784f8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1784f8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1784fc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1784fcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178500: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x178500u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x178504: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178504u;
    SET_GPR_U32(ctx, 31, 0x17850Cu);
    ctx->pc = 0x178508u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178504u;
            // 0x178508: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17850Cu; }
        if (ctx->pc != 0x17850Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17850Cu; }
        if (ctx->pc != 0x17850Cu) { return; }
    }
    ctx->pc = 0x17850Cu;
    // 0x17850c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17850cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178510: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178510u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178514: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x178514u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x178518: 0xc06560c  jal         func_195830
    ctx->pc = 0x178518u;
    SET_GPR_U32(ctx, 31, 0x178520u);
    ctx->pc = 0x17851Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178518u;
            // 0x17851c: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178520u; }
        if (ctx->pc != 0x178520u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178520u; }
        if (ctx->pc != 0x178520u) { return; }
    }
    ctx->pc = 0x178520u;
    // 0x178520: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178520u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178524: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178524u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178528: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x178528u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x17852c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17852Cu;
    SET_GPR_U32(ctx, 31, 0x178534u);
    ctx->pc = 0x178530u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17852Cu;
            // 0x178530: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178534u; }
        if (ctx->pc != 0x178534u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178534u; }
        if (ctx->pc != 0x178534u) { return; }
    }
    ctx->pc = 0x178534u;
    // 0x178534: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178534u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178538: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178538u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17853c: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x17853cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x178540: 0xc06560c  jal         func_195830
    ctx->pc = 0x178540u;
    SET_GPR_U32(ctx, 31, 0x178548u);
    ctx->pc = 0x178544u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178540u;
            // 0x178544: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178548u; }
        if (ctx->pc != 0x178548u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178548u; }
        if (ctx->pc != 0x178548u) { return; }
    }
    ctx->pc = 0x178548u;
    // 0x178548: 0x10000829  b           . + 4 + (0x829 << 2)
    ctx->pc = 0x178548u;
    {
        const bool branch_taken_0x178548 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x178548) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x178550u;
label_178550:
    // 0x178550: 0xc065d00  jal         func_197400
    ctx->pc = 0x178550u;
    SET_GPR_U32(ctx, 31, 0x178558u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178558u; }
        if (ctx->pc != 0x178558u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178558u; }
        if (ctx->pc != 0x178558u) { return; }
    }
    ctx->pc = 0x178558u;
    // 0x178558: 0x28410002  slti        $at, $v0, 0x2
    ctx->pc = 0x178558u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)2) ? 1 : 0);
    // 0x17855c: 0x142000f2  bnez        $at, . + 4 + (0xF2 << 2)
    ctx->pc = 0x17855Cu;
    {
        const bool branch_taken_0x17855c = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x17855c) {
            ctx->pc = 0x178928u;
            goto label_178928;
        }
    }
    ctx->pc = 0x178564u;
    // 0x178564: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178564u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178568: 0x24020078  addiu       $v0, $zero, 0x78
    ctx->pc = 0x178568u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 120));
    // 0x17856c: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x17856cu;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x178570: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178570u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178574: 0x0  nop
    ctx->pc = 0x178574u;
    // NOP
    // 0x178578: 0x0  nop
    ctx->pc = 0x178578u;
    // NOP
    // 0x17857c: 0x1010  mfhi        $v0
    ctx->pc = 0x17857cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178580: 0x14400035  bnez        $v0, . + 4 + (0x35 << 2)
    ctx->pc = 0x178580u;
    {
        const bool branch_taken_0x178580 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178580) {
            ctx->pc = 0x178658u;
            goto label_178658;
        }
    }
    ctx->pc = 0x178588u;
    // 0x178588: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178588u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17858c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17858cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178590: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x178590u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x178594: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x178594u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x178598: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178598u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17859c: 0x0  nop
    ctx->pc = 0x17859cu;
    // NOP
    // 0x1785a0: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1785a0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1785a4: 0xc05d080  jal         func_174200
    ctx->pc = 0x1785A4u;
    SET_GPR_U32(ctx, 31, 0x1785ACu);
    ctx->pc = 0x1785A8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1785A4u;
            // 0x1785a8: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1785ACu; }
        if (ctx->pc != 0x1785ACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1785ACu; }
        if (ctx->pc != 0x1785ACu) { return; }
    }
    ctx->pc = 0x1785ACu;
    // 0x1785ac: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1785acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1785b0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1785b0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1785b4: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x1785b4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x1785b8: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x1785b8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x1785bc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1785bcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1785c0: 0x0  nop
    ctx->pc = 0x1785c0u;
    // NOP
    // 0x1785c4: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1785c4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1785c8: 0xc05d080  jal         func_174200
    ctx->pc = 0x1785C8u;
    SET_GPR_U32(ctx, 31, 0x1785D0u);
    ctx->pc = 0x1785CCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1785C8u;
            // 0x1785cc: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1785D0u; }
        if (ctx->pc != 0x1785D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1785D0u; }
        if (ctx->pc != 0x1785D0u) { return; }
    }
    ctx->pc = 0x1785D0u;
    // 0x1785d0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1785d0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1785d4: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x1785d4u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1785d8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1785D8u;
    SET_GPR_U32(ctx, 31, 0x1785E0u);
    ctx->pc = 0x1785DCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1785D8u;
            // 0x1785dc: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1785E0u; }
        if (ctx->pc != 0x1785E0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1785E0u; }
        if (ctx->pc != 0x1785E0u) { return; }
    }
    ctx->pc = 0x1785E0u;
    // 0x1785e0: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x1785e0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1785e4: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x1785e4u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x1785e8: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x1785e8u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1785ec: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x1785ecu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x1785f0: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x1785f0u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x1785f4: 0xc065480  jal         func_195200
    ctx->pc = 0x1785F4u;
    SET_GPR_U32(ctx, 31, 0x1785FCu);
    ctx->pc = 0x1785F8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1785F4u;
            // 0x1785f8: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1785FCu; }
        if (ctx->pc != 0x1785FCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1785FCu; }
        if (ctx->pc != 0x1785FCu) { return; }
    }
    ctx->pc = 0x1785FCu;
    // 0x1785fc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1785fcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178600: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178600u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178604: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x178604u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x178608: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178608u;
    SET_GPR_U32(ctx, 31, 0x178610u);
    ctx->pc = 0x17860Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178608u;
            // 0x17860c: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178610u; }
        if (ctx->pc != 0x178610u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178610u; }
        if (ctx->pc != 0x178610u) { return; }
    }
    ctx->pc = 0x178610u;
    // 0x178610: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178610u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178614: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178614u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178618: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178618u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17861c: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x17861cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x178620: 0xc065508  jal         func_195420
    ctx->pc = 0x178620u;
    SET_GPR_U32(ctx, 31, 0x178628u);
    ctx->pc = 0x178624u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178620u;
            // 0x178624: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178628u; }
        if (ctx->pc != 0x178628u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178628u; }
        if (ctx->pc != 0x178628u) { return; }
    }
    ctx->pc = 0x178628u;
    // 0x178628: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178628u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17862c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17862cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178630: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x178630u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x178634: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178634u;
    SET_GPR_U32(ctx, 31, 0x17863Cu);
    ctx->pc = 0x178638u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178634u;
            // 0x178638: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17863Cu; }
        if (ctx->pc != 0x17863Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17863Cu; }
        if (ctx->pc != 0x17863Cu) { return; }
    }
    ctx->pc = 0x17863Cu;
    // 0x17863c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17863cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178640: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178640u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178644: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178644u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178648: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x178648u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x17864c: 0xc065508  jal         func_195420
    ctx->pc = 0x17864Cu;
    SET_GPR_U32(ctx, 31, 0x178654u);
    ctx->pc = 0x178650u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17864Cu;
            // 0x178650: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178654u; }
        if (ctx->pc != 0x178654u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178654u; }
        if (ctx->pc != 0x178654u) { return; }
    }
    ctx->pc = 0x178654u;
    // 0x178654: 0x0  nop
    ctx->pc = 0x178654u;
    // NOP
label_178658:
    // 0x178658: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178658u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17865c: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x17865cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x178660: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x178660u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x178664: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178664u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178668: 0x0  nop
    ctx->pc = 0x178668u;
    // NOP
    // 0x17866c: 0x0  nop
    ctx->pc = 0x17866cu;
    // NOP
    // 0x178670: 0x1010  mfhi        $v0
    ctx->pc = 0x178670u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178674: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x178674u;
    {
        const bool branch_taken_0x178674 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178674) {
            ctx->pc = 0x178720u;
            goto label_178720;
        }
    }
    ctx->pc = 0x17867Cu;
    // 0x17867c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17867cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178680: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178680u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178684: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178684u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178688: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x178688u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17868c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17868cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178690: 0x0  nop
    ctx->pc = 0x178690u;
    // NOP
    // 0x178694: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178694u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178698: 0xc05d080  jal         func_174200
    ctx->pc = 0x178698u;
    SET_GPR_U32(ctx, 31, 0x1786A0u);
    ctx->pc = 0x17869Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178698u;
            // 0x17869c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1786A0u; }
        if (ctx->pc != 0x1786A0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1786A0u; }
        if (ctx->pc != 0x1786A0u) { return; }
    }
    ctx->pc = 0x1786A0u;
    // 0x1786a0: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1786a0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1786a4: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1786a4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1786a8: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1786a8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1786ac: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x1786acu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x1786b0: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1786b0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1786b4: 0x0  nop
    ctx->pc = 0x1786b4u;
    // NOP
    // 0x1786b8: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1786b8u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1786bc: 0xc05d080  jal         func_174200
    ctx->pc = 0x1786BCu;
    SET_GPR_U32(ctx, 31, 0x1786C4u);
    ctx->pc = 0x1786C0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1786BCu;
            // 0x1786c0: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1786C4u; }
        if (ctx->pc != 0x1786C4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1786C4u; }
        if (ctx->pc != 0x1786C4u) { return; }
    }
    ctx->pc = 0x1786C4u;
    // 0x1786c4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1786c4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1786c8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1786c8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1786cc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x1786ccu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x1786d0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1786D0u;
    SET_GPR_U32(ctx, 31, 0x1786D8u);
    ctx->pc = 0x1786D4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1786D0u;
            // 0x1786d4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1786D8u; }
        if (ctx->pc != 0x1786D8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1786D8u; }
        if (ctx->pc != 0x1786D8u) { return; }
    }
    ctx->pc = 0x1786D8u;
    // 0x1786d8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1786d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1786dc: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x1786dcu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x1786e0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1786e0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1786e4: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x1786e4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x1786e8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x1786E8u;
    SET_GPR_U32(ctx, 31, 0x1786F0u);
    ctx->pc = 0x1786ECu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1786E8u;
            // 0x1786ec: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1786F0u; }
        if (ctx->pc != 0x1786F0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1786F0u; }
        if (ctx->pc != 0x1786F0u) { return; }
    }
    ctx->pc = 0x1786F0u;
    // 0x1786f0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1786f0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1786f4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1786f4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1786f8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x1786f8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x1786fc: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1786FCu;
    SET_GPR_U32(ctx, 31, 0x178704u);
    ctx->pc = 0x178700u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1786FCu;
            // 0x178700: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178704u; }
        if (ctx->pc != 0x178704u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178704u; }
        if (ctx->pc != 0x178704u) { return; }
    }
    ctx->pc = 0x178704u;
    // 0x178704: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178704u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178708: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178708u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17870c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17870cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178710: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178710u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178714: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178714u;
    SET_GPR_U32(ctx, 31, 0x17871Cu);
    ctx->pc = 0x178718u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178714u;
            // 0x178718: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17871Cu; }
        if (ctx->pc != 0x17871Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17871Cu; }
        if (ctx->pc != 0x17871Cu) { return; }
    }
    ctx->pc = 0x17871Cu;
    // 0x17871c: 0x0  nop
    ctx->pc = 0x17871cu;
    // NOP
label_178720:
    // 0x178720: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178720u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178724: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x178724u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x178728: 0x2463000f  addiu       $v1, $v1, 0xF
    ctx->pc = 0x178728u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 15));
    // 0x17872c: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17872cu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178730: 0x0  nop
    ctx->pc = 0x178730u;
    // NOP
    // 0x178734: 0x0  nop
    ctx->pc = 0x178734u;
    // NOP
    // 0x178738: 0x1010  mfhi        $v0
    ctx->pc = 0x178738u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17873c: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x17873Cu;
    {
        const bool branch_taken_0x17873c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17873c) {
            ctx->pc = 0x1787E8u;
            goto label_1787e8;
        }
    }
    ctx->pc = 0x178744u;
    // 0x178744: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178744u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178748: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178748u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17874c: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17874cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178750: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x178750u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x178754: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178754u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178758: 0x0  nop
    ctx->pc = 0x178758u;
    // NOP
    // 0x17875c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17875cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178760: 0xc05d080  jal         func_174200
    ctx->pc = 0x178760u;
    SET_GPR_U32(ctx, 31, 0x178768u);
    ctx->pc = 0x178764u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178760u;
            // 0x178764: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178768u; }
        if (ctx->pc != 0x178768u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178768u; }
        if (ctx->pc != 0x178768u) { return; }
    }
    ctx->pc = 0x178768u;
    // 0x178768: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178768u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17876c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17876cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178770: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178770u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178774: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x178774u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x178778: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178778u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17877c: 0x0  nop
    ctx->pc = 0x17877cu;
    // NOP
    // 0x178780: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178780u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178784: 0xc05d080  jal         func_174200
    ctx->pc = 0x178784u;
    SET_GPR_U32(ctx, 31, 0x17878Cu);
    ctx->pc = 0x178788u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178784u;
            // 0x178788: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17878Cu; }
        if (ctx->pc != 0x17878Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17878Cu; }
        if (ctx->pc != 0x17878Cu) { return; }
    }
    ctx->pc = 0x17878Cu;
    // 0x17878c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17878cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178790: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178790u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178794: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178794u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178798: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178798u;
    SET_GPR_U32(ctx, 31, 0x1787A0u);
    ctx->pc = 0x17879Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178798u;
            // 0x17879c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1787A0u; }
        if (ctx->pc != 0x1787A0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1787A0u; }
        if (ctx->pc != 0x1787A0u) { return; }
    }
    ctx->pc = 0x1787A0u;
    // 0x1787a0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1787a0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1787a4: 0x24060006  addiu       $a2, $zero, 0x6
    ctx->pc = 0x1787a4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 6));
    // 0x1787a8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1787a8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1787ac: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x1787acu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x1787b0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x1787B0u;
    SET_GPR_U32(ctx, 31, 0x1787B8u);
    ctx->pc = 0x1787B4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1787B0u;
            // 0x1787b4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1787B8u; }
        if (ctx->pc != 0x1787B8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1787B8u; }
        if (ctx->pc != 0x1787B8u) { return; }
    }
    ctx->pc = 0x1787B8u;
    // 0x1787b8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1787b8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1787bc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1787bcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1787c0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x1787c0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x1787c4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1787C4u;
    SET_GPR_U32(ctx, 31, 0x1787CCu);
    ctx->pc = 0x1787C8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1787C4u;
            // 0x1787c8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1787CCu; }
        if (ctx->pc != 0x1787CCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1787CCu; }
        if (ctx->pc != 0x1787CCu) { return; }
    }
    ctx->pc = 0x1787CCu;
    // 0x1787cc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1787ccu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1787d0: 0x24060072  addiu       $a2, $zero, 0x72
    ctx->pc = 0x1787d0u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 114));
    // 0x1787d4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1787d4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1787d8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x1787d8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x1787dc: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x1787DCu;
    SET_GPR_U32(ctx, 31, 0x1787E4u);
    ctx->pc = 0x1787E0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1787DCu;
            // 0x1787e0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1787E4u; }
        if (ctx->pc != 0x1787E4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1787E4u; }
        if (ctx->pc != 0x1787E4u) { return; }
    }
    ctx->pc = 0x1787E4u;
    // 0x1787e4: 0x0  nop
    ctx->pc = 0x1787e4u;
    // NOP
label_1787e8:
    // 0x1787e8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1787e8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1787ec: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x1787ecu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x1787f0: 0x2463000a  addiu       $v1, $v1, 0xA
    ctx->pc = 0x1787f0u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 10));
    // 0x1787f4: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1787f4u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1787f8: 0x0  nop
    ctx->pc = 0x1787f8u;
    // NOP
    // 0x1787fc: 0x0  nop
    ctx->pc = 0x1787fcu;
    // NOP
    // 0x178800: 0x1010  mfhi        $v0
    ctx->pc = 0x178800u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178804: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x178804u;
    {
        const bool branch_taken_0x178804 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178804) {
            ctx->pc = 0x1788B0u;
            goto label_1788b0;
        }
    }
    ctx->pc = 0x17880Cu;
    // 0x17880c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17880cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178810: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178810u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178814: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178814u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178818: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x178818u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17881c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17881cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178820: 0x0  nop
    ctx->pc = 0x178820u;
    // NOP
    // 0x178824: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178824u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178828: 0xc05d080  jal         func_174200
    ctx->pc = 0x178828u;
    SET_GPR_U32(ctx, 31, 0x178830u);
    ctx->pc = 0x17882Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178828u;
            // 0x17882c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178830u; }
        if (ctx->pc != 0x178830u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178830u; }
        if (ctx->pc != 0x178830u) { return; }
    }
    ctx->pc = 0x178830u;
    // 0x178830: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178830u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178834: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178834u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178838: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178838u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17883c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17883cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x178840: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178840u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178844: 0x0  nop
    ctx->pc = 0x178844u;
    // NOP
    // 0x178848: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178848u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17884c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17884Cu;
    SET_GPR_U32(ctx, 31, 0x178854u);
    ctx->pc = 0x178850u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17884Cu;
            // 0x178850: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178854u; }
        if (ctx->pc != 0x178854u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178854u; }
        if (ctx->pc != 0x178854u) { return; }
    }
    ctx->pc = 0x178854u;
    // 0x178854: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178854u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178858: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178858u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17885c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17885cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178860: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178860u;
    SET_GPR_U32(ctx, 31, 0x178868u);
    ctx->pc = 0x178864u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178860u;
            // 0x178864: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178868u; }
        if (ctx->pc != 0x178868u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178868u; }
        if (ctx->pc != 0x178868u) { return; }
    }
    ctx->pc = 0x178868u;
    // 0x178868: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178868u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17886c: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17886cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x178870: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178870u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178874: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178874u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178878: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178878u;
    SET_GPR_U32(ctx, 31, 0x178880u);
    ctx->pc = 0x17887Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178878u;
            // 0x17887c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178880u; }
        if (ctx->pc != 0x178880u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178880u; }
        if (ctx->pc != 0x178880u) { return; }
    }
    ctx->pc = 0x178880u;
    // 0x178880: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178880u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178884: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178884u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178888: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178888u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17888c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17888Cu;
    SET_GPR_U32(ctx, 31, 0x178894u);
    ctx->pc = 0x178890u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17888Cu;
            // 0x178890: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178894u; }
        if (ctx->pc != 0x178894u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178894u; }
        if (ctx->pc != 0x178894u) { return; }
    }
    ctx->pc = 0x178894u;
    // 0x178894: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178894u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178898: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x178898u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17889c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17889cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1788a0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x1788a0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x1788a4: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x1788A4u;
    SET_GPR_U32(ctx, 31, 0x1788ACu);
    ctx->pc = 0x1788A8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1788A4u;
            // 0x1788a8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1788ACu; }
        if (ctx->pc != 0x1788ACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1788ACu; }
        if (ctx->pc != 0x1788ACu) { return; }
    }
    ctx->pc = 0x1788ACu;
    // 0x1788ac: 0x0  nop
    ctx->pc = 0x1788acu;
    // NOP
label_1788b0:
    // 0x1788b0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1788b0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1788b4: 0x2402002d  addiu       $v0, $zero, 0x2D
    ctx->pc = 0x1788b4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 45));
    // 0x1788b8: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1788b8u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1788bc: 0x0  nop
    ctx->pc = 0x1788bcu;
    // NOP
    // 0x1788c0: 0x0  nop
    ctx->pc = 0x1788c0u;
    // NOP
    // 0x1788c4: 0x1010  mfhi        $v0
    ctx->pc = 0x1788c4u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1788c8: 0x14400749  bnez        $v0, . + 4 + (0x749 << 2)
    ctx->pc = 0x1788C8u;
    {
        const bool branch_taken_0x1788c8 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1788c8) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x1788D0u;
    // 0x1788d0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1788d0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1788d4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1788d4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1788d8: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x1788d8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x1788dc: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1788DCu;
    SET_GPR_U32(ctx, 31, 0x1788E4u);
    ctx->pc = 0x1788E0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1788DCu;
            // 0x1788e0: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1788E4u; }
        if (ctx->pc != 0x1788E4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1788E4u; }
        if (ctx->pc != 0x1788E4u) { return; }
    }
    ctx->pc = 0x1788E4u;
    // 0x1788e4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1788e4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1788e8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1788e8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1788ec: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x1788ecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x1788f0: 0xc06560c  jal         func_195830
    ctx->pc = 0x1788F0u;
    SET_GPR_U32(ctx, 31, 0x1788F8u);
    ctx->pc = 0x1788F4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1788F0u;
            // 0x1788f4: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1788F8u; }
        if (ctx->pc != 0x1788F8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1788F8u; }
        if (ctx->pc != 0x1788F8u) { return; }
    }
    ctx->pc = 0x1788F8u;
    // 0x1788f8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1788f8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1788fc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1788fcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178900: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x178900u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x178904: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178904u;
    SET_GPR_U32(ctx, 31, 0x17890Cu);
    ctx->pc = 0x178908u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178904u;
            // 0x178908: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17890Cu; }
        if (ctx->pc != 0x17890Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17890Cu; }
        if (ctx->pc != 0x17890Cu) { return; }
    }
    ctx->pc = 0x17890Cu;
    // 0x17890c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17890cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178910: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178910u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178914: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x178914u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x178918: 0xc06560c  jal         func_195830
    ctx->pc = 0x178918u;
    SET_GPR_U32(ctx, 31, 0x178920u);
    ctx->pc = 0x17891Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178918u;
            // 0x17891c: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178920u; }
        if (ctx->pc != 0x178920u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178920u; }
        if (ctx->pc != 0x178920u) { return; }
    }
    ctx->pc = 0x178920u;
    // 0x178920: 0x10000733  b           . + 4 + (0x733 << 2)
    ctx->pc = 0x178920u;
    {
        const bool branch_taken_0x178920 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x178920) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x178928u;
label_178928:
    // 0x178928: 0xc065d00  jal         func_197400
    ctx->pc = 0x178928u;
    SET_GPR_U32(ctx, 31, 0x178930u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178930u; }
        if (ctx->pc != 0x178930u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178930u; }
        if (ctx->pc != 0x178930u) { return; }
    }
    ctx->pc = 0x178930u;
    // 0x178930: 0x184000bf  blez        $v0, . + 4 + (0xBF << 2)
    ctx->pc = 0x178930u;
    {
        const bool branch_taken_0x178930 = (GPR_S32(ctx, 2) <= 0);
        if (branch_taken_0x178930) {
            ctx->pc = 0x178C30u;
            goto label_178c30;
        }
    }
    ctx->pc = 0x178938u;
    // 0x178938: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178938u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17893c: 0x240200f0  addiu       $v0, $zero, 0xF0
    ctx->pc = 0x17893cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 240));
    // 0x178940: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x178940u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x178944: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178944u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178948: 0x0  nop
    ctx->pc = 0x178948u;
    // NOP
    // 0x17894c: 0x0  nop
    ctx->pc = 0x17894cu;
    // NOP
    // 0x178950: 0x1010  mfhi        $v0
    ctx->pc = 0x178950u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178954: 0x14400034  bnez        $v0, . + 4 + (0x34 << 2)
    ctx->pc = 0x178954u;
    {
        const bool branch_taken_0x178954 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178954) {
            ctx->pc = 0x178A28u;
            goto label_178a28;
        }
    }
    ctx->pc = 0x17895Cu;
    // 0x17895c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17895cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178960: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178960u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178964: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x178964u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x178968: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x178968u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x17896c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17896cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178970: 0x0  nop
    ctx->pc = 0x178970u;
    // NOP
    // 0x178974: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178974u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178978: 0xc05d080  jal         func_174200
    ctx->pc = 0x178978u;
    SET_GPR_U32(ctx, 31, 0x178980u);
    ctx->pc = 0x17897Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178978u;
            // 0x17897c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178980u; }
        if (ctx->pc != 0x178980u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178980u; }
        if (ctx->pc != 0x178980u) { return; }
    }
    ctx->pc = 0x178980u;
    // 0x178980: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178980u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178984: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178984u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178988: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x178988u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17898c: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x17898cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x178990: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178990u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178994: 0x0  nop
    ctx->pc = 0x178994u;
    // NOP
    // 0x178998: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178998u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17899c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17899Cu;
    SET_GPR_U32(ctx, 31, 0x1789A4u);
    ctx->pc = 0x1789A0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17899Cu;
            // 0x1789a0: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1789A4u; }
        if (ctx->pc != 0x1789A4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1789A4u; }
        if (ctx->pc != 0x1789A4u) { return; }
    }
    ctx->pc = 0x1789A4u;
    // 0x1789a4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1789a4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1789a8: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x1789a8u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1789ac: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1789ACu;
    SET_GPR_U32(ctx, 31, 0x1789B4u);
    ctx->pc = 0x1789B0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1789ACu;
            // 0x1789b0: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1789B4u; }
        if (ctx->pc != 0x1789B4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1789B4u; }
        if (ctx->pc != 0x1789B4u) { return; }
    }
    ctx->pc = 0x1789B4u;
    // 0x1789b4: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x1789b4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1789b8: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x1789b8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x1789bc: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x1789bcu;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1789c0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x1789c0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x1789c4: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x1789c4u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x1789c8: 0xc065480  jal         func_195200
    ctx->pc = 0x1789C8u;
    SET_GPR_U32(ctx, 31, 0x1789D0u);
    ctx->pc = 0x1789CCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1789C8u;
            // 0x1789cc: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1789D0u; }
        if (ctx->pc != 0x1789D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1789D0u; }
        if (ctx->pc != 0x1789D0u) { return; }
    }
    ctx->pc = 0x1789D0u;
    // 0x1789d0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1789d0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1789d4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1789d4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1789d8: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x1789d8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x1789dc: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1789DCu;
    SET_GPR_U32(ctx, 31, 0x1789E4u);
    ctx->pc = 0x1789E0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1789DCu;
            // 0x1789e0: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1789E4u; }
        if (ctx->pc != 0x1789E4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1789E4u; }
        if (ctx->pc != 0x1789E4u) { return; }
    }
    ctx->pc = 0x1789E4u;
    // 0x1789e4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1789e4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1789e8: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x1789e8u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x1789ec: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1789ecu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1789f0: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x1789f0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x1789f4: 0xc065508  jal         func_195420
    ctx->pc = 0x1789F4u;
    SET_GPR_U32(ctx, 31, 0x1789FCu);
    ctx->pc = 0x1789F8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1789F4u;
            // 0x1789f8: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1789FCu; }
        if (ctx->pc != 0x1789FCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1789FCu; }
        if (ctx->pc != 0x1789FCu) { return; }
    }
    ctx->pc = 0x1789FCu;
    // 0x1789fc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1789fcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178a00: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178a00u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178a04: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x178a04u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x178a08: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178A08u;
    SET_GPR_U32(ctx, 31, 0x178A10u);
    ctx->pc = 0x178A0Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178A08u;
            // 0x178a0c: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178A10u; }
        if (ctx->pc != 0x178A10u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178A10u; }
        if (ctx->pc != 0x178A10u) { return; }
    }
    ctx->pc = 0x178A10u;
    // 0x178a10: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178a10u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178a14: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178a14u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178a18: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178a18u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178a1c: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x178a1cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x178a20: 0xc065508  jal         func_195420
    ctx->pc = 0x178A20u;
    SET_GPR_U32(ctx, 31, 0x178A28u);
    ctx->pc = 0x178A24u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178A20u;
            // 0x178a24: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178A28u; }
        if (ctx->pc != 0x178A28u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178A28u; }
        if (ctx->pc != 0x178A28u) { return; }
    }
    ctx->pc = 0x178A28u;
label_178a28:
    // 0x178a28: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178a28u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178a2c: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x178a2cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x178a30: 0x2463000f  addiu       $v1, $v1, 0xF
    ctx->pc = 0x178a30u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 15));
    // 0x178a34: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178a34u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178a38: 0x0  nop
    ctx->pc = 0x178a38u;
    // NOP
    // 0x178a3c: 0x0  nop
    ctx->pc = 0x178a3cu;
    // NOP
    // 0x178a40: 0x1010  mfhi        $v0
    ctx->pc = 0x178a40u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178a44: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x178A44u;
    {
        const bool branch_taken_0x178a44 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178a44) {
            ctx->pc = 0x178AF0u;
            goto label_178af0;
        }
    }
    ctx->pc = 0x178A4Cu;
    // 0x178a4c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178a4cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178a50: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178a50u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178a54: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178a54u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178a58: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x178a58u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x178a5c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178a5cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178a60: 0x0  nop
    ctx->pc = 0x178a60u;
    // NOP
    // 0x178a64: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178a64u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178a68: 0xc05d080  jal         func_174200
    ctx->pc = 0x178A68u;
    SET_GPR_U32(ctx, 31, 0x178A70u);
    ctx->pc = 0x178A6Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178A68u;
            // 0x178a6c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178A70u; }
        if (ctx->pc != 0x178A70u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178A70u; }
        if (ctx->pc != 0x178A70u) { return; }
    }
    ctx->pc = 0x178A70u;
    // 0x178a70: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178a70u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178a74: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178a74u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178a78: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178a78u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178a7c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x178a7cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x178a80: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178a80u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178a84: 0x0  nop
    ctx->pc = 0x178a84u;
    // NOP
    // 0x178a88: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178a88u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178a8c: 0xc05d080  jal         func_174200
    ctx->pc = 0x178A8Cu;
    SET_GPR_U32(ctx, 31, 0x178A94u);
    ctx->pc = 0x178A90u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178A8Cu;
            // 0x178a90: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178A94u; }
        if (ctx->pc != 0x178A94u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178A94u; }
        if (ctx->pc != 0x178A94u) { return; }
    }
    ctx->pc = 0x178A94u;
    // 0x178a94: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178a94u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178a98: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178a98u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178a9c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178a9cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178aa0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178AA0u;
    SET_GPR_U32(ctx, 31, 0x178AA8u);
    ctx->pc = 0x178AA4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178AA0u;
            // 0x178aa4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178AA8u; }
        if (ctx->pc != 0x178AA8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178AA8u; }
        if (ctx->pc != 0x178AA8u) { return; }
    }
    ctx->pc = 0x178AA8u;
    // 0x178aa8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178aa8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178aac: 0x24060006  addiu       $a2, $zero, 0x6
    ctx->pc = 0x178aacu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 6));
    // 0x178ab0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178ab0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178ab4: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178ab4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178ab8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178AB8u;
    SET_GPR_U32(ctx, 31, 0x178AC0u);
    ctx->pc = 0x178ABCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178AB8u;
            // 0x178abc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178AC0u; }
        if (ctx->pc != 0x178AC0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178AC0u; }
        if (ctx->pc != 0x178AC0u) { return; }
    }
    ctx->pc = 0x178AC0u;
    // 0x178ac0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178ac0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178ac4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178ac4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178ac8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178ac8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178acc: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178ACCu;
    SET_GPR_U32(ctx, 31, 0x178AD4u);
    ctx->pc = 0x178AD0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178ACCu;
            // 0x178ad0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178AD4u; }
        if (ctx->pc != 0x178AD4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178AD4u; }
        if (ctx->pc != 0x178AD4u) { return; }
    }
    ctx->pc = 0x178AD4u;
    // 0x178ad4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178ad4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178ad8: 0x24060072  addiu       $a2, $zero, 0x72
    ctx->pc = 0x178ad8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 114));
    // 0x178adc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178adcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178ae0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178ae0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178ae4: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178AE4u;
    SET_GPR_U32(ctx, 31, 0x178AECu);
    ctx->pc = 0x178AE8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178AE4u;
            // 0x178ae8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178AECu; }
        if (ctx->pc != 0x178AECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178AECu; }
        if (ctx->pc != 0x178AECu) { return; }
    }
    ctx->pc = 0x178AECu;
    // 0x178aec: 0x0  nop
    ctx->pc = 0x178aecu;
    // NOP
label_178af0:
    // 0x178af0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178af0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178af4: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x178af4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x178af8: 0x2463000a  addiu       $v1, $v1, 0xA
    ctx->pc = 0x178af8u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 10));
    // 0x178afc: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178afcu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178b00: 0x0  nop
    ctx->pc = 0x178b00u;
    // NOP
    // 0x178b04: 0x0  nop
    ctx->pc = 0x178b04u;
    // NOP
    // 0x178b08: 0x1010  mfhi        $v0
    ctx->pc = 0x178b08u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178b0c: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x178B0Cu;
    {
        const bool branch_taken_0x178b0c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178b0c) {
            ctx->pc = 0x178BB8u;
            goto label_178bb8;
        }
    }
    ctx->pc = 0x178B14u;
    // 0x178b14: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178b14u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178b18: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178b18u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178b1c: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178b1cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178b20: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x178b20u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x178b24: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178b24u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178b28: 0x0  nop
    ctx->pc = 0x178b28u;
    // NOP
    // 0x178b2c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178b2cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178b30: 0xc05d080  jal         func_174200
    ctx->pc = 0x178B30u;
    SET_GPR_U32(ctx, 31, 0x178B38u);
    ctx->pc = 0x178B34u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178B30u;
            // 0x178b34: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178B38u; }
        if (ctx->pc != 0x178B38u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178B38u; }
        if (ctx->pc != 0x178B38u) { return; }
    }
    ctx->pc = 0x178B38u;
    // 0x178b38: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178b38u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178b3c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178b3cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178b40: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178b40u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178b44: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x178b44u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x178b48: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178b48u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178b4c: 0x0  nop
    ctx->pc = 0x178b4cu;
    // NOP
    // 0x178b50: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178b50u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178b54: 0xc05d080  jal         func_174200
    ctx->pc = 0x178B54u;
    SET_GPR_U32(ctx, 31, 0x178B5Cu);
    ctx->pc = 0x178B58u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178B54u;
            // 0x178b58: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178B5Cu; }
        if (ctx->pc != 0x178B5Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178B5Cu; }
        if (ctx->pc != 0x178B5Cu) { return; }
    }
    ctx->pc = 0x178B5Cu;
    // 0x178b5c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178b5cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178b60: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178b60u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178b64: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178b64u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178b68: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178B68u;
    SET_GPR_U32(ctx, 31, 0x178B70u);
    ctx->pc = 0x178B6Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178B68u;
            // 0x178b6c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178B70u; }
        if (ctx->pc != 0x178B70u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178B70u; }
        if (ctx->pc != 0x178B70u) { return; }
    }
    ctx->pc = 0x178B70u;
    // 0x178b70: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178b70u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178b74: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x178b74u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x178b78: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178b78u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178b7c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178b7cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178b80: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178B80u;
    SET_GPR_U32(ctx, 31, 0x178B88u);
    ctx->pc = 0x178B84u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178B80u;
            // 0x178b84: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178B88u; }
        if (ctx->pc != 0x178B88u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178B88u; }
        if (ctx->pc != 0x178B88u) { return; }
    }
    ctx->pc = 0x178B88u;
    // 0x178b88: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178b88u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178b8c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178b8cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178b90: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178b90u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178b94: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178B94u;
    SET_GPR_U32(ctx, 31, 0x178B9Cu);
    ctx->pc = 0x178B98u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178B94u;
            // 0x178b98: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178B9Cu; }
        if (ctx->pc != 0x178B9Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178B9Cu; }
        if (ctx->pc != 0x178B9Cu) { return; }
    }
    ctx->pc = 0x178B9Cu;
    // 0x178b9c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178b9cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178ba0: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x178ba0u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x178ba4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178ba4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178ba8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178ba8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178bac: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178BACu;
    SET_GPR_U32(ctx, 31, 0x178BB4u);
    ctx->pc = 0x178BB0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178BACu;
            // 0x178bb0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178BB4u; }
        if (ctx->pc != 0x178BB4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178BB4u; }
        if (ctx->pc != 0x178BB4u) { return; }
    }
    ctx->pc = 0x178BB4u;
    // 0x178bb4: 0x0  nop
    ctx->pc = 0x178bb4u;
    // NOP
label_178bb8:
    // 0x178bb8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178bb8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178bbc: 0x2402002d  addiu       $v0, $zero, 0x2D
    ctx->pc = 0x178bbcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 45));
    // 0x178bc0: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178bc0u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178bc4: 0x0  nop
    ctx->pc = 0x178bc4u;
    // NOP
    // 0x178bc8: 0x0  nop
    ctx->pc = 0x178bc8u;
    // NOP
    // 0x178bcc: 0x1010  mfhi        $v0
    ctx->pc = 0x178bccu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178bd0: 0x14400687  bnez        $v0, . + 4 + (0x687 << 2)
    ctx->pc = 0x178BD0u;
    {
        const bool branch_taken_0x178bd0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178bd0) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x178BD8u;
    // 0x178bd8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178bd8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178bdc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178bdcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178be0: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x178be0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x178be4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178BE4u;
    SET_GPR_U32(ctx, 31, 0x178BECu);
    ctx->pc = 0x178BE8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178BE4u;
            // 0x178be8: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178BECu; }
        if (ctx->pc != 0x178BECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178BECu; }
        if (ctx->pc != 0x178BECu) { return; }
    }
    ctx->pc = 0x178BECu;
    // 0x178bec: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178becu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178bf0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178bf0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178bf4: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x178bf4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x178bf8: 0xc06560c  jal         func_195830
    ctx->pc = 0x178BF8u;
    SET_GPR_U32(ctx, 31, 0x178C00u);
    ctx->pc = 0x178BFCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178BF8u;
            // 0x178bfc: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178C00u; }
        if (ctx->pc != 0x178C00u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178C00u; }
        if (ctx->pc != 0x178C00u) { return; }
    }
    ctx->pc = 0x178C00u;
    // 0x178c00: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178c00u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178c04: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178c04u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178c08: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x178c08u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x178c0c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178C0Cu;
    SET_GPR_U32(ctx, 31, 0x178C14u);
    ctx->pc = 0x178C10u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178C0Cu;
            // 0x178c10: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178C14u; }
        if (ctx->pc != 0x178C14u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178C14u; }
        if (ctx->pc != 0x178C14u) { return; }
    }
    ctx->pc = 0x178C14u;
    // 0x178c14: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178c14u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178c18: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178c18u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178c1c: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x178c1cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x178c20: 0xc06560c  jal         func_195830
    ctx->pc = 0x178C20u;
    SET_GPR_U32(ctx, 31, 0x178C28u);
    ctx->pc = 0x178C24u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178C20u;
            // 0x178c24: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178C28u; }
        if (ctx->pc != 0x178C28u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178C28u; }
        if (ctx->pc != 0x178C28u) { return; }
    }
    ctx->pc = 0x178C28u;
    // 0x178c28: 0x10000671  b           . + 4 + (0x671 << 2)
    ctx->pc = 0x178C28u;
    {
        const bool branch_taken_0x178c28 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x178c28) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x178C30u;
label_178c30:
    // 0x178c30: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178c30u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178c34: 0x240200f0  addiu       $v0, $zero, 0xF0
    ctx->pc = 0x178c34u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 240));
    // 0x178c38: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x178c38u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x178c3c: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178c3cu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178c40: 0x0  nop
    ctx->pc = 0x178c40u;
    // NOP
    // 0x178c44: 0x0  nop
    ctx->pc = 0x178c44u;
    // NOP
    // 0x178c48: 0x1010  mfhi        $v0
    ctx->pc = 0x178c48u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178c4c: 0x14400034  bnez        $v0, . + 4 + (0x34 << 2)
    ctx->pc = 0x178C4Cu;
    {
        const bool branch_taken_0x178c4c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178c4c) {
            ctx->pc = 0x178D20u;
            goto label_178d20;
        }
    }
    ctx->pc = 0x178C54u;
    // 0x178c54: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178c54u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178c58: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178c58u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178c5c: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x178c5cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x178c60: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x178c60u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x178c64: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178c64u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178c68: 0x0  nop
    ctx->pc = 0x178c68u;
    // NOP
    // 0x178c6c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178c6cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178c70: 0xc05d080  jal         func_174200
    ctx->pc = 0x178C70u;
    SET_GPR_U32(ctx, 31, 0x178C78u);
    ctx->pc = 0x178C74u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178C70u;
            // 0x178c74: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178C78u; }
        if (ctx->pc != 0x178C78u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178C78u; }
        if (ctx->pc != 0x178C78u) { return; }
    }
    ctx->pc = 0x178C78u;
    // 0x178c78: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178c78u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178c7c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178c7cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178c80: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x178c80u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x178c84: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x178c84u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x178c88: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178c88u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178c8c: 0x0  nop
    ctx->pc = 0x178c8cu;
    // NOP
    // 0x178c90: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178c90u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178c94: 0xc05d080  jal         func_174200
    ctx->pc = 0x178C94u;
    SET_GPR_U32(ctx, 31, 0x178C9Cu);
    ctx->pc = 0x178C98u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178C94u;
            // 0x178c98: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178C9Cu; }
        if (ctx->pc != 0x178C9Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178C9Cu; }
        if (ctx->pc != 0x178C9Cu) { return; }
    }
    ctx->pc = 0x178C9Cu;
    // 0x178c9c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178c9cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178ca0: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x178ca0u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178ca4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178CA4u;
    SET_GPR_U32(ctx, 31, 0x178CACu);
    ctx->pc = 0x178CA8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178CA4u;
            // 0x178ca8: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178CACu; }
        if (ctx->pc != 0x178CACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178CACu; }
        if (ctx->pc != 0x178CACu) { return; }
    }
    ctx->pc = 0x178CACu;
    // 0x178cac: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x178cacu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178cb0: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x178cb0u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x178cb4: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x178cb4u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178cb8: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x178cb8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x178cbc: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178cbcu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178cc0: 0xc065480  jal         func_195200
    ctx->pc = 0x178CC0u;
    SET_GPR_U32(ctx, 31, 0x178CC8u);
    ctx->pc = 0x178CC4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178CC0u;
            // 0x178cc4: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178CC8u; }
        if (ctx->pc != 0x178CC8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178CC8u; }
        if (ctx->pc != 0x178CC8u) { return; }
    }
    ctx->pc = 0x178CC8u;
    // 0x178cc8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178cc8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178ccc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178cccu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178cd0: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x178cd0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x178cd4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178CD4u;
    SET_GPR_U32(ctx, 31, 0x178CDCu);
    ctx->pc = 0x178CD8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178CD4u;
            // 0x178cd8: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178CDCu; }
        if (ctx->pc != 0x178CDCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178CDCu; }
        if (ctx->pc != 0x178CDCu) { return; }
    }
    ctx->pc = 0x178CDCu;
    // 0x178cdc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178cdcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178ce0: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178ce0u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178ce4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178ce4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178ce8: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x178ce8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x178cec: 0xc065508  jal         func_195420
    ctx->pc = 0x178CECu;
    SET_GPR_U32(ctx, 31, 0x178CF4u);
    ctx->pc = 0x178CF0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178CECu;
            // 0x178cf0: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178CF4u; }
        if (ctx->pc != 0x178CF4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178CF4u; }
        if (ctx->pc != 0x178CF4u) { return; }
    }
    ctx->pc = 0x178CF4u;
    // 0x178cf4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178cf4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178cf8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178cf8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178cfc: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x178cfcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x178d00: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178D00u;
    SET_GPR_U32(ctx, 31, 0x178D08u);
    ctx->pc = 0x178D04u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178D00u;
            // 0x178d04: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178D08u; }
        if (ctx->pc != 0x178D08u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178D08u; }
        if (ctx->pc != 0x178D08u) { return; }
    }
    ctx->pc = 0x178D08u;
    // 0x178d08: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178d08u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178d0c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178d0cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178d10: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178d10u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178d14: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x178d14u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x178d18: 0xc065508  jal         func_195420
    ctx->pc = 0x178D18u;
    SET_GPR_U32(ctx, 31, 0x178D20u);
    ctx->pc = 0x178D1Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178D18u;
            // 0x178d1c: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178D20u; }
        if (ctx->pc != 0x178D20u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178D20u; }
        if (ctx->pc != 0x178D20u) { return; }
    }
    ctx->pc = 0x178D20u;
label_178d20:
    // 0x178d20: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178d20u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178d24: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x178d24u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x178d28: 0x2463000f  addiu       $v1, $v1, 0xF
    ctx->pc = 0x178d28u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 15));
    // 0x178d2c: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178d2cu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178d30: 0x0  nop
    ctx->pc = 0x178d30u;
    // NOP
    // 0x178d34: 0x0  nop
    ctx->pc = 0x178d34u;
    // NOP
    // 0x178d38: 0x1010  mfhi        $v0
    ctx->pc = 0x178d38u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178d3c: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x178D3Cu;
    {
        const bool branch_taken_0x178d3c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178d3c) {
            ctx->pc = 0x178DE8u;
            goto label_178de8;
        }
    }
    ctx->pc = 0x178D44u;
    // 0x178d44: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178d44u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178d48: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178d48u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178d4c: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178d4cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178d50: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x178d50u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x178d54: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178d54u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178d58: 0x0  nop
    ctx->pc = 0x178d58u;
    // NOP
    // 0x178d5c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178d5cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178d60: 0xc05d080  jal         func_174200
    ctx->pc = 0x178D60u;
    SET_GPR_U32(ctx, 31, 0x178D68u);
    ctx->pc = 0x178D64u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178D60u;
            // 0x178d64: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178D68u; }
        if (ctx->pc != 0x178D68u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178D68u; }
        if (ctx->pc != 0x178D68u) { return; }
    }
    ctx->pc = 0x178D68u;
    // 0x178d68: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178d68u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178d6c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178d6cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178d70: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178d70u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178d74: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x178d74u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x178d78: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178d78u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178d7c: 0x0  nop
    ctx->pc = 0x178d7cu;
    // NOP
    // 0x178d80: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178d80u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178d84: 0xc05d080  jal         func_174200
    ctx->pc = 0x178D84u;
    SET_GPR_U32(ctx, 31, 0x178D8Cu);
    ctx->pc = 0x178D88u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178D84u;
            // 0x178d88: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178D8Cu; }
        if (ctx->pc != 0x178D8Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178D8Cu; }
        if (ctx->pc != 0x178D8Cu) { return; }
    }
    ctx->pc = 0x178D8Cu;
    // 0x178d8c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178d8cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178d90: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178d90u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178d94: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178d94u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178d98: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178D98u;
    SET_GPR_U32(ctx, 31, 0x178DA0u);
    ctx->pc = 0x178D9Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178D98u;
            // 0x178d9c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178DA0u; }
        if (ctx->pc != 0x178DA0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178DA0u; }
        if (ctx->pc != 0x178DA0u) { return; }
    }
    ctx->pc = 0x178DA0u;
    // 0x178da0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178da0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178da4: 0x24060006  addiu       $a2, $zero, 0x6
    ctx->pc = 0x178da4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 6));
    // 0x178da8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178da8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178dac: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178dacu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178db0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178DB0u;
    SET_GPR_U32(ctx, 31, 0x178DB8u);
    ctx->pc = 0x178DB4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178DB0u;
            // 0x178db4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178DB8u; }
        if (ctx->pc != 0x178DB8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178DB8u; }
        if (ctx->pc != 0x178DB8u) { return; }
    }
    ctx->pc = 0x178DB8u;
    // 0x178db8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178db8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178dbc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178dbcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178dc0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178dc0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178dc4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178DC4u;
    SET_GPR_U32(ctx, 31, 0x178DCCu);
    ctx->pc = 0x178DC8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178DC4u;
            // 0x178dc8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178DCCu; }
        if (ctx->pc != 0x178DCCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178DCCu; }
        if (ctx->pc != 0x178DCCu) { return; }
    }
    ctx->pc = 0x178DCCu;
    // 0x178dcc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178dccu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178dd0: 0x24060072  addiu       $a2, $zero, 0x72
    ctx->pc = 0x178dd0u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 114));
    // 0x178dd4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178dd4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178dd8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178dd8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178ddc: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178DDCu;
    SET_GPR_U32(ctx, 31, 0x178DE4u);
    ctx->pc = 0x178DE0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178DDCu;
            // 0x178de0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178DE4u; }
        if (ctx->pc != 0x178DE4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178DE4u; }
        if (ctx->pc != 0x178DE4u) { return; }
    }
    ctx->pc = 0x178DE4u;
    // 0x178de4: 0x0  nop
    ctx->pc = 0x178de4u;
    // NOP
label_178de8:
    // 0x178de8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178de8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178dec: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x178decu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x178df0: 0x2463000a  addiu       $v1, $v1, 0xA
    ctx->pc = 0x178df0u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 10));
    // 0x178df4: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178df4u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178df8: 0x0  nop
    ctx->pc = 0x178df8u;
    // NOP
    // 0x178dfc: 0x0  nop
    ctx->pc = 0x178dfcu;
    // NOP
    // 0x178e00: 0x1010  mfhi        $v0
    ctx->pc = 0x178e00u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178e04: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x178E04u;
    {
        const bool branch_taken_0x178e04 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178e04) {
            ctx->pc = 0x178EB0u;
            goto label_178eb0;
        }
    }
    ctx->pc = 0x178E0Cu;
    // 0x178e0c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178e0cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178e10: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178e10u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178e14: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178e14u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178e18: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x178e18u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x178e1c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178e1cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178e20: 0x0  nop
    ctx->pc = 0x178e20u;
    // NOP
    // 0x178e24: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178e24u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178e28: 0xc05d080  jal         func_174200
    ctx->pc = 0x178E28u;
    SET_GPR_U32(ctx, 31, 0x178E30u);
    ctx->pc = 0x178E2Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178E28u;
            // 0x178e2c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178E30u; }
        if (ctx->pc != 0x178E30u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178E30u; }
        if (ctx->pc != 0x178E30u) { return; }
    }
    ctx->pc = 0x178E30u;
    // 0x178e30: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178e30u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178e34: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178e34u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178e38: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x178e38u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x178e3c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x178e3cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x178e40: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178e40u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178e44: 0x0  nop
    ctx->pc = 0x178e44u;
    // NOP
    // 0x178e48: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178e48u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178e4c: 0xc05d080  jal         func_174200
    ctx->pc = 0x178E4Cu;
    SET_GPR_U32(ctx, 31, 0x178E54u);
    ctx->pc = 0x178E50u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178E4Cu;
            // 0x178e50: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178E54u; }
        if (ctx->pc != 0x178E54u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178E54u; }
        if (ctx->pc != 0x178E54u) { return; }
    }
    ctx->pc = 0x178E54u;
    // 0x178e54: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178e54u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178e58: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178e58u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178e5c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178e5cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178e60: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178E60u;
    SET_GPR_U32(ctx, 31, 0x178E68u);
    ctx->pc = 0x178E64u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178E60u;
            // 0x178e64: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178E68u; }
        if (ctx->pc != 0x178E68u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178E68u; }
        if (ctx->pc != 0x178E68u) { return; }
    }
    ctx->pc = 0x178E68u;
    // 0x178e68: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178e68u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178e6c: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x178e6cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x178e70: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178e70u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178e74: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x178e74u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x178e78: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178E78u;
    SET_GPR_U32(ctx, 31, 0x178E80u);
    ctx->pc = 0x178E7Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178E78u;
            // 0x178e7c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178E80u; }
        if (ctx->pc != 0x178E80u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178E80u; }
        if (ctx->pc != 0x178E80u) { return; }
    }
    ctx->pc = 0x178E80u;
    // 0x178e80: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178e80u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178e84: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178e84u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178e88: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178e88u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178e8c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178E8Cu;
    SET_GPR_U32(ctx, 31, 0x178E94u);
    ctx->pc = 0x178E90u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178E8Cu;
            // 0x178e90: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178E94u; }
        if (ctx->pc != 0x178E94u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178E94u; }
        if (ctx->pc != 0x178E94u) { return; }
    }
    ctx->pc = 0x178E94u;
    // 0x178e94: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178e94u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178e98: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x178e98u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x178e9c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178e9cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178ea0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x178ea0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x178ea4: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x178EA4u;
    SET_GPR_U32(ctx, 31, 0x178EACu);
    ctx->pc = 0x178EA8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178EA4u;
            // 0x178ea8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178EACu; }
        if (ctx->pc != 0x178EACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178EACu; }
        if (ctx->pc != 0x178EACu) { return; }
    }
    ctx->pc = 0x178EACu;
    // 0x178eac: 0x0  nop
    ctx->pc = 0x178eacu;
    // NOP
label_178eb0:
    // 0x178eb0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178eb0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178eb4: 0x2402005a  addiu       $v0, $zero, 0x5A
    ctx->pc = 0x178eb4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 90));
    // 0x178eb8: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178eb8u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178ebc: 0x0  nop
    ctx->pc = 0x178ebcu;
    // NOP
    // 0x178ec0: 0x0  nop
    ctx->pc = 0x178ec0u;
    // NOP
    // 0x178ec4: 0x1010  mfhi        $v0
    ctx->pc = 0x178ec4u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178ec8: 0x144005c9  bnez        $v0, . + 4 + (0x5C9 << 2)
    ctx->pc = 0x178EC8u;
    {
        const bool branch_taken_0x178ec8 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178ec8) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x178ED0u;
    // 0x178ed0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178ed0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178ed4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178ed4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178ed8: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x178ed8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x178edc: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178EDCu;
    SET_GPR_U32(ctx, 31, 0x178EE4u);
    ctx->pc = 0x178EE0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178EDCu;
            // 0x178ee0: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178EE4u; }
        if (ctx->pc != 0x178EE4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178EE4u; }
        if (ctx->pc != 0x178EE4u) { return; }
    }
    ctx->pc = 0x178EE4u;
    // 0x178ee4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178ee4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178ee8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178ee8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178eec: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x178eecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x178ef0: 0xc06560c  jal         func_195830
    ctx->pc = 0x178EF0u;
    SET_GPR_U32(ctx, 31, 0x178EF8u);
    ctx->pc = 0x178EF4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178EF0u;
            // 0x178ef4: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178EF8u; }
        if (ctx->pc != 0x178EF8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178EF8u; }
        if (ctx->pc != 0x178EF8u) { return; }
    }
    ctx->pc = 0x178EF8u;
    // 0x178ef8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178ef8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178efc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178efcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178f00: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x178f00u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x178f04: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178F04u;
    SET_GPR_U32(ctx, 31, 0x178F0Cu);
    ctx->pc = 0x178F08u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178F04u;
            // 0x178f08: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178F0Cu; }
        if (ctx->pc != 0x178F0Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178F0Cu; }
        if (ctx->pc != 0x178F0Cu) { return; }
    }
    ctx->pc = 0x178F0Cu;
    // 0x178f0c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178f0cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178f10: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178f10u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178f14: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x178f14u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x178f18: 0xc06560c  jal         func_195830
    ctx->pc = 0x178F18u;
    SET_GPR_U32(ctx, 31, 0x178F20u);
    ctx->pc = 0x178F1Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178F18u;
            // 0x178f1c: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178F20u; }
        if (ctx->pc != 0x178F20u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178F20u; }
        if (ctx->pc != 0x178F20u) { return; }
    }
    ctx->pc = 0x178F20u;
    // 0x178f20: 0x100005b3  b           . + 4 + (0x5B3 << 2)
    ctx->pc = 0x178F20u;
    {
        const bool branch_taken_0x178f20 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x178f20) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x178F28u;
label_178f28:
    // 0x178f28: 0xc065d00  jal         func_197400
    ctx->pc = 0x178F28u;
    SET_GPR_U32(ctx, 31, 0x178F30u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178F30u; }
        if (ctx->pc != 0x178F30u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178F30u; }
        if (ctx->pc != 0x178F30u) { return; }
    }
    ctx->pc = 0x178F30u;
    // 0x178f30: 0x28410002  slti        $at, $v0, 0x2
    ctx->pc = 0x178f30u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)2) ? 1 : 0);
    // 0x178f34: 0x14200124  bnez        $at, . + 4 + (0x124 << 2)
    ctx->pc = 0x178F34u;
    {
        const bool branch_taken_0x178f34 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x178f34) {
            ctx->pc = 0x1793C8u;
            goto label_1793c8;
        }
    }
    ctx->pc = 0x178F3Cu;
    // 0x178f3c: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x178f3cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x178f40: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x178f40u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x178f44: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x178f44u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x178f48: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x178f48u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x178f4c: 0x0  nop
    ctx->pc = 0x178f4cu;
    // NOP
    // 0x178f50: 0x0  nop
    ctx->pc = 0x178f50u;
    // NOP
    // 0x178f54: 0x1010  mfhi        $v0
    ctx->pc = 0x178f54u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x178f58: 0x14400035  bnez        $v0, . + 4 + (0x35 << 2)
    ctx->pc = 0x178F58u;
    {
        const bool branch_taken_0x178f58 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x178f58) {
            ctx->pc = 0x179030u;
            goto label_179030;
        }
    }
    ctx->pc = 0x178F60u;
    // 0x178f60: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178f60u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178f64: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178f64u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178f68: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x178f68u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x178f6c: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x178f6cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x178f70: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178f70u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178f74: 0x0  nop
    ctx->pc = 0x178f74u;
    // NOP
    // 0x178f78: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178f78u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178f7c: 0xc05d080  jal         func_174200
    ctx->pc = 0x178F7Cu;
    SET_GPR_U32(ctx, 31, 0x178F84u);
    ctx->pc = 0x178F80u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178F7Cu;
            // 0x178f80: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178F84u; }
        if (ctx->pc != 0x178F84u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178F84u; }
        if (ctx->pc != 0x178F84u) { return; }
    }
    ctx->pc = 0x178F84u;
    // 0x178f84: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x178f84u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178f88: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x178f88u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x178f8c: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x178f8cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x178f90: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x178f90u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x178f94: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x178f94u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x178f98: 0x0  nop
    ctx->pc = 0x178f98u;
    // NOP
    // 0x178f9c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x178f9cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x178fa0: 0xc05d080  jal         func_174200
    ctx->pc = 0x178FA0u;
    SET_GPR_U32(ctx, 31, 0x178FA8u);
    ctx->pc = 0x178FA4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178FA0u;
            // 0x178fa4: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178FA8u; }
        if (ctx->pc != 0x178FA8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178FA8u; }
        if (ctx->pc != 0x178FA8u) { return; }
    }
    ctx->pc = 0x178FA8u;
    // 0x178fa8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178fa8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178fac: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x178facu;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178fb0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178FB0u;
    SET_GPR_U32(ctx, 31, 0x178FB8u);
    ctx->pc = 0x178FB4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178FB0u;
            // 0x178fb4: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178FB8u; }
        if (ctx->pc != 0x178FB8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178FB8u; }
        if (ctx->pc != 0x178FB8u) { return; }
    }
    ctx->pc = 0x178FB8u;
    // 0x178fb8: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x178fb8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178fbc: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x178fbcu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x178fc0: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x178fc0u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178fc4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x178fc4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x178fc8: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178fc8u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178fcc: 0xc065480  jal         func_195200
    ctx->pc = 0x178FCCu;
    SET_GPR_U32(ctx, 31, 0x178FD4u);
    ctx->pc = 0x178FD0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178FCCu;
            // 0x178fd0: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178FD4u; }
        if (ctx->pc != 0x178FD4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178FD4u; }
        if (ctx->pc != 0x178FD4u) { return; }
    }
    ctx->pc = 0x178FD4u;
    // 0x178fd4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178fd4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178fd8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178fd8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178fdc: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x178fdcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x178fe0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x178FE0u;
    SET_GPR_U32(ctx, 31, 0x178FE8u);
    ctx->pc = 0x178FE4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178FE0u;
            // 0x178fe4: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178FE8u; }
        if (ctx->pc != 0x178FE8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x178FE8u; }
        if (ctx->pc != 0x178FE8u) { return; }
    }
    ctx->pc = 0x178FE8u;
    // 0x178fe8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x178fe8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x178fec: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x178fecu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x178ff0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x178ff0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x178ff4: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x178ff4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x178ff8: 0xc065508  jal         func_195420
    ctx->pc = 0x178FF8u;
    SET_GPR_U32(ctx, 31, 0x179000u);
    ctx->pc = 0x178FFCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x178FF8u;
            // 0x178ffc: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179000u; }
        if (ctx->pc != 0x179000u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179000u; }
        if (ctx->pc != 0x179000u) { return; }
    }
    ctx->pc = 0x179000u;
    // 0x179000: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179000u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179004: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179004u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179008: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x179008u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x17900c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17900Cu;
    SET_GPR_U32(ctx, 31, 0x179014u);
    ctx->pc = 0x179010u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17900Cu;
            // 0x179010: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179014u; }
        if (ctx->pc != 0x179014u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179014u; }
        if (ctx->pc != 0x179014u) { return; }
    }
    ctx->pc = 0x179014u;
    // 0x179014: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179014u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179018: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179018u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17901c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17901cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179020: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x179020u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x179024: 0xc065508  jal         func_195420
    ctx->pc = 0x179024u;
    SET_GPR_U32(ctx, 31, 0x17902Cu);
    ctx->pc = 0x179028u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179024u;
            // 0x179028: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17902Cu; }
        if (ctx->pc != 0x17902Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17902Cu; }
        if (ctx->pc != 0x17902Cu) { return; }
    }
    ctx->pc = 0x17902Cu;
    // 0x17902c: 0x0  nop
    ctx->pc = 0x17902cu;
    // NOP
label_179030:
    // 0x179030: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179030u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179034: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x179034u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x179038: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x179038u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x17903c: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17903cu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179040: 0x0  nop
    ctx->pc = 0x179040u;
    // NOP
    // 0x179044: 0x0  nop
    ctx->pc = 0x179044u;
    // NOP
    // 0x179048: 0x1010  mfhi        $v0
    ctx->pc = 0x179048u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17904c: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x17904Cu;
    {
        const bool branch_taken_0x17904c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17904c) {
            ctx->pc = 0x1790F8u;
            goto label_1790f8;
        }
    }
    ctx->pc = 0x179054u;
    // 0x179054: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179054u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179058: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179058u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17905c: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17905cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179060: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x179060u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x179064: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179064u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179068: 0x0  nop
    ctx->pc = 0x179068u;
    // NOP
    // 0x17906c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17906cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179070: 0xc05d080  jal         func_174200
    ctx->pc = 0x179070u;
    SET_GPR_U32(ctx, 31, 0x179078u);
    ctx->pc = 0x179074u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179070u;
            // 0x179074: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179078u; }
        if (ctx->pc != 0x179078u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179078u; }
        if (ctx->pc != 0x179078u) { return; }
    }
    ctx->pc = 0x179078u;
    // 0x179078: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179078u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17907c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17907cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179080: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179080u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179084: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x179084u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x179088: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179088u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17908c: 0x0  nop
    ctx->pc = 0x17908cu;
    // NOP
    // 0x179090: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179090u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179094: 0xc05d080  jal         func_174200
    ctx->pc = 0x179094u;
    SET_GPR_U32(ctx, 31, 0x17909Cu);
    ctx->pc = 0x179098u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179094u;
            // 0x179098: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17909Cu; }
        if (ctx->pc != 0x17909Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17909Cu; }
        if (ctx->pc != 0x17909Cu) { return; }
    }
    ctx->pc = 0x17909Cu;
    // 0x17909c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17909cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1790a0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1790a0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1790a4: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x1790a4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x1790a8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1790A8u;
    SET_GPR_U32(ctx, 31, 0x1790B0u);
    ctx->pc = 0x1790ACu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1790A8u;
            // 0x1790ac: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1790B0u; }
        if (ctx->pc != 0x1790B0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1790B0u; }
        if (ctx->pc != 0x1790B0u) { return; }
    }
    ctx->pc = 0x1790B0u;
    // 0x1790b0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1790b0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1790b4: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x1790b4u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x1790b8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1790b8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1790bc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x1790bcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x1790c0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x1790C0u;
    SET_GPR_U32(ctx, 31, 0x1790C8u);
    ctx->pc = 0x1790C4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1790C0u;
            // 0x1790c4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1790C8u; }
        if (ctx->pc != 0x1790C8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1790C8u; }
        if (ctx->pc != 0x1790C8u) { return; }
    }
    ctx->pc = 0x1790C8u;
    // 0x1790c8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1790c8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1790cc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1790ccu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1790d0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x1790d0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x1790d4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1790D4u;
    SET_GPR_U32(ctx, 31, 0x1790DCu);
    ctx->pc = 0x1790D8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1790D4u;
            // 0x1790d8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1790DCu; }
        if (ctx->pc != 0x1790DCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1790DCu; }
        if (ctx->pc != 0x1790DCu) { return; }
    }
    ctx->pc = 0x1790DCu;
    // 0x1790dc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1790dcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1790e0: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x1790e0u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x1790e4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1790e4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1790e8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x1790e8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x1790ec: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x1790ECu;
    SET_GPR_U32(ctx, 31, 0x1790F4u);
    ctx->pc = 0x1790F0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1790ECu;
            // 0x1790f0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1790F4u; }
        if (ctx->pc != 0x1790F4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1790F4u; }
        if (ctx->pc != 0x1790F4u) { return; }
    }
    ctx->pc = 0x1790F4u;
    // 0x1790f4: 0x0  nop
    ctx->pc = 0x1790f4u;
    // NOP
label_1790f8:
    // 0x1790f8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1790f8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1790fc: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x1790fcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x179100: 0x2463000f  addiu       $v1, $v1, 0xF
    ctx->pc = 0x179100u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 15));
    // 0x179104: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179104u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179108: 0x0  nop
    ctx->pc = 0x179108u;
    // NOP
    // 0x17910c: 0x0  nop
    ctx->pc = 0x17910cu;
    // NOP
    // 0x179110: 0x1010  mfhi        $v0
    ctx->pc = 0x179110u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179114: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x179114u;
    {
        const bool branch_taken_0x179114 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179114) {
            ctx->pc = 0x1791C0u;
            goto label_1791c0;
        }
    }
    ctx->pc = 0x17911Cu;
    // 0x17911c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17911cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179120: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179120u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179124: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179124u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179128: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x179128u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17912c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17912cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179130: 0x0  nop
    ctx->pc = 0x179130u;
    // NOP
    // 0x179134: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179134u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179138: 0xc05d080  jal         func_174200
    ctx->pc = 0x179138u;
    SET_GPR_U32(ctx, 31, 0x179140u);
    ctx->pc = 0x17913Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179138u;
            // 0x17913c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179140u; }
        if (ctx->pc != 0x179140u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179140u; }
        if (ctx->pc != 0x179140u) { return; }
    }
    ctx->pc = 0x179140u;
    // 0x179140: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179140u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179144: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179144u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179148: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179148u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17914c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17914cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x179150: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179150u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179154: 0x0  nop
    ctx->pc = 0x179154u;
    // NOP
    // 0x179158: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179158u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17915c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17915Cu;
    SET_GPR_U32(ctx, 31, 0x179164u);
    ctx->pc = 0x179160u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17915Cu;
            // 0x179160: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179164u; }
        if (ctx->pc != 0x179164u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179164u; }
        if (ctx->pc != 0x179164u) { return; }
    }
    ctx->pc = 0x179164u;
    // 0x179164: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179164u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179168: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179168u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17916c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17916cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179170: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179170u;
    SET_GPR_U32(ctx, 31, 0x179178u);
    ctx->pc = 0x179174u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179170u;
            // 0x179174: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179178u; }
        if (ctx->pc != 0x179178u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179178u; }
        if (ctx->pc != 0x179178u) { return; }
    }
    ctx->pc = 0x179178u;
    // 0x179178: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179178u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17917c: 0x24060005  addiu       $a2, $zero, 0x5
    ctx->pc = 0x17917cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 5));
    // 0x179180: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179180u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179184: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179184u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179188: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179188u;
    SET_GPR_U32(ctx, 31, 0x179190u);
    ctx->pc = 0x17918Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179188u;
            // 0x17918c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179190u; }
        if (ctx->pc != 0x179190u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179190u; }
        if (ctx->pc != 0x179190u) { return; }
    }
    ctx->pc = 0x179190u;
    // 0x179190: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179190u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179194: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179194u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179198: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179198u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17919c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17919Cu;
    SET_GPR_U32(ctx, 31, 0x1791A4u);
    ctx->pc = 0x1791A0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17919Cu;
            // 0x1791a0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1791A4u; }
        if (ctx->pc != 0x1791A4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1791A4u; }
        if (ctx->pc != 0x1791A4u) { return; }
    }
    ctx->pc = 0x1791A4u;
    // 0x1791a4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1791a4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1791a8: 0x24060073  addiu       $a2, $zero, 0x73
    ctx->pc = 0x1791a8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 115));
    // 0x1791ac: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1791acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1791b0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x1791b0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x1791b4: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x1791B4u;
    SET_GPR_U32(ctx, 31, 0x1791BCu);
    ctx->pc = 0x1791B8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1791B4u;
            // 0x1791b8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1791BCu; }
        if (ctx->pc != 0x1791BCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1791BCu; }
        if (ctx->pc != 0x1791BCu) { return; }
    }
    ctx->pc = 0x1791BCu;
    // 0x1791bc: 0x0  nop
    ctx->pc = 0x1791bcu;
    // NOP
label_1791c0:
    // 0x1791c0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1791c0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1791c4: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x1791c4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x1791c8: 0x2463000a  addiu       $v1, $v1, 0xA
    ctx->pc = 0x1791c8u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 10));
    // 0x1791cc: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1791ccu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1791d0: 0x0  nop
    ctx->pc = 0x1791d0u;
    // NOP
    // 0x1791d4: 0x0  nop
    ctx->pc = 0x1791d4u;
    // NOP
    // 0x1791d8: 0x1010  mfhi        $v0
    ctx->pc = 0x1791d8u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1791dc: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x1791DCu;
    {
        const bool branch_taken_0x1791dc = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1791dc) {
            ctx->pc = 0x179288u;
            goto label_179288;
        }
    }
    ctx->pc = 0x1791E4u;
    // 0x1791e4: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1791e4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1791e8: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1791e8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1791ec: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1791ecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1791f0: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x1791f0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x1791f4: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1791f4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1791f8: 0x0  nop
    ctx->pc = 0x1791f8u;
    // NOP
    // 0x1791fc: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1791fcu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179200: 0xc05d080  jal         func_174200
    ctx->pc = 0x179200u;
    SET_GPR_U32(ctx, 31, 0x179208u);
    ctx->pc = 0x179204u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179200u;
            // 0x179204: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179208u; }
        if (ctx->pc != 0x179208u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179208u; }
        if (ctx->pc != 0x179208u) { return; }
    }
    ctx->pc = 0x179208u;
    // 0x179208: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179208u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17920c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17920cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179210: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179210u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179214: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x179214u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x179218: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179218u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17921c: 0x0  nop
    ctx->pc = 0x17921cu;
    // NOP
    // 0x179220: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179220u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179224: 0xc05d080  jal         func_174200
    ctx->pc = 0x179224u;
    SET_GPR_U32(ctx, 31, 0x17922Cu);
    ctx->pc = 0x179228u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179224u;
            // 0x179228: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17922Cu; }
        if (ctx->pc != 0x17922Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17922Cu; }
        if (ctx->pc != 0x17922Cu) { return; }
    }
    ctx->pc = 0x17922Cu;
    // 0x17922c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17922cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179230: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179230u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179234: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179234u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179238: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179238u;
    SET_GPR_U32(ctx, 31, 0x179240u);
    ctx->pc = 0x17923Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179238u;
            // 0x17923c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179240u; }
        if (ctx->pc != 0x179240u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179240u; }
        if (ctx->pc != 0x179240u) { return; }
    }
    ctx->pc = 0x179240u;
    // 0x179240: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179240u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179244: 0x2406000a  addiu       $a2, $zero, 0xA
    ctx->pc = 0x179244u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 10));
    // 0x179248: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179248u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17924c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17924cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179250: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179250u;
    SET_GPR_U32(ctx, 31, 0x179258u);
    ctx->pc = 0x179254u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179250u;
            // 0x179254: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179258u; }
        if (ctx->pc != 0x179258u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179258u; }
        if (ctx->pc != 0x179258u) { return; }
    }
    ctx->pc = 0x179258u;
    // 0x179258: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179258u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17925c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17925cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179260: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179260u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179264: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179264u;
    SET_GPR_U32(ctx, 31, 0x17926Cu);
    ctx->pc = 0x179268u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179264u;
            // 0x179268: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17926Cu; }
        if (ctx->pc != 0x17926Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17926Cu; }
        if (ctx->pc != 0x17926Cu) { return; }
    }
    ctx->pc = 0x17926Cu;
    // 0x17926c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17926cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179270: 0x2406006e  addiu       $a2, $zero, 0x6E
    ctx->pc = 0x179270u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 110));
    // 0x179274: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179274u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179278: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179278u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17927c: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17927Cu;
    SET_GPR_U32(ctx, 31, 0x179284u);
    ctx->pc = 0x179280u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17927Cu;
            // 0x179280: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179284u; }
        if (ctx->pc != 0x179284u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179284u; }
        if (ctx->pc != 0x179284u) { return; }
    }
    ctx->pc = 0x179284u;
    // 0x179284: 0x0  nop
    ctx->pc = 0x179284u;
    // NOP
label_179288:
    // 0x179288: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179288u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17928c: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x17928cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x179290: 0x24630005  addiu       $v1, $v1, 0x5
    ctx->pc = 0x179290u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 5));
    // 0x179294: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179294u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179298: 0x0  nop
    ctx->pc = 0x179298u;
    // NOP
    // 0x17929c: 0x0  nop
    ctx->pc = 0x17929cu;
    // NOP
    // 0x1792a0: 0x1010  mfhi        $v0
    ctx->pc = 0x1792a0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1792a4: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x1792A4u;
    {
        const bool branch_taken_0x1792a4 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1792a4) {
            ctx->pc = 0x179350u;
            goto label_179350;
        }
    }
    ctx->pc = 0x1792ACu;
    // 0x1792ac: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1792acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1792b0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1792b0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1792b4: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1792b4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1792b8: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x1792b8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x1792bc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1792bcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1792c0: 0x0  nop
    ctx->pc = 0x1792c0u;
    // NOP
    // 0x1792c4: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1792c4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1792c8: 0xc05d080  jal         func_174200
    ctx->pc = 0x1792C8u;
    SET_GPR_U32(ctx, 31, 0x1792D0u);
    ctx->pc = 0x1792CCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1792C8u;
            // 0x1792cc: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1792D0u; }
        if (ctx->pc != 0x1792D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1792D0u; }
        if (ctx->pc != 0x1792D0u) { return; }
    }
    ctx->pc = 0x1792D0u;
    // 0x1792d0: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1792d0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1792d4: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1792d4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1792d8: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1792d8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1792dc: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x1792dcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x1792e0: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1792e0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1792e4: 0x0  nop
    ctx->pc = 0x1792e4u;
    // NOP
    // 0x1792e8: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1792e8u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1792ec: 0xc05d080  jal         func_174200
    ctx->pc = 0x1792ECu;
    SET_GPR_U32(ctx, 31, 0x1792F4u);
    ctx->pc = 0x1792F0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1792ECu;
            // 0x1792f0: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1792F4u; }
        if (ctx->pc != 0x1792F4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1792F4u; }
        if (ctx->pc != 0x1792F4u) { return; }
    }
    ctx->pc = 0x1792F4u;
    // 0x1792f4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1792f4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1792f8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1792f8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1792fc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x1792fcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179300: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179300u;
    SET_GPR_U32(ctx, 31, 0x179308u);
    ctx->pc = 0x179304u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179300u;
            // 0x179304: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179308u; }
        if (ctx->pc != 0x179308u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179308u; }
        if (ctx->pc != 0x179308u) { return; }
    }
    ctx->pc = 0x179308u;
    // 0x179308: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179308u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17930c: 0x2406000f  addiu       $a2, $zero, 0xF
    ctx->pc = 0x17930cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 15));
    // 0x179310: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179310u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179314: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179314u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179318: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179318u;
    SET_GPR_U32(ctx, 31, 0x179320u);
    ctx->pc = 0x17931Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179318u;
            // 0x17931c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179320u; }
        if (ctx->pc != 0x179320u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179320u; }
        if (ctx->pc != 0x179320u) { return; }
    }
    ctx->pc = 0x179320u;
    // 0x179320: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179320u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179324: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179324u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179328: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179328u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17932c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17932Cu;
    SET_GPR_U32(ctx, 31, 0x179334u);
    ctx->pc = 0x179330u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17932Cu;
            // 0x179330: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179334u; }
        if (ctx->pc != 0x179334u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179334u; }
        if (ctx->pc != 0x179334u) { return; }
    }
    ctx->pc = 0x179334u;
    // 0x179334: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179334u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179338: 0x24060069  addiu       $a2, $zero, 0x69
    ctx->pc = 0x179338u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 105));
    // 0x17933c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17933cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179340: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179340u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179344: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179344u;
    SET_GPR_U32(ctx, 31, 0x17934Cu);
    ctx->pc = 0x179348u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179344u;
            // 0x179348: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17934Cu; }
        if (ctx->pc != 0x17934Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17934Cu; }
        if (ctx->pc != 0x17934Cu) { return; }
    }
    ctx->pc = 0x17934Cu;
    // 0x17934c: 0x0  nop
    ctx->pc = 0x17934cu;
    // NOP
label_179350:
    // 0x179350: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179350u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179354: 0x24020023  addiu       $v0, $zero, 0x23
    ctx->pc = 0x179354u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 35));
    // 0x179358: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179358u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17935c: 0x0  nop
    ctx->pc = 0x17935cu;
    // NOP
    // 0x179360: 0x0  nop
    ctx->pc = 0x179360u;
    // NOP
    // 0x179364: 0x1010  mfhi        $v0
    ctx->pc = 0x179364u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179368: 0x144004a1  bnez        $v0, . + 4 + (0x4A1 << 2)
    ctx->pc = 0x179368u;
    {
        const bool branch_taken_0x179368 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179368) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x179370u;
    // 0x179370: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179370u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179374: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179374u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179378: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x179378u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x17937c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17937Cu;
    SET_GPR_U32(ctx, 31, 0x179384u);
    ctx->pc = 0x179380u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17937Cu;
            // 0x179380: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179384u; }
        if (ctx->pc != 0x179384u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179384u; }
        if (ctx->pc != 0x179384u) { return; }
    }
    ctx->pc = 0x179384u;
    // 0x179384: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179384u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179388: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179388u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17938c: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x17938cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x179390: 0xc06560c  jal         func_195830
    ctx->pc = 0x179390u;
    SET_GPR_U32(ctx, 31, 0x179398u);
    ctx->pc = 0x179394u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179390u;
            // 0x179394: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179398u; }
        if (ctx->pc != 0x179398u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179398u; }
        if (ctx->pc != 0x179398u) { return; }
    }
    ctx->pc = 0x179398u;
    // 0x179398: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179398u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17939c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17939cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1793a0: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x1793a0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x1793a4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1793A4u;
    SET_GPR_U32(ctx, 31, 0x1793ACu);
    ctx->pc = 0x1793A8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1793A4u;
            // 0x1793a8: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1793ACu; }
        if (ctx->pc != 0x1793ACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1793ACu; }
        if (ctx->pc != 0x1793ACu) { return; }
    }
    ctx->pc = 0x1793ACu;
    // 0x1793ac: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1793acu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1793b0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1793b0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1793b4: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x1793b4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x1793b8: 0xc06560c  jal         func_195830
    ctx->pc = 0x1793B8u;
    SET_GPR_U32(ctx, 31, 0x1793C0u);
    ctx->pc = 0x1793BCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1793B8u;
            // 0x1793bc: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1793C0u; }
        if (ctx->pc != 0x1793C0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1793C0u; }
        if (ctx->pc != 0x1793C0u) { return; }
    }
    ctx->pc = 0x1793C0u;
    // 0x1793c0: 0x1000048b  b           . + 4 + (0x48B << 2)
    ctx->pc = 0x1793C0u;
    {
        const bool branch_taken_0x1793c0 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x1793c0) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x1793C8u;
label_1793c8:
    // 0x1793c8: 0xc065d00  jal         func_197400
    ctx->pc = 0x1793C8u;
    SET_GPR_U32(ctx, 31, 0x1793D0u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1793D0u; }
        if (ctx->pc != 0x1793D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1793D0u; }
        if (ctx->pc != 0x1793D0u) { return; }
    }
    ctx->pc = 0x1793D0u;
    // 0x1793d0: 0x184000bf  blez        $v0, . + 4 + (0xBF << 2)
    ctx->pc = 0x1793D0u;
    {
        const bool branch_taken_0x1793d0 = (GPR_S32(ctx, 2) <= 0);
        if (branch_taken_0x1793d0) {
            ctx->pc = 0x1796D0u;
            goto label_1796d0;
        }
    }
    ctx->pc = 0x1793D8u;
    // 0x1793d8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1793d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1793dc: 0x240200c8  addiu       $v0, $zero, 0xC8
    ctx->pc = 0x1793dcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 200));
    // 0x1793e0: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x1793e0u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x1793e4: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1793e4u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1793e8: 0x0  nop
    ctx->pc = 0x1793e8u;
    // NOP
    // 0x1793ec: 0x0  nop
    ctx->pc = 0x1793ecu;
    // NOP
    // 0x1793f0: 0x1010  mfhi        $v0
    ctx->pc = 0x1793f0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1793f4: 0x14400034  bnez        $v0, . + 4 + (0x34 << 2)
    ctx->pc = 0x1793F4u;
    {
        const bool branch_taken_0x1793f4 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1793f4) {
            ctx->pc = 0x1794C8u;
            goto label_1794c8;
        }
    }
    ctx->pc = 0x1793FCu;
    // 0x1793fc: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1793fcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179400: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179400u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179404: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x179404u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x179408: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x179408u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x17940c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17940cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179410: 0x0  nop
    ctx->pc = 0x179410u;
    // NOP
    // 0x179414: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179414u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179418: 0xc05d080  jal         func_174200
    ctx->pc = 0x179418u;
    SET_GPR_U32(ctx, 31, 0x179420u);
    ctx->pc = 0x17941Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179418u;
            // 0x17941c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179420u; }
        if (ctx->pc != 0x179420u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179420u; }
        if (ctx->pc != 0x179420u) { return; }
    }
    ctx->pc = 0x179420u;
    // 0x179420: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179420u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179424: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179424u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179428: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x179428u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17942c: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x17942cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x179430: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179430u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179434: 0x0  nop
    ctx->pc = 0x179434u;
    // NOP
    // 0x179438: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179438u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17943c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17943Cu;
    SET_GPR_U32(ctx, 31, 0x179444u);
    ctx->pc = 0x179440u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17943Cu;
            // 0x179440: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179444u; }
        if (ctx->pc != 0x179444u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179444u; }
        if (ctx->pc != 0x179444u) { return; }
    }
    ctx->pc = 0x179444u;
    // 0x179444: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179444u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179448: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x179448u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17944c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17944Cu;
    SET_GPR_U32(ctx, 31, 0x179454u);
    ctx->pc = 0x179450u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17944Cu;
            // 0x179450: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179454u; }
        if (ctx->pc != 0x179454u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179454u; }
        if (ctx->pc != 0x179454u) { return; }
    }
    ctx->pc = 0x179454u;
    // 0x179454: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x179454u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179458: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x179458u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x17945c: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x17945cu;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179460: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x179460u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x179464: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179464u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x179468: 0xc065480  jal         func_195200
    ctx->pc = 0x179468u;
    SET_GPR_U32(ctx, 31, 0x179470u);
    ctx->pc = 0x17946Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179468u;
            // 0x17946c: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179470u; }
        if (ctx->pc != 0x179470u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179470u; }
        if (ctx->pc != 0x179470u) { return; }
    }
    ctx->pc = 0x179470u;
    // 0x179470: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179470u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179474: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179474u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179478: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x179478u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x17947c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17947Cu;
    SET_GPR_U32(ctx, 31, 0x179484u);
    ctx->pc = 0x179480u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17947Cu;
            // 0x179480: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179484u; }
        if (ctx->pc != 0x179484u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179484u; }
        if (ctx->pc != 0x179484u) { return; }
    }
    ctx->pc = 0x179484u;
    // 0x179484: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179484u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179488: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179488u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17948c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17948cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179490: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x179490u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x179494: 0xc065508  jal         func_195420
    ctx->pc = 0x179494u;
    SET_GPR_U32(ctx, 31, 0x17949Cu);
    ctx->pc = 0x179498u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179494u;
            // 0x179498: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17949Cu; }
        if (ctx->pc != 0x17949Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17949Cu; }
        if (ctx->pc != 0x17949Cu) { return; }
    }
    ctx->pc = 0x17949Cu;
    // 0x17949c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17949cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1794a0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1794a0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1794a4: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x1794a4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x1794a8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1794A8u;
    SET_GPR_U32(ctx, 31, 0x1794B0u);
    ctx->pc = 0x1794ACu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1794A8u;
            // 0x1794ac: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1794B0u; }
        if (ctx->pc != 0x1794B0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1794B0u; }
        if (ctx->pc != 0x1794B0u) { return; }
    }
    ctx->pc = 0x1794B0u;
    // 0x1794b0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1794b0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1794b4: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x1794b4u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x1794b8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1794b8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1794bc: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x1794bcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x1794c0: 0xc065508  jal         func_195420
    ctx->pc = 0x1794C0u;
    SET_GPR_U32(ctx, 31, 0x1794C8u);
    ctx->pc = 0x1794C4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1794C0u;
            // 0x1794c4: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1794C8u; }
        if (ctx->pc != 0x1794C8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1794C8u; }
        if (ctx->pc != 0x1794C8u) { return; }
    }
    ctx->pc = 0x1794C8u;
label_1794c8:
    // 0x1794c8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1794c8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1794cc: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x1794ccu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x1794d0: 0x2463000f  addiu       $v1, $v1, 0xF
    ctx->pc = 0x1794d0u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 15));
    // 0x1794d4: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1794d4u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1794d8: 0x0  nop
    ctx->pc = 0x1794d8u;
    // NOP
    // 0x1794dc: 0x0  nop
    ctx->pc = 0x1794dcu;
    // NOP
    // 0x1794e0: 0x1010  mfhi        $v0
    ctx->pc = 0x1794e0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1794e4: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x1794E4u;
    {
        const bool branch_taken_0x1794e4 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1794e4) {
            ctx->pc = 0x179590u;
            goto label_179590;
        }
    }
    ctx->pc = 0x1794ECu;
    // 0x1794ec: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1794ecu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1794f0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1794f0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1794f4: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1794f4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1794f8: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x1794f8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x1794fc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1794fcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179500: 0x0  nop
    ctx->pc = 0x179500u;
    // NOP
    // 0x179504: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179504u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179508: 0xc05d080  jal         func_174200
    ctx->pc = 0x179508u;
    SET_GPR_U32(ctx, 31, 0x179510u);
    ctx->pc = 0x17950Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179508u;
            // 0x17950c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179510u; }
        if (ctx->pc != 0x179510u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179510u; }
        if (ctx->pc != 0x179510u) { return; }
    }
    ctx->pc = 0x179510u;
    // 0x179510: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179510u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179514: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179514u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179518: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179518u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17951c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17951cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x179520: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179520u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179524: 0x0  nop
    ctx->pc = 0x179524u;
    // NOP
    // 0x179528: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179528u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17952c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17952Cu;
    SET_GPR_U32(ctx, 31, 0x179534u);
    ctx->pc = 0x179530u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17952Cu;
            // 0x179530: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179534u; }
        if (ctx->pc != 0x179534u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179534u; }
        if (ctx->pc != 0x179534u) { return; }
    }
    ctx->pc = 0x179534u;
    // 0x179534: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179534u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179538: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179538u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17953c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17953cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179540: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179540u;
    SET_GPR_U32(ctx, 31, 0x179548u);
    ctx->pc = 0x179544u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179540u;
            // 0x179544: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179548u; }
        if (ctx->pc != 0x179548u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179548u; }
        if (ctx->pc != 0x179548u) { return; }
    }
    ctx->pc = 0x179548u;
    // 0x179548: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179548u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17954c: 0x24060005  addiu       $a2, $zero, 0x5
    ctx->pc = 0x17954cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 5));
    // 0x179550: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179550u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179554: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179554u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179558: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179558u;
    SET_GPR_U32(ctx, 31, 0x179560u);
    ctx->pc = 0x17955Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179558u;
            // 0x17955c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179560u; }
        if (ctx->pc != 0x179560u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179560u; }
        if (ctx->pc != 0x179560u) { return; }
    }
    ctx->pc = 0x179560u;
    // 0x179560: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179560u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179564: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179564u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179568: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179568u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17956c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17956Cu;
    SET_GPR_U32(ctx, 31, 0x179574u);
    ctx->pc = 0x179570u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17956Cu;
            // 0x179570: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179574u; }
        if (ctx->pc != 0x179574u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179574u; }
        if (ctx->pc != 0x179574u) { return; }
    }
    ctx->pc = 0x179574u;
    // 0x179574: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179574u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179578: 0x24060073  addiu       $a2, $zero, 0x73
    ctx->pc = 0x179578u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 115));
    // 0x17957c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17957cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179580: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179580u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179584: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179584u;
    SET_GPR_U32(ctx, 31, 0x17958Cu);
    ctx->pc = 0x179588u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179584u;
            // 0x179588: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17958Cu; }
        if (ctx->pc != 0x17958Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17958Cu; }
        if (ctx->pc != 0x17958Cu) { return; }
    }
    ctx->pc = 0x17958Cu;
    // 0x17958c: 0x0  nop
    ctx->pc = 0x17958cu;
    // NOP
label_179590:
    // 0x179590: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179590u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179594: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x179594u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x179598: 0x24630005  addiu       $v1, $v1, 0x5
    ctx->pc = 0x179598u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 5));
    // 0x17959c: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17959cu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1795a0: 0x0  nop
    ctx->pc = 0x1795a0u;
    // NOP
    // 0x1795a4: 0x0  nop
    ctx->pc = 0x1795a4u;
    // NOP
    // 0x1795a8: 0x1010  mfhi        $v0
    ctx->pc = 0x1795a8u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1795ac: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x1795ACu;
    {
        const bool branch_taken_0x1795ac = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1795ac) {
            ctx->pc = 0x179658u;
            goto label_179658;
        }
    }
    ctx->pc = 0x1795B4u;
    // 0x1795b4: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1795b4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1795b8: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1795b8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1795bc: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1795bcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1795c0: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x1795c0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x1795c4: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1795c4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1795c8: 0x0  nop
    ctx->pc = 0x1795c8u;
    // NOP
    // 0x1795cc: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1795ccu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1795d0: 0xc05d080  jal         func_174200
    ctx->pc = 0x1795D0u;
    SET_GPR_U32(ctx, 31, 0x1795D8u);
    ctx->pc = 0x1795D4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1795D0u;
            // 0x1795d4: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1795D8u; }
        if (ctx->pc != 0x1795D8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1795D8u; }
        if (ctx->pc != 0x1795D8u) { return; }
    }
    ctx->pc = 0x1795D8u;
    // 0x1795d8: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1795d8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1795dc: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1795dcu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1795e0: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1795e0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1795e4: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x1795e4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x1795e8: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1795e8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1795ec: 0x0  nop
    ctx->pc = 0x1795ecu;
    // NOP
    // 0x1795f0: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1795f0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1795f4: 0xc05d080  jal         func_174200
    ctx->pc = 0x1795F4u;
    SET_GPR_U32(ctx, 31, 0x1795FCu);
    ctx->pc = 0x1795F8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1795F4u;
            // 0x1795f8: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1795FCu; }
        if (ctx->pc != 0x1795FCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1795FCu; }
        if (ctx->pc != 0x1795FCu) { return; }
    }
    ctx->pc = 0x1795FCu;
    // 0x1795fc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1795fcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179600: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179600u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179604: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179604u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179608: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179608u;
    SET_GPR_U32(ctx, 31, 0x179610u);
    ctx->pc = 0x17960Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179608u;
            // 0x17960c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179610u; }
        if (ctx->pc != 0x179610u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179610u; }
        if (ctx->pc != 0x179610u) { return; }
    }
    ctx->pc = 0x179610u;
    // 0x179610: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179610u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179614: 0x2406000f  addiu       $a2, $zero, 0xF
    ctx->pc = 0x179614u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 15));
    // 0x179618: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179618u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17961c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17961cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179620: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179620u;
    SET_GPR_U32(ctx, 31, 0x179628u);
    ctx->pc = 0x179624u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179620u;
            // 0x179624: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179628u; }
        if (ctx->pc != 0x179628u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179628u; }
        if (ctx->pc != 0x179628u) { return; }
    }
    ctx->pc = 0x179628u;
    // 0x179628: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179628u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17962c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17962cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179630: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179630u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179634: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179634u;
    SET_GPR_U32(ctx, 31, 0x17963Cu);
    ctx->pc = 0x179638u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179634u;
            // 0x179638: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17963Cu; }
        if (ctx->pc != 0x17963Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17963Cu; }
        if (ctx->pc != 0x17963Cu) { return; }
    }
    ctx->pc = 0x17963Cu;
    // 0x17963c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17963cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179640: 0x24060069  addiu       $a2, $zero, 0x69
    ctx->pc = 0x179640u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 105));
    // 0x179644: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179644u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179648: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179648u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17964c: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17964Cu;
    SET_GPR_U32(ctx, 31, 0x179654u);
    ctx->pc = 0x179650u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17964Cu;
            // 0x179650: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179654u; }
        if (ctx->pc != 0x179654u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179654u; }
        if (ctx->pc != 0x179654u) { return; }
    }
    ctx->pc = 0x179654u;
    // 0x179654: 0x0  nop
    ctx->pc = 0x179654u;
    // NOP
label_179658:
    // 0x179658: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179658u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17965c: 0x24020023  addiu       $v0, $zero, 0x23
    ctx->pc = 0x17965cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 35));
    // 0x179660: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179660u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179664: 0x0  nop
    ctx->pc = 0x179664u;
    // NOP
    // 0x179668: 0x0  nop
    ctx->pc = 0x179668u;
    // NOP
    // 0x17966c: 0x1010  mfhi        $v0
    ctx->pc = 0x17966cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179670: 0x144003df  bnez        $v0, . + 4 + (0x3DF << 2)
    ctx->pc = 0x179670u;
    {
        const bool branch_taken_0x179670 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179670) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x179678u;
    // 0x179678: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179678u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17967c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17967cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179680: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x179680u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x179684: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179684u;
    SET_GPR_U32(ctx, 31, 0x17968Cu);
    ctx->pc = 0x179688u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179684u;
            // 0x179688: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17968Cu; }
        if (ctx->pc != 0x17968Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17968Cu; }
        if (ctx->pc != 0x17968Cu) { return; }
    }
    ctx->pc = 0x17968Cu;
    // 0x17968c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17968cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179690: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179690u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179694: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x179694u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x179698: 0xc06560c  jal         func_195830
    ctx->pc = 0x179698u;
    SET_GPR_U32(ctx, 31, 0x1796A0u);
    ctx->pc = 0x17969Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179698u;
            // 0x17969c: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1796A0u; }
        if (ctx->pc != 0x1796A0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1796A0u; }
        if (ctx->pc != 0x1796A0u) { return; }
    }
    ctx->pc = 0x1796A0u;
    // 0x1796a0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1796a0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1796a4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1796a4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1796a8: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x1796a8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x1796ac: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1796ACu;
    SET_GPR_U32(ctx, 31, 0x1796B4u);
    ctx->pc = 0x1796B0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1796ACu;
            // 0x1796b0: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1796B4u; }
        if (ctx->pc != 0x1796B4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1796B4u; }
        if (ctx->pc != 0x1796B4u) { return; }
    }
    ctx->pc = 0x1796B4u;
    // 0x1796b4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1796b4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1796b8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1796b8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1796bc: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x1796bcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x1796c0: 0xc06560c  jal         func_195830
    ctx->pc = 0x1796C0u;
    SET_GPR_U32(ctx, 31, 0x1796C8u);
    ctx->pc = 0x1796C4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1796C0u;
            // 0x1796c4: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1796C8u; }
        if (ctx->pc != 0x1796C8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1796C8u; }
        if (ctx->pc != 0x1796C8u) { return; }
    }
    ctx->pc = 0x1796C8u;
    // 0x1796c8: 0x100003c9  b           . + 4 + (0x3C9 << 2)
    ctx->pc = 0x1796C8u;
    {
        const bool branch_taken_0x1796c8 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x1796c8) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x1796D0u;
label_1796d0:
    // 0x1796d0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1796d0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1796d4: 0x240200c8  addiu       $v0, $zero, 0xC8
    ctx->pc = 0x1796d4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 200));
    // 0x1796d8: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x1796d8u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x1796dc: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1796dcu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1796e0: 0x0  nop
    ctx->pc = 0x1796e0u;
    // NOP
    // 0x1796e4: 0x0  nop
    ctx->pc = 0x1796e4u;
    // NOP
    // 0x1796e8: 0x1010  mfhi        $v0
    ctx->pc = 0x1796e8u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1796ec: 0x14400034  bnez        $v0, . + 4 + (0x34 << 2)
    ctx->pc = 0x1796ECu;
    {
        const bool branch_taken_0x1796ec = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1796ec) {
            ctx->pc = 0x1797C0u;
            goto label_1797c0;
        }
    }
    ctx->pc = 0x1796F4u;
    // 0x1796f4: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1796f4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1796f8: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1796f8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1796fc: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x1796fcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x179700: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x179700u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x179704: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179704u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179708: 0x0  nop
    ctx->pc = 0x179708u;
    // NOP
    // 0x17970c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17970cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179710: 0xc05d080  jal         func_174200
    ctx->pc = 0x179710u;
    SET_GPR_U32(ctx, 31, 0x179718u);
    ctx->pc = 0x179714u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179710u;
            // 0x179714: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179718u; }
        if (ctx->pc != 0x179718u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179718u; }
        if (ctx->pc != 0x179718u) { return; }
    }
    ctx->pc = 0x179718u;
    // 0x179718: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179718u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17971c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17971cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179720: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x179720u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x179724: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x179724u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x179728: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179728u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17972c: 0x0  nop
    ctx->pc = 0x17972cu;
    // NOP
    // 0x179730: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179730u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179734: 0xc05d080  jal         func_174200
    ctx->pc = 0x179734u;
    SET_GPR_U32(ctx, 31, 0x17973Cu);
    ctx->pc = 0x179738u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179734u;
            // 0x179738: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17973Cu; }
        if (ctx->pc != 0x17973Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17973Cu; }
        if (ctx->pc != 0x17973Cu) { return; }
    }
    ctx->pc = 0x17973Cu;
    // 0x17973c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17973cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179740: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x179740u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179744: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179744u;
    SET_GPR_U32(ctx, 31, 0x17974Cu);
    ctx->pc = 0x179748u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179744u;
            // 0x179748: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17974Cu; }
        if (ctx->pc != 0x17974Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17974Cu; }
        if (ctx->pc != 0x17974Cu) { return; }
    }
    ctx->pc = 0x17974Cu;
    // 0x17974c: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x17974cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179750: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x179750u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x179754: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x179754u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179758: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x179758u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17975c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17975cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x179760: 0xc065480  jal         func_195200
    ctx->pc = 0x179760u;
    SET_GPR_U32(ctx, 31, 0x179768u);
    ctx->pc = 0x179764u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179760u;
            // 0x179764: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179768u; }
        if (ctx->pc != 0x179768u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179768u; }
        if (ctx->pc != 0x179768u) { return; }
    }
    ctx->pc = 0x179768u;
    // 0x179768: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179768u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17976c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17976cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179770: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x179770u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x179774: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179774u;
    SET_GPR_U32(ctx, 31, 0x17977Cu);
    ctx->pc = 0x179778u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179774u;
            // 0x179778: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17977Cu; }
        if (ctx->pc != 0x17977Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17977Cu; }
        if (ctx->pc != 0x17977Cu) { return; }
    }
    ctx->pc = 0x17977Cu;
    // 0x17977c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17977cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179780: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179780u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x179784: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179784u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179788: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x179788u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x17978c: 0xc065508  jal         func_195420
    ctx->pc = 0x17978Cu;
    SET_GPR_U32(ctx, 31, 0x179794u);
    ctx->pc = 0x179790u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17978Cu;
            // 0x179790: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179794u; }
        if (ctx->pc != 0x179794u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179794u; }
        if (ctx->pc != 0x179794u) { return; }
    }
    ctx->pc = 0x179794u;
    // 0x179794: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179794u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179798: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179798u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17979c: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x17979cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x1797a0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1797A0u;
    SET_GPR_U32(ctx, 31, 0x1797A8u);
    ctx->pc = 0x1797A4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1797A0u;
            // 0x1797a4: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1797A8u; }
        if (ctx->pc != 0x1797A8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1797A8u; }
        if (ctx->pc != 0x1797A8u) { return; }
    }
    ctx->pc = 0x1797A8u;
    // 0x1797a8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1797a8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1797ac: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x1797acu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x1797b0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1797b0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1797b4: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x1797b4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x1797b8: 0xc065508  jal         func_195420
    ctx->pc = 0x1797B8u;
    SET_GPR_U32(ctx, 31, 0x1797C0u);
    ctx->pc = 0x1797BCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1797B8u;
            // 0x1797bc: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1797C0u; }
        if (ctx->pc != 0x1797C0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1797C0u; }
        if (ctx->pc != 0x1797C0u) { return; }
    }
    ctx->pc = 0x1797C0u;
label_1797c0:
    // 0x1797c0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1797c0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1797c4: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x1797c4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x1797c8: 0x2463000f  addiu       $v1, $v1, 0xF
    ctx->pc = 0x1797c8u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 15));
    // 0x1797cc: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1797ccu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1797d0: 0x0  nop
    ctx->pc = 0x1797d0u;
    // NOP
    // 0x1797d4: 0x0  nop
    ctx->pc = 0x1797d4u;
    // NOP
    // 0x1797d8: 0x1010  mfhi        $v0
    ctx->pc = 0x1797d8u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1797dc: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x1797DCu;
    {
        const bool branch_taken_0x1797dc = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1797dc) {
            ctx->pc = 0x179888u;
            goto label_179888;
        }
    }
    ctx->pc = 0x1797E4u;
    // 0x1797e4: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1797e4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1797e8: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1797e8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1797ec: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1797ecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1797f0: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x1797f0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x1797f4: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1797f4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1797f8: 0x0  nop
    ctx->pc = 0x1797f8u;
    // NOP
    // 0x1797fc: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1797fcu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179800: 0xc05d080  jal         func_174200
    ctx->pc = 0x179800u;
    SET_GPR_U32(ctx, 31, 0x179808u);
    ctx->pc = 0x179804u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179800u;
            // 0x179804: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179808u; }
        if (ctx->pc != 0x179808u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179808u; }
        if (ctx->pc != 0x179808u) { return; }
    }
    ctx->pc = 0x179808u;
    // 0x179808: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179808u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17980c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17980cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179810: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179810u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179814: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x179814u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x179818: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179818u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17981c: 0x0  nop
    ctx->pc = 0x17981cu;
    // NOP
    // 0x179820: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179820u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179824: 0xc05d080  jal         func_174200
    ctx->pc = 0x179824u;
    SET_GPR_U32(ctx, 31, 0x17982Cu);
    ctx->pc = 0x179828u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179824u;
            // 0x179828: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17982Cu; }
        if (ctx->pc != 0x17982Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17982Cu; }
        if (ctx->pc != 0x17982Cu) { return; }
    }
    ctx->pc = 0x17982Cu;
    // 0x17982c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17982cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179830: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179830u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179834: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179834u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179838: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179838u;
    SET_GPR_U32(ctx, 31, 0x179840u);
    ctx->pc = 0x17983Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179838u;
            // 0x17983c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179840u; }
        if (ctx->pc != 0x179840u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179840u; }
        if (ctx->pc != 0x179840u) { return; }
    }
    ctx->pc = 0x179840u;
    // 0x179840: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179840u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179844: 0x24060005  addiu       $a2, $zero, 0x5
    ctx->pc = 0x179844u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 5));
    // 0x179848: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179848u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17984c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17984cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179850: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179850u;
    SET_GPR_U32(ctx, 31, 0x179858u);
    ctx->pc = 0x179854u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179850u;
            // 0x179854: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179858u; }
        if (ctx->pc != 0x179858u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179858u; }
        if (ctx->pc != 0x179858u) { return; }
    }
    ctx->pc = 0x179858u;
    // 0x179858: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179858u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17985c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17985cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179860: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179860u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179864: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179864u;
    SET_GPR_U32(ctx, 31, 0x17986Cu);
    ctx->pc = 0x179868u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179864u;
            // 0x179868: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17986Cu; }
        if (ctx->pc != 0x17986Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17986Cu; }
        if (ctx->pc != 0x17986Cu) { return; }
    }
    ctx->pc = 0x17986Cu;
    // 0x17986c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17986cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179870: 0x24060073  addiu       $a2, $zero, 0x73
    ctx->pc = 0x179870u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 115));
    // 0x179874: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179874u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179878: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179878u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17987c: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17987Cu;
    SET_GPR_U32(ctx, 31, 0x179884u);
    ctx->pc = 0x179880u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17987Cu;
            // 0x179880: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179884u; }
        if (ctx->pc != 0x179884u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179884u; }
        if (ctx->pc != 0x179884u) { return; }
    }
    ctx->pc = 0x179884u;
    // 0x179884: 0x0  nop
    ctx->pc = 0x179884u;
    // NOP
label_179888:
    // 0x179888: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179888u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17988c: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x17988cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x179890: 0x24630005  addiu       $v1, $v1, 0x5
    ctx->pc = 0x179890u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 5));
    // 0x179894: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179894u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179898: 0x0  nop
    ctx->pc = 0x179898u;
    // NOP
    // 0x17989c: 0x0  nop
    ctx->pc = 0x17989cu;
    // NOP
    // 0x1798a0: 0x1010  mfhi        $v0
    ctx->pc = 0x1798a0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1798a4: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x1798A4u;
    {
        const bool branch_taken_0x1798a4 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1798a4) {
            ctx->pc = 0x179950u;
            goto label_179950;
        }
    }
    ctx->pc = 0x1798ACu;
    // 0x1798ac: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1798acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1798b0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1798b0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1798b4: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1798b4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1798b8: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x1798b8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x1798bc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1798bcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1798c0: 0x0  nop
    ctx->pc = 0x1798c0u;
    // NOP
    // 0x1798c4: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1798c4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1798c8: 0xc05d080  jal         func_174200
    ctx->pc = 0x1798C8u;
    SET_GPR_U32(ctx, 31, 0x1798D0u);
    ctx->pc = 0x1798CCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1798C8u;
            // 0x1798cc: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1798D0u; }
        if (ctx->pc != 0x1798D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1798D0u; }
        if (ctx->pc != 0x1798D0u) { return; }
    }
    ctx->pc = 0x1798D0u;
    // 0x1798d0: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x1798d0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1798d4: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x1798d4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x1798d8: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x1798d8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x1798dc: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x1798dcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x1798e0: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x1798e0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x1798e4: 0x0  nop
    ctx->pc = 0x1798e4u;
    // NOP
    // 0x1798e8: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x1798e8u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x1798ec: 0xc05d080  jal         func_174200
    ctx->pc = 0x1798ECu;
    SET_GPR_U32(ctx, 31, 0x1798F4u);
    ctx->pc = 0x1798F0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1798ECu;
            // 0x1798f0: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1798F4u; }
        if (ctx->pc != 0x1798F4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1798F4u; }
        if (ctx->pc != 0x1798F4u) { return; }
    }
    ctx->pc = 0x1798F4u;
    // 0x1798f4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1798f4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1798f8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1798f8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1798fc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x1798fcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179900: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179900u;
    SET_GPR_U32(ctx, 31, 0x179908u);
    ctx->pc = 0x179904u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179900u;
            // 0x179904: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179908u; }
        if (ctx->pc != 0x179908u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179908u; }
        if (ctx->pc != 0x179908u) { return; }
    }
    ctx->pc = 0x179908u;
    // 0x179908: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179908u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17990c: 0x2406000f  addiu       $a2, $zero, 0xF
    ctx->pc = 0x17990cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 15));
    // 0x179910: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179910u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179914: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179914u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179918: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179918u;
    SET_GPR_U32(ctx, 31, 0x179920u);
    ctx->pc = 0x17991Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179918u;
            // 0x17991c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179920u; }
        if (ctx->pc != 0x179920u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179920u; }
        if (ctx->pc != 0x179920u) { return; }
    }
    ctx->pc = 0x179920u;
    // 0x179920: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179920u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179924: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179924u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179928: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179928u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17992c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17992Cu;
    SET_GPR_U32(ctx, 31, 0x179934u);
    ctx->pc = 0x179930u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17992Cu;
            // 0x179930: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179934u; }
        if (ctx->pc != 0x179934u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179934u; }
        if (ctx->pc != 0x179934u) { return; }
    }
    ctx->pc = 0x179934u;
    // 0x179934: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179934u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179938: 0x24060069  addiu       $a2, $zero, 0x69
    ctx->pc = 0x179938u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 105));
    // 0x17993c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17993cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179940: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179940u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179944: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179944u;
    SET_GPR_U32(ctx, 31, 0x17994Cu);
    ctx->pc = 0x179948u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179944u;
            // 0x179948: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17994Cu; }
        if (ctx->pc != 0x17994Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17994Cu; }
        if (ctx->pc != 0x17994Cu) { return; }
    }
    ctx->pc = 0x17994Cu;
    // 0x17994c: 0x0  nop
    ctx->pc = 0x17994cu;
    // NOP
label_179950:
    // 0x179950: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179950u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179954: 0x24020046  addiu       $v0, $zero, 0x46
    ctx->pc = 0x179954u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 70));
    // 0x179958: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179958u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17995c: 0x0  nop
    ctx->pc = 0x17995cu;
    // NOP
    // 0x179960: 0x0  nop
    ctx->pc = 0x179960u;
    // NOP
    // 0x179964: 0x1010  mfhi        $v0
    ctx->pc = 0x179964u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179968: 0x14400321  bnez        $v0, . + 4 + (0x321 << 2)
    ctx->pc = 0x179968u;
    {
        const bool branch_taken_0x179968 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179968) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x179970u;
    // 0x179970: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179970u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179974: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179974u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179978: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x179978u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x17997c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17997Cu;
    SET_GPR_U32(ctx, 31, 0x179984u);
    ctx->pc = 0x179980u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17997Cu;
            // 0x179980: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179984u; }
        if (ctx->pc != 0x179984u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179984u; }
        if (ctx->pc != 0x179984u) { return; }
    }
    ctx->pc = 0x179984u;
    // 0x179984: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179984u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179988: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179988u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17998c: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x17998cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x179990: 0xc06560c  jal         func_195830
    ctx->pc = 0x179990u;
    SET_GPR_U32(ctx, 31, 0x179998u);
    ctx->pc = 0x179994u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179990u;
            // 0x179994: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179998u; }
        if (ctx->pc != 0x179998u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179998u; }
        if (ctx->pc != 0x179998u) { return; }
    }
    ctx->pc = 0x179998u;
    // 0x179998: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179998u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17999c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17999cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1799a0: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x1799a0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x1799a4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x1799A4u;
    SET_GPR_U32(ctx, 31, 0x1799ACu);
    ctx->pc = 0x1799A8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1799A4u;
            // 0x1799a8: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1799ACu; }
        if (ctx->pc != 0x1799ACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1799ACu; }
        if (ctx->pc != 0x1799ACu) { return; }
    }
    ctx->pc = 0x1799ACu;
    // 0x1799ac: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x1799acu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1799b0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x1799b0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1799b4: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x1799b4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x1799b8: 0xc06560c  jal         func_195830
    ctx->pc = 0x1799B8u;
    SET_GPR_U32(ctx, 31, 0x1799C0u);
    ctx->pc = 0x1799BCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x1799B8u;
            // 0x1799bc: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1799C0u; }
        if (ctx->pc != 0x1799C0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1799C0u; }
        if (ctx->pc != 0x1799C0u) { return; }
    }
    ctx->pc = 0x1799C0u;
    // 0x1799c0: 0x1000030b  b           . + 4 + (0x30B << 2)
    ctx->pc = 0x1799C0u;
    {
        const bool branch_taken_0x1799c0 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x1799c0) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x1799C8u;
label_1799c8:
    // 0x1799c8: 0xc065d00  jal         func_197400
    ctx->pc = 0x1799C8u;
    SET_GPR_U32(ctx, 31, 0x1799D0u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1799D0u; }
        if (ctx->pc != 0x1799D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x1799D0u; }
        if (ctx->pc != 0x1799D0u) { return; }
    }
    ctx->pc = 0x1799D0u;
    // 0x1799d0: 0x28410002  slti        $at, $v0, 0x2
    ctx->pc = 0x1799d0u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)2) ? 1 : 0);
    // 0x1799d4: 0x14200156  bnez        $at, . + 4 + (0x156 << 2)
    ctx->pc = 0x1799D4u;
    {
        const bool branch_taken_0x1799d4 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x1799d4) {
            ctx->pc = 0x179F30u;
            goto label_179f30;
        }
    }
    ctx->pc = 0x1799DCu;
    // 0x1799dc: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x1799dcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1799e0: 0x2402005a  addiu       $v0, $zero, 0x5A
    ctx->pc = 0x1799e0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 90));
    // 0x1799e4: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x1799e4u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x1799e8: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x1799e8u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x1799ec: 0x0  nop
    ctx->pc = 0x1799ecu;
    // NOP
    // 0x1799f0: 0x0  nop
    ctx->pc = 0x1799f0u;
    // NOP
    // 0x1799f4: 0x1010  mfhi        $v0
    ctx->pc = 0x1799f4u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x1799f8: 0x14400035  bnez        $v0, . + 4 + (0x35 << 2)
    ctx->pc = 0x1799F8u;
    {
        const bool branch_taken_0x1799f8 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x1799f8) {
            ctx->pc = 0x179AD0u;
            goto label_179ad0;
        }
    }
    ctx->pc = 0x179A00u;
    // 0x179a00: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179a00u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179a04: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179a04u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179a08: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x179a08u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x179a0c: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x179a0cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x179a10: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179a10u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179a14: 0x0  nop
    ctx->pc = 0x179a14u;
    // NOP
    // 0x179a18: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179a18u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179a1c: 0xc05d080  jal         func_174200
    ctx->pc = 0x179A1Cu;
    SET_GPR_U32(ctx, 31, 0x179A24u);
    ctx->pc = 0x179A20u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179A1Cu;
            // 0x179a20: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179A24u; }
        if (ctx->pc != 0x179A24u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179A24u; }
        if (ctx->pc != 0x179A24u) { return; }
    }
    ctx->pc = 0x179A24u;
    // 0x179a24: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179a24u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179a28: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179a28u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179a2c: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x179a2cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x179a30: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x179a30u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x179a34: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179a34u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179a38: 0x0  nop
    ctx->pc = 0x179a38u;
    // NOP
    // 0x179a3c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179a3cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179a40: 0xc05d080  jal         func_174200
    ctx->pc = 0x179A40u;
    SET_GPR_U32(ctx, 31, 0x179A48u);
    ctx->pc = 0x179A44u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179A40u;
            // 0x179a44: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179A48u; }
        if (ctx->pc != 0x179A48u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179A48u; }
        if (ctx->pc != 0x179A48u) { return; }
    }
    ctx->pc = 0x179A48u;
    // 0x179a48: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179a48u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179a4c: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x179a4cu;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179a50: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179A50u;
    SET_GPR_U32(ctx, 31, 0x179A58u);
    ctx->pc = 0x179A54u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179A50u;
            // 0x179a54: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179A58u; }
        if (ctx->pc != 0x179A58u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179A58u; }
        if (ctx->pc != 0x179A58u) { return; }
    }
    ctx->pc = 0x179A58u;
    // 0x179a58: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x179a58u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179a5c: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x179a5cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x179a60: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x179a60u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179a64: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x179a64u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x179a68: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179a68u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x179a6c: 0xc065480  jal         func_195200
    ctx->pc = 0x179A6Cu;
    SET_GPR_U32(ctx, 31, 0x179A74u);
    ctx->pc = 0x179A70u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179A6Cu;
            // 0x179a70: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179A74u; }
        if (ctx->pc != 0x179A74u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179A74u; }
        if (ctx->pc != 0x179A74u) { return; }
    }
    ctx->pc = 0x179A74u;
    // 0x179a74: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179a74u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179a78: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179a78u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179a7c: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x179a7cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x179a80: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179A80u;
    SET_GPR_U32(ctx, 31, 0x179A88u);
    ctx->pc = 0x179A84u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179A80u;
            // 0x179a84: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179A88u; }
        if (ctx->pc != 0x179A88u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179A88u; }
        if (ctx->pc != 0x179A88u) { return; }
    }
    ctx->pc = 0x179A88u;
    // 0x179a88: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179a88u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179a8c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179a8cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x179a90: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179a90u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179a94: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x179a94u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x179a98: 0xc065508  jal         func_195420
    ctx->pc = 0x179A98u;
    SET_GPR_U32(ctx, 31, 0x179AA0u);
    ctx->pc = 0x179A9Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179A98u;
            // 0x179a9c: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179AA0u; }
        if (ctx->pc != 0x179AA0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179AA0u; }
        if (ctx->pc != 0x179AA0u) { return; }
    }
    ctx->pc = 0x179AA0u;
    // 0x179aa0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179aa0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179aa4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179aa4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179aa8: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x179aa8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x179aac: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179AACu;
    SET_GPR_U32(ctx, 31, 0x179AB4u);
    ctx->pc = 0x179AB0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179AACu;
            // 0x179ab0: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179AB4u; }
        if (ctx->pc != 0x179AB4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179AB4u; }
        if (ctx->pc != 0x179AB4u) { return; }
    }
    ctx->pc = 0x179AB4u;
    // 0x179ab4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179ab4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179ab8: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179ab8u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x179abc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179abcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179ac0: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x179ac0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x179ac4: 0xc065508  jal         func_195420
    ctx->pc = 0x179AC4u;
    SET_GPR_U32(ctx, 31, 0x179ACCu);
    ctx->pc = 0x179AC8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179AC4u;
            // 0x179ac8: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179ACCu; }
        if (ctx->pc != 0x179ACCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179ACCu; }
        if (ctx->pc != 0x179ACCu) { return; }
    }
    ctx->pc = 0x179ACCu;
    // 0x179acc: 0x0  nop
    ctx->pc = 0x179accu;
    // NOP
label_179ad0:
    // 0x179ad0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179ad0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179ad4: 0x24020046  addiu       $v0, $zero, 0x46
    ctx->pc = 0x179ad4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 70));
    // 0x179ad8: 0x24630019  addiu       $v1, $v1, 0x19
    ctx->pc = 0x179ad8u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 25));
    // 0x179adc: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179adcu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179ae0: 0x0  nop
    ctx->pc = 0x179ae0u;
    // NOP
    // 0x179ae4: 0x0  nop
    ctx->pc = 0x179ae4u;
    // NOP
    // 0x179ae8: 0x1010  mfhi        $v0
    ctx->pc = 0x179ae8u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179aec: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x179AECu;
    {
        const bool branch_taken_0x179aec = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179aec) {
            ctx->pc = 0x179B98u;
            goto label_179b98;
        }
    }
    ctx->pc = 0x179AF4u;
    // 0x179af4: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179af4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179af8: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179af8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179afc: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179afcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179b00: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x179b00u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x179b04: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179b04u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179b08: 0x0  nop
    ctx->pc = 0x179b08u;
    // NOP
    // 0x179b0c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179b0cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179b10: 0xc05d080  jal         func_174200
    ctx->pc = 0x179B10u;
    SET_GPR_U32(ctx, 31, 0x179B18u);
    ctx->pc = 0x179B14u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179B10u;
            // 0x179b14: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B18u; }
        if (ctx->pc != 0x179B18u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B18u; }
        if (ctx->pc != 0x179B18u) { return; }
    }
    ctx->pc = 0x179B18u;
    // 0x179b18: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179b18u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179b1c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179b1cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179b20: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179b20u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179b24: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x179b24u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x179b28: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179b28u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179b2c: 0x0  nop
    ctx->pc = 0x179b2cu;
    // NOP
    // 0x179b30: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179b30u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179b34: 0xc05d080  jal         func_174200
    ctx->pc = 0x179B34u;
    SET_GPR_U32(ctx, 31, 0x179B3Cu);
    ctx->pc = 0x179B38u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179B34u;
            // 0x179b38: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B3Cu; }
        if (ctx->pc != 0x179B3Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B3Cu; }
        if (ctx->pc != 0x179B3Cu) { return; }
    }
    ctx->pc = 0x179B3Cu;
    // 0x179b3c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179b3cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179b40: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179b40u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179b44: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179b44u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179b48: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179B48u;
    SET_GPR_U32(ctx, 31, 0x179B50u);
    ctx->pc = 0x179B4Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179B48u;
            // 0x179b4c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B50u; }
        if (ctx->pc != 0x179B50u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B50u; }
        if (ctx->pc != 0x179B50u) { return; }
    }
    ctx->pc = 0x179B50u;
    // 0x179b50: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179b50u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179b54: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179b54u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x179b58: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179b58u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179b5c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179b5cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179b60: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179B60u;
    SET_GPR_U32(ctx, 31, 0x179B68u);
    ctx->pc = 0x179B64u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179B60u;
            // 0x179b64: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B68u; }
        if (ctx->pc != 0x179B68u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B68u; }
        if (ctx->pc != 0x179B68u) { return; }
    }
    ctx->pc = 0x179B68u;
    // 0x179b68: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179b68u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179b6c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179b6cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179b70: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179b70u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179b74: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179B74u;
    SET_GPR_U32(ctx, 31, 0x179B7Cu);
    ctx->pc = 0x179B78u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179B74u;
            // 0x179b78: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B7Cu; }
        if (ctx->pc != 0x179B7Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B7Cu; }
        if (ctx->pc != 0x179B7Cu) { return; }
    }
    ctx->pc = 0x179B7Cu;
    // 0x179b7c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179b7cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179b80: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179b80u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x179b84: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179b84u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179b88: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179b88u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179b8c: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179B8Cu;
    SET_GPR_U32(ctx, 31, 0x179B94u);
    ctx->pc = 0x179B90u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179B8Cu;
            // 0x179b90: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B94u; }
        if (ctx->pc != 0x179B94u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179B94u; }
        if (ctx->pc != 0x179B94u) { return; }
    }
    ctx->pc = 0x179B94u;
    // 0x179b94: 0x0  nop
    ctx->pc = 0x179b94u;
    // NOP
label_179b98:
    // 0x179b98: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179b98u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179b9c: 0x24020046  addiu       $v0, $zero, 0x46
    ctx->pc = 0x179b9cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 70));
    // 0x179ba0: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x179ba0u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x179ba4: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179ba4u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179ba8: 0x0  nop
    ctx->pc = 0x179ba8u;
    // NOP
    // 0x179bac: 0x0  nop
    ctx->pc = 0x179bacu;
    // NOP
    // 0x179bb0: 0x1010  mfhi        $v0
    ctx->pc = 0x179bb0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179bb4: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x179BB4u;
    {
        const bool branch_taken_0x179bb4 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179bb4) {
            ctx->pc = 0x179C60u;
            goto label_179c60;
        }
    }
    ctx->pc = 0x179BBCu;
    // 0x179bbc: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179bbcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179bc0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179bc0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179bc4: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179bc4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179bc8: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x179bc8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x179bcc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179bccu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179bd0: 0x0  nop
    ctx->pc = 0x179bd0u;
    // NOP
    // 0x179bd4: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179bd4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179bd8: 0xc05d080  jal         func_174200
    ctx->pc = 0x179BD8u;
    SET_GPR_U32(ctx, 31, 0x179BE0u);
    ctx->pc = 0x179BDCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179BD8u;
            // 0x179bdc: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179BE0u; }
        if (ctx->pc != 0x179BE0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179BE0u; }
        if (ctx->pc != 0x179BE0u) { return; }
    }
    ctx->pc = 0x179BE0u;
    // 0x179be0: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179be0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179be4: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179be4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179be8: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179be8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179bec: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x179becu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x179bf0: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179bf0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179bf4: 0x0  nop
    ctx->pc = 0x179bf4u;
    // NOP
    // 0x179bf8: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179bf8u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179bfc: 0xc05d080  jal         func_174200
    ctx->pc = 0x179BFCu;
    SET_GPR_U32(ctx, 31, 0x179C04u);
    ctx->pc = 0x179C00u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179BFCu;
            // 0x179c00: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179C04u; }
        if (ctx->pc != 0x179C04u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179C04u; }
        if (ctx->pc != 0x179C04u) { return; }
    }
    ctx->pc = 0x179C04u;
    // 0x179c04: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179c04u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179c08: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179c08u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179c0c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179c0cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179c10: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179C10u;
    SET_GPR_U32(ctx, 31, 0x179C18u);
    ctx->pc = 0x179C14u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179C10u;
            // 0x179c14: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179C18u; }
        if (ctx->pc != 0x179C18u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179C18u; }
        if (ctx->pc != 0x179C18u) { return; }
    }
    ctx->pc = 0x179C18u;
    // 0x179c18: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179c18u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179c1c: 0x24060004  addiu       $a2, $zero, 0x4
    ctx->pc = 0x179c1cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 4));
    // 0x179c20: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179c20u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179c24: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179c24u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179c28: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179C28u;
    SET_GPR_U32(ctx, 31, 0x179C30u);
    ctx->pc = 0x179C2Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179C28u;
            // 0x179c2c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179C30u; }
        if (ctx->pc != 0x179C30u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179C30u; }
        if (ctx->pc != 0x179C30u) { return; }
    }
    ctx->pc = 0x179C30u;
    // 0x179c30: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179c30u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179c34: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179c34u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179c38: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179c38u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179c3c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179C3Cu;
    SET_GPR_U32(ctx, 31, 0x179C44u);
    ctx->pc = 0x179C40u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179C3Cu;
            // 0x179c40: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179C44u; }
        if (ctx->pc != 0x179C44u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179C44u; }
        if (ctx->pc != 0x179C44u) { return; }
    }
    ctx->pc = 0x179C44u;
    // 0x179c44: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179c44u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179c48: 0x24060074  addiu       $a2, $zero, 0x74
    ctx->pc = 0x179c48u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 116));
    // 0x179c4c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179c4cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179c50: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179c50u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179c54: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179C54u;
    SET_GPR_U32(ctx, 31, 0x179C5Cu);
    ctx->pc = 0x179C58u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179C54u;
            // 0x179c58: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179C5Cu; }
        if (ctx->pc != 0x179C5Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179C5Cu; }
        if (ctx->pc != 0x179C5Cu) { return; }
    }
    ctx->pc = 0x179C5Cu;
    // 0x179c5c: 0x0  nop
    ctx->pc = 0x179c5cu;
    // NOP
label_179c60:
    // 0x179c60: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179c60u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179c64: 0x24020046  addiu       $v0, $zero, 0x46
    ctx->pc = 0x179c64u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 70));
    // 0x179c68: 0x2463000f  addiu       $v1, $v1, 0xF
    ctx->pc = 0x179c68u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 15));
    // 0x179c6c: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179c6cu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179c70: 0x0  nop
    ctx->pc = 0x179c70u;
    // NOP
    // 0x179c74: 0x0  nop
    ctx->pc = 0x179c74u;
    // NOP
    // 0x179c78: 0x1010  mfhi        $v0
    ctx->pc = 0x179c78u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179c7c: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x179C7Cu;
    {
        const bool branch_taken_0x179c7c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179c7c) {
            ctx->pc = 0x179D28u;
            goto label_179d28;
        }
    }
    ctx->pc = 0x179C84u;
    // 0x179c84: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179c84u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179c88: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179c88u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179c8c: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179c8cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179c90: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x179c90u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x179c94: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179c94u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179c98: 0x0  nop
    ctx->pc = 0x179c98u;
    // NOP
    // 0x179c9c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179c9cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179ca0: 0xc05d080  jal         func_174200
    ctx->pc = 0x179CA0u;
    SET_GPR_U32(ctx, 31, 0x179CA8u);
    ctx->pc = 0x179CA4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179CA0u;
            // 0x179ca4: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179CA8u; }
        if (ctx->pc != 0x179CA8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179CA8u; }
        if (ctx->pc != 0x179CA8u) { return; }
    }
    ctx->pc = 0x179CA8u;
    // 0x179ca8: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179ca8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179cac: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179cacu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179cb0: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179cb0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179cb4: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x179cb4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x179cb8: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179cb8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179cbc: 0x0  nop
    ctx->pc = 0x179cbcu;
    // NOP
    // 0x179cc0: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179cc0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179cc4: 0xc05d080  jal         func_174200
    ctx->pc = 0x179CC4u;
    SET_GPR_U32(ctx, 31, 0x179CCCu);
    ctx->pc = 0x179CC8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179CC4u;
            // 0x179cc8: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179CCCu; }
        if (ctx->pc != 0x179CCCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179CCCu; }
        if (ctx->pc != 0x179CCCu) { return; }
    }
    ctx->pc = 0x179CCCu;
    // 0x179ccc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179cccu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179cd0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179cd0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179cd4: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179cd4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179cd8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179CD8u;
    SET_GPR_U32(ctx, 31, 0x179CE0u);
    ctx->pc = 0x179CDCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179CD8u;
            // 0x179cdc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179CE0u; }
        if (ctx->pc != 0x179CE0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179CE0u; }
        if (ctx->pc != 0x179CE0u) { return; }
    }
    ctx->pc = 0x179CE0u;
    // 0x179ce0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179ce0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179ce4: 0x24060008  addiu       $a2, $zero, 0x8
    ctx->pc = 0x179ce4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 8));
    // 0x179ce8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179ce8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179cec: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179cecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179cf0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179CF0u;
    SET_GPR_U32(ctx, 31, 0x179CF8u);
    ctx->pc = 0x179CF4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179CF0u;
            // 0x179cf4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179CF8u; }
        if (ctx->pc != 0x179CF8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179CF8u; }
        if (ctx->pc != 0x179CF8u) { return; }
    }
    ctx->pc = 0x179CF8u;
    // 0x179cf8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179cf8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179cfc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179cfcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179d00: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179d00u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179d04: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179D04u;
    SET_GPR_U32(ctx, 31, 0x179D0Cu);
    ctx->pc = 0x179D08u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179D04u;
            // 0x179d08: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179D0Cu; }
        if (ctx->pc != 0x179D0Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179D0Cu; }
        if (ctx->pc != 0x179D0Cu) { return; }
    }
    ctx->pc = 0x179D0Cu;
    // 0x179d0c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179d0cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179d10: 0x24060070  addiu       $a2, $zero, 0x70
    ctx->pc = 0x179d10u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 112));
    // 0x179d14: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179d14u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179d18: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179d18u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179d1c: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179D1Cu;
    SET_GPR_U32(ctx, 31, 0x179D24u);
    ctx->pc = 0x179D20u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179D1Cu;
            // 0x179d20: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179D24u; }
        if (ctx->pc != 0x179D24u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179D24u; }
        if (ctx->pc != 0x179D24u) { return; }
    }
    ctx->pc = 0x179D24u;
    // 0x179d24: 0x0  nop
    ctx->pc = 0x179d24u;
    // NOP
label_179d28:
    // 0x179d28: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179d28u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179d2c: 0x24020046  addiu       $v0, $zero, 0x46
    ctx->pc = 0x179d2cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 70));
    // 0x179d30: 0x2463000a  addiu       $v1, $v1, 0xA
    ctx->pc = 0x179d30u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 10));
    // 0x179d34: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179d34u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179d38: 0x0  nop
    ctx->pc = 0x179d38u;
    // NOP
    // 0x179d3c: 0x0  nop
    ctx->pc = 0x179d3cu;
    // NOP
    // 0x179d40: 0x1010  mfhi        $v0
    ctx->pc = 0x179d40u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179d44: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x179D44u;
    {
        const bool branch_taken_0x179d44 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179d44) {
            ctx->pc = 0x179DF0u;
            goto label_179df0;
        }
    }
    ctx->pc = 0x179D4Cu;
    // 0x179d4c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179d4cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179d50: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179d50u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179d54: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179d54u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179d58: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x179d58u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x179d5c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179d5cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179d60: 0x0  nop
    ctx->pc = 0x179d60u;
    // NOP
    // 0x179d64: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179d64u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179d68: 0xc05d080  jal         func_174200
    ctx->pc = 0x179D68u;
    SET_GPR_U32(ctx, 31, 0x179D70u);
    ctx->pc = 0x179D6Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179D68u;
            // 0x179d6c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179D70u; }
        if (ctx->pc != 0x179D70u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179D70u; }
        if (ctx->pc != 0x179D70u) { return; }
    }
    ctx->pc = 0x179D70u;
    // 0x179d70: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179d70u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179d74: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179d74u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179d78: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179d78u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179d7c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x179d7cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x179d80: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179d80u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179d84: 0x0  nop
    ctx->pc = 0x179d84u;
    // NOP
    // 0x179d88: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179d88u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179d8c: 0xc05d080  jal         func_174200
    ctx->pc = 0x179D8Cu;
    SET_GPR_U32(ctx, 31, 0x179D94u);
    ctx->pc = 0x179D90u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179D8Cu;
            // 0x179d90: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179D94u; }
        if (ctx->pc != 0x179D94u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179D94u; }
        if (ctx->pc != 0x179D94u) { return; }
    }
    ctx->pc = 0x179D94u;
    // 0x179d94: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179d94u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179d98: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179d98u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179d9c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179d9cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179da0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179DA0u;
    SET_GPR_U32(ctx, 31, 0x179DA8u);
    ctx->pc = 0x179DA4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179DA0u;
            // 0x179da4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179DA8u; }
        if (ctx->pc != 0x179DA8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179DA8u; }
        if (ctx->pc != 0x179DA8u) { return; }
    }
    ctx->pc = 0x179DA8u;
    // 0x179da8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179da8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179dac: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x179dacu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x179db0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179db0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179db4: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179db4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179db8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179DB8u;
    SET_GPR_U32(ctx, 31, 0x179DC0u);
    ctx->pc = 0x179DBCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179DB8u;
            // 0x179dbc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179DC0u; }
        if (ctx->pc != 0x179DC0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179DC0u; }
        if (ctx->pc != 0x179DC0u) { return; }
    }
    ctx->pc = 0x179DC0u;
    // 0x179dc0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179dc0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179dc4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179dc4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179dc8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179dc8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179dcc: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179DCCu;
    SET_GPR_U32(ctx, 31, 0x179DD4u);
    ctx->pc = 0x179DD0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179DCCu;
            // 0x179dd0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179DD4u; }
        if (ctx->pc != 0x179DD4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179DD4u; }
        if (ctx->pc != 0x179DD4u) { return; }
    }
    ctx->pc = 0x179DD4u;
    // 0x179dd4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179dd4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179dd8: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x179dd8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x179ddc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179ddcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179de0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179de0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179de4: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179DE4u;
    SET_GPR_U32(ctx, 31, 0x179DECu);
    ctx->pc = 0x179DE8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179DE4u;
            // 0x179de8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179DECu; }
        if (ctx->pc != 0x179DECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179DECu; }
        if (ctx->pc != 0x179DECu) { return; }
    }
    ctx->pc = 0x179DECu;
    // 0x179dec: 0x0  nop
    ctx->pc = 0x179decu;
    // NOP
label_179df0:
    // 0x179df0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179df0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179df4: 0x24020046  addiu       $v0, $zero, 0x46
    ctx->pc = 0x179df4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 70));
    // 0x179df8: 0x24630005  addiu       $v1, $v1, 0x5
    ctx->pc = 0x179df8u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 5));
    // 0x179dfc: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179dfcu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179e00: 0x0  nop
    ctx->pc = 0x179e00u;
    // NOP
    // 0x179e04: 0x0  nop
    ctx->pc = 0x179e04u;
    // NOP
    // 0x179e08: 0x1010  mfhi        $v0
    ctx->pc = 0x179e08u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179e0c: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x179E0Cu;
    {
        const bool branch_taken_0x179e0c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179e0c) {
            ctx->pc = 0x179EB8u;
            goto label_179eb8;
        }
    }
    ctx->pc = 0x179E14u;
    // 0x179e14: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179e14u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179e18: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179e18u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179e1c: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179e1cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179e20: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x179e20u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x179e24: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179e24u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179e28: 0x0  nop
    ctx->pc = 0x179e28u;
    // NOP
    // 0x179e2c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179e2cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179e30: 0xc05d080  jal         func_174200
    ctx->pc = 0x179E30u;
    SET_GPR_U32(ctx, 31, 0x179E38u);
    ctx->pc = 0x179E34u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179E30u;
            // 0x179e34: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179E38u; }
        if (ctx->pc != 0x179E38u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179E38u; }
        if (ctx->pc != 0x179E38u) { return; }
    }
    ctx->pc = 0x179E38u;
    // 0x179e38: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179e38u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179e3c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179e3cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179e40: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x179e40u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x179e44: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x179e44u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x179e48: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179e48u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179e4c: 0x0  nop
    ctx->pc = 0x179e4cu;
    // NOP
    // 0x179e50: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179e50u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179e54: 0xc05d080  jal         func_174200
    ctx->pc = 0x179E54u;
    SET_GPR_U32(ctx, 31, 0x179E5Cu);
    ctx->pc = 0x179E58u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179E54u;
            // 0x179e58: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179E5Cu; }
        if (ctx->pc != 0x179E5Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179E5Cu; }
        if (ctx->pc != 0x179E5Cu) { return; }
    }
    ctx->pc = 0x179E5Cu;
    // 0x179e5c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179e5cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179e60: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179e60u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179e64: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179e64u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179e68: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179E68u;
    SET_GPR_U32(ctx, 31, 0x179E70u);
    ctx->pc = 0x179E6Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179E68u;
            // 0x179e6c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179E70u; }
        if (ctx->pc != 0x179E70u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179E70u; }
        if (ctx->pc != 0x179E70u) { return; }
    }
    ctx->pc = 0x179E70u;
    // 0x179e70: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179e70u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179e74: 0x24060010  addiu       $a2, $zero, 0x10
    ctx->pc = 0x179e74u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 16));
    // 0x179e78: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179e78u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179e7c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x179e7cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x179e80: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179E80u;
    SET_GPR_U32(ctx, 31, 0x179E88u);
    ctx->pc = 0x179E84u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179E80u;
            // 0x179e84: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179E88u; }
        if (ctx->pc != 0x179E88u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179E88u; }
        if (ctx->pc != 0x179E88u) { return; }
    }
    ctx->pc = 0x179E88u;
    // 0x179e88: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179e88u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179e8c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179e8cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179e90: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179e90u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179e94: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179E94u;
    SET_GPR_U32(ctx, 31, 0x179E9Cu);
    ctx->pc = 0x179E98u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179E94u;
            // 0x179e98: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179E9Cu; }
        if (ctx->pc != 0x179E9Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179E9Cu; }
        if (ctx->pc != 0x179E9Cu) { return; }
    }
    ctx->pc = 0x179E9Cu;
    // 0x179e9c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179e9cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179ea0: 0x24060068  addiu       $a2, $zero, 0x68
    ctx->pc = 0x179ea0u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 104));
    // 0x179ea4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179ea4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179ea8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x179ea8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x179eac: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x179EACu;
    SET_GPR_U32(ctx, 31, 0x179EB4u);
    ctx->pc = 0x179EB0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179EACu;
            // 0x179eb0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179EB4u; }
        if (ctx->pc != 0x179EB4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179EB4u; }
        if (ctx->pc != 0x179EB4u) { return; }
    }
    ctx->pc = 0x179EB4u;
    // 0x179eb4: 0x0  nop
    ctx->pc = 0x179eb4u;
    // NOP
label_179eb8:
    // 0x179eb8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179eb8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179ebc: 0x24020019  addiu       $v0, $zero, 0x19
    ctx->pc = 0x179ebcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 25));
    // 0x179ec0: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179ec0u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179ec4: 0x0  nop
    ctx->pc = 0x179ec4u;
    // NOP
    // 0x179ec8: 0x0  nop
    ctx->pc = 0x179ec8u;
    // NOP
    // 0x179ecc: 0x1010  mfhi        $v0
    ctx->pc = 0x179eccu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179ed0: 0x144001c7  bnez        $v0, . + 4 + (0x1C7 << 2)
    ctx->pc = 0x179ED0u;
    {
        const bool branch_taken_0x179ed0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179ed0) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x179ED8u;
    // 0x179ed8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179ed8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179edc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179edcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179ee0: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x179ee0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x179ee4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179EE4u;
    SET_GPR_U32(ctx, 31, 0x179EECu);
    ctx->pc = 0x179EE8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179EE4u;
            // 0x179ee8: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179EECu; }
        if (ctx->pc != 0x179EECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179EECu; }
        if (ctx->pc != 0x179EECu) { return; }
    }
    ctx->pc = 0x179EECu;
    // 0x179eec: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179eecu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179ef0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179ef0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179ef4: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x179ef4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x179ef8: 0xc06560c  jal         func_195830
    ctx->pc = 0x179EF8u;
    SET_GPR_U32(ctx, 31, 0x179F00u);
    ctx->pc = 0x179EFCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179EF8u;
            // 0x179efc: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179F00u; }
        if (ctx->pc != 0x179F00u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179F00u; }
        if (ctx->pc != 0x179F00u) { return; }
    }
    ctx->pc = 0x179F00u;
    // 0x179f00: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179f00u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179f04: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179f04u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179f08: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x179f08u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x179f0c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179F0Cu;
    SET_GPR_U32(ctx, 31, 0x179F14u);
    ctx->pc = 0x179F10u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179F0Cu;
            // 0x179f10: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179F14u; }
        if (ctx->pc != 0x179F14u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179F14u; }
        if (ctx->pc != 0x179F14u) { return; }
    }
    ctx->pc = 0x179F14u;
    // 0x179f14: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179f14u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179f18: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179f18u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179f1c: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x179f1cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x179f20: 0xc06560c  jal         func_195830
    ctx->pc = 0x179F20u;
    SET_GPR_U32(ctx, 31, 0x179F28u);
    ctx->pc = 0x179F24u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179F20u;
            // 0x179f24: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179F28u; }
        if (ctx->pc != 0x179F28u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179F28u; }
        if (ctx->pc != 0x179F28u) { return; }
    }
    ctx->pc = 0x179F28u;
    // 0x179f28: 0x100001b1  b           . + 4 + (0x1B1 << 2)
    ctx->pc = 0x179F28u;
    {
        const bool branch_taken_0x179f28 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x179f28) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x179F30u;
label_179f30:
    // 0x179f30: 0xc065d00  jal         func_197400
    ctx->pc = 0x179F30u;
    SET_GPR_U32(ctx, 31, 0x179F38u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179F38u; }
        if (ctx->pc != 0x179F38u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179F38u; }
        if (ctx->pc != 0x179F38u) { return; }
    }
    ctx->pc = 0x179F38u;
    // 0x179f38: 0x184000f1  blez        $v0, . + 4 + (0xF1 << 2)
    ctx->pc = 0x179F38u;
    {
        const bool branch_taken_0x179f38 = (GPR_S32(ctx, 2) <= 0);
        if (branch_taken_0x179f38) {
            ctx->pc = 0x17A300u;
            goto label_17a300;
        }
    }
    ctx->pc = 0x179F40u;
    // 0x179f40: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x179f40u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x179f44: 0x240200b4  addiu       $v0, $zero, 0xB4
    ctx->pc = 0x179f44u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 180));
    // 0x179f48: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x179f48u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x179f4c: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x179f4cu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x179f50: 0x0  nop
    ctx->pc = 0x179f50u;
    // NOP
    // 0x179f54: 0x0  nop
    ctx->pc = 0x179f54u;
    // NOP
    // 0x179f58: 0x1010  mfhi        $v0
    ctx->pc = 0x179f58u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x179f5c: 0x14400034  bnez        $v0, . + 4 + (0x34 << 2)
    ctx->pc = 0x179F5Cu;
    {
        const bool branch_taken_0x179f5c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x179f5c) {
            ctx->pc = 0x17A030u;
            goto label_17a030;
        }
    }
    ctx->pc = 0x179F64u;
    // 0x179f64: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179f64u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179f68: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179f68u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179f6c: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x179f6cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x179f70: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x179f70u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x179f74: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179f74u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179f78: 0x0  nop
    ctx->pc = 0x179f78u;
    // NOP
    // 0x179f7c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179f7cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179f80: 0xc05d080  jal         func_174200
    ctx->pc = 0x179F80u;
    SET_GPR_U32(ctx, 31, 0x179F88u);
    ctx->pc = 0x179F84u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179F80u;
            // 0x179f84: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179F88u; }
        if (ctx->pc != 0x179F88u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179F88u; }
        if (ctx->pc != 0x179F88u) { return; }
    }
    ctx->pc = 0x179F88u;
    // 0x179f88: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x179f88u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179f8c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x179f8cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x179f90: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x179f90u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x179f94: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x179f94u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x179f98: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x179f98u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x179f9c: 0x0  nop
    ctx->pc = 0x179f9cu;
    // NOP
    // 0x179fa0: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x179fa0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x179fa4: 0xc05d080  jal         func_174200
    ctx->pc = 0x179FA4u;
    SET_GPR_U32(ctx, 31, 0x179FACu);
    ctx->pc = 0x179FA8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179FA4u;
            // 0x179fa8: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179FACu; }
        if (ctx->pc != 0x179FACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179FACu; }
        if (ctx->pc != 0x179FACu) { return; }
    }
    ctx->pc = 0x179FACu;
    // 0x179fac: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179facu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179fb0: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x179fb0u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179fb4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179FB4u;
    SET_GPR_U32(ctx, 31, 0x179FBCu);
    ctx->pc = 0x179FB8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179FB4u;
            // 0x179fb8: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179FBCu; }
        if (ctx->pc != 0x179FBCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179FBCu; }
        if (ctx->pc != 0x179FBCu) { return; }
    }
    ctx->pc = 0x179FBCu;
    // 0x179fbc: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x179fbcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179fc0: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x179fc0u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x179fc4: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x179fc4u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179fc8: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x179fc8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x179fcc: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179fccu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x179fd0: 0xc065480  jal         func_195200
    ctx->pc = 0x179FD0u;
    SET_GPR_U32(ctx, 31, 0x179FD8u);
    ctx->pc = 0x179FD4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179FD0u;
            // 0x179fd4: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179FD8u; }
        if (ctx->pc != 0x179FD8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179FD8u; }
        if (ctx->pc != 0x179FD8u) { return; }
    }
    ctx->pc = 0x179FD8u;
    // 0x179fd8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179fd8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179fdc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179fdcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179fe0: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x179fe0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x179fe4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x179FE4u;
    SET_GPR_U32(ctx, 31, 0x179FECu);
    ctx->pc = 0x179FE8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179FE4u;
            // 0x179fe8: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179FECu; }
        if (ctx->pc != 0x179FECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x179FECu; }
        if (ctx->pc != 0x179FECu) { return; }
    }
    ctx->pc = 0x179FECu;
    // 0x179fec: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x179fecu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x179ff0: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x179ff0u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x179ff4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x179ff4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x179ff8: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x179ff8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x179ffc: 0xc065508  jal         func_195420
    ctx->pc = 0x179FFCu;
    SET_GPR_U32(ctx, 31, 0x17A004u);
    ctx->pc = 0x17A000u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x179FFCu;
            // 0x17a000: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A004u; }
        if (ctx->pc != 0x17A004u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A004u; }
        if (ctx->pc != 0x17A004u) { return; }
    }
    ctx->pc = 0x17A004u;
    // 0x17a004: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a004u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a008: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a008u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a00c: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x17a00cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x17a010: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A010u;
    SET_GPR_U32(ctx, 31, 0x17A018u);
    ctx->pc = 0x17A014u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A010u;
            // 0x17a014: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A018u; }
        if (ctx->pc != 0x17A018u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A018u; }
        if (ctx->pc != 0x17A018u) { return; }
    }
    ctx->pc = 0x17A018u;
    // 0x17a018: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a018u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a01c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a01cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a020: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a020u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a024: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x17a024u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x17a028: 0xc065508  jal         func_195420
    ctx->pc = 0x17A028u;
    SET_GPR_U32(ctx, 31, 0x17A030u);
    ctx->pc = 0x17A02Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A028u;
            // 0x17a02c: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A030u; }
        if (ctx->pc != 0x17A030u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A030u; }
        if (ctx->pc != 0x17A030u) { return; }
    }
    ctx->pc = 0x17A030u;
label_17a030:
    // 0x17a030: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a030u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a034: 0x24020046  addiu       $v0, $zero, 0x46
    ctx->pc = 0x17a034u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 70));
    // 0x17a038: 0x24630019  addiu       $v1, $v1, 0x19
    ctx->pc = 0x17a038u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 25));
    // 0x17a03c: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a03cu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a040: 0x0  nop
    ctx->pc = 0x17a040u;
    // NOP
    // 0x17a044: 0x0  nop
    ctx->pc = 0x17a044u;
    // NOP
    // 0x17a048: 0x1010  mfhi        $v0
    ctx->pc = 0x17a048u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a04c: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x17A04Cu;
    {
        const bool branch_taken_0x17a04c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a04c) {
            ctx->pc = 0x17A0F8u;
            goto label_17a0f8;
        }
    }
    ctx->pc = 0x17A054u;
    // 0x17a054: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a054u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a058: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a058u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a05c: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17a05cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17a060: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17a060u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17a064: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a064u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a068: 0x0  nop
    ctx->pc = 0x17a068u;
    // NOP
    // 0x17a06c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a06cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a070: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A070u;
    SET_GPR_U32(ctx, 31, 0x17A078u);
    ctx->pc = 0x17A074u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A070u;
            // 0x17a074: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A078u; }
        if (ctx->pc != 0x17A078u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A078u; }
        if (ctx->pc != 0x17A078u) { return; }
    }
    ctx->pc = 0x17A078u;
    // 0x17a078: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a078u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a07c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a07cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a080: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17a080u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17a084: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17a084u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17a088: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a088u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a08c: 0x0  nop
    ctx->pc = 0x17a08cu;
    // NOP
    // 0x17a090: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a090u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a094: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A094u;
    SET_GPR_U32(ctx, 31, 0x17A09Cu);
    ctx->pc = 0x17A098u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A094u;
            // 0x17a098: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A09Cu; }
        if (ctx->pc != 0x17A09Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A09Cu; }
        if (ctx->pc != 0x17A09Cu) { return; }
    }
    ctx->pc = 0x17A09Cu;
    // 0x17a09c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a09cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a0a0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a0a0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a0a4: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a0a4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a0a8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A0A8u;
    SET_GPR_U32(ctx, 31, 0x17A0B0u);
    ctx->pc = 0x17A0ACu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A0A8u;
            // 0x17a0ac: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A0B0u; }
        if (ctx->pc != 0x17A0B0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A0B0u; }
        if (ctx->pc != 0x17A0B0u) { return; }
    }
    ctx->pc = 0x17A0B0u;
    // 0x17a0b0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a0b0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a0b4: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a0b4u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a0b8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a0b8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a0bc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a0bcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a0c0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A0C0u;
    SET_GPR_U32(ctx, 31, 0x17A0C8u);
    ctx->pc = 0x17A0C4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A0C0u;
            // 0x17a0c4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A0C8u; }
        if (ctx->pc != 0x17A0C8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A0C8u; }
        if (ctx->pc != 0x17A0C8u) { return; }
    }
    ctx->pc = 0x17A0C8u;
    // 0x17a0c8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a0c8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a0cc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a0ccu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a0d0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a0d0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a0d4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A0D4u;
    SET_GPR_U32(ctx, 31, 0x17A0DCu);
    ctx->pc = 0x17A0D8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A0D4u;
            // 0x17a0d8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A0DCu; }
        if (ctx->pc != 0x17A0DCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A0DCu; }
        if (ctx->pc != 0x17A0DCu) { return; }
    }
    ctx->pc = 0x17A0DCu;
    // 0x17a0dc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a0dcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a0e0: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a0e0u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a0e4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a0e4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a0e8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a0e8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a0ec: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A0ECu;
    SET_GPR_U32(ctx, 31, 0x17A0F4u);
    ctx->pc = 0x17A0F0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A0ECu;
            // 0x17a0f0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A0F4u; }
        if (ctx->pc != 0x17A0F4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A0F4u; }
        if (ctx->pc != 0x17A0F4u) { return; }
    }
    ctx->pc = 0x17A0F4u;
    // 0x17a0f4: 0x0  nop
    ctx->pc = 0x17a0f4u;
    // NOP
label_17a0f8:
    // 0x17a0f8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a0f8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a0fc: 0x24020046  addiu       $v0, $zero, 0x46
    ctx->pc = 0x17a0fcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 70));
    // 0x17a100: 0x2463000f  addiu       $v1, $v1, 0xF
    ctx->pc = 0x17a100u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 15));
    // 0x17a104: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a104u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a108: 0x0  nop
    ctx->pc = 0x17a108u;
    // NOP
    // 0x17a10c: 0x0  nop
    ctx->pc = 0x17a10cu;
    // NOP
    // 0x17a110: 0x1010  mfhi        $v0
    ctx->pc = 0x17a110u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a114: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x17A114u;
    {
        const bool branch_taken_0x17a114 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a114) {
            ctx->pc = 0x17A1C0u;
            goto label_17a1c0;
        }
    }
    ctx->pc = 0x17A11Cu;
    // 0x17a11c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a11cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a120: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a120u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a124: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17a124u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17a128: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17a128u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17a12c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a12cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a130: 0x0  nop
    ctx->pc = 0x17a130u;
    // NOP
    // 0x17a134: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a134u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a138: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A138u;
    SET_GPR_U32(ctx, 31, 0x17A140u);
    ctx->pc = 0x17A13Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A138u;
            // 0x17a13c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A140u; }
        if (ctx->pc != 0x17A140u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A140u; }
        if (ctx->pc != 0x17A140u) { return; }
    }
    ctx->pc = 0x17A140u;
    // 0x17a140: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a140u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a144: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a144u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a148: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17a148u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17a14c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17a14cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17a150: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a150u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a154: 0x0  nop
    ctx->pc = 0x17a154u;
    // NOP
    // 0x17a158: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a158u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a15c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A15Cu;
    SET_GPR_U32(ctx, 31, 0x17A164u);
    ctx->pc = 0x17A160u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A15Cu;
            // 0x17a160: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A164u; }
        if (ctx->pc != 0x17A164u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A164u; }
        if (ctx->pc != 0x17A164u) { return; }
    }
    ctx->pc = 0x17A164u;
    // 0x17a164: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a164u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a168: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a168u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a16c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a16cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a170: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A170u;
    SET_GPR_U32(ctx, 31, 0x17A178u);
    ctx->pc = 0x17A174u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A170u;
            // 0x17a174: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A178u; }
        if (ctx->pc != 0x17A178u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A178u; }
        if (ctx->pc != 0x17A178u) { return; }
    }
    ctx->pc = 0x17A178u;
    // 0x17a178: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a178u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a17c: 0x2406000a  addiu       $a2, $zero, 0xA
    ctx->pc = 0x17a17cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 10));
    // 0x17a180: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a180u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a184: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a184u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a188: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A188u;
    SET_GPR_U32(ctx, 31, 0x17A190u);
    ctx->pc = 0x17A18Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A188u;
            // 0x17a18c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A190u; }
        if (ctx->pc != 0x17A190u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A190u; }
        if (ctx->pc != 0x17A190u) { return; }
    }
    ctx->pc = 0x17A190u;
    // 0x17a190: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a190u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a194: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a194u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a198: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a198u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a19c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A19Cu;
    SET_GPR_U32(ctx, 31, 0x17A1A4u);
    ctx->pc = 0x17A1A0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A19Cu;
            // 0x17a1a0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A1A4u; }
        if (ctx->pc != 0x17A1A4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A1A4u; }
        if (ctx->pc != 0x17A1A4u) { return; }
    }
    ctx->pc = 0x17A1A4u;
    // 0x17a1a4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a1a4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a1a8: 0x2406006e  addiu       $a2, $zero, 0x6E
    ctx->pc = 0x17a1a8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 110));
    // 0x17a1ac: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a1acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a1b0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a1b0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a1b4: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A1B4u;
    SET_GPR_U32(ctx, 31, 0x17A1BCu);
    ctx->pc = 0x17A1B8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A1B4u;
            // 0x17a1b8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A1BCu; }
        if (ctx->pc != 0x17A1BCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A1BCu; }
        if (ctx->pc != 0x17A1BCu) { return; }
    }
    ctx->pc = 0x17A1BCu;
    // 0x17a1bc: 0x0  nop
    ctx->pc = 0x17a1bcu;
    // NOP
label_17a1c0:
    // 0x17a1c0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a1c0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a1c4: 0x24020046  addiu       $v0, $zero, 0x46
    ctx->pc = 0x17a1c4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 70));
    // 0x17a1c8: 0x24630005  addiu       $v1, $v1, 0x5
    ctx->pc = 0x17a1c8u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 5));
    // 0x17a1cc: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a1ccu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a1d0: 0x0  nop
    ctx->pc = 0x17a1d0u;
    // NOP
    // 0x17a1d4: 0x0  nop
    ctx->pc = 0x17a1d4u;
    // NOP
    // 0x17a1d8: 0x1010  mfhi        $v0
    ctx->pc = 0x17a1d8u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a1dc: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x17A1DCu;
    {
        const bool branch_taken_0x17a1dc = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a1dc) {
            ctx->pc = 0x17A288u;
            goto label_17a288;
        }
    }
    ctx->pc = 0x17A1E4u;
    // 0x17a1e4: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a1e4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a1e8: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a1e8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a1ec: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17a1ecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17a1f0: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17a1f0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17a1f4: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a1f4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a1f8: 0x0  nop
    ctx->pc = 0x17a1f8u;
    // NOP
    // 0x17a1fc: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a1fcu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a200: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A200u;
    SET_GPR_U32(ctx, 31, 0x17A208u);
    ctx->pc = 0x17A204u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A200u;
            // 0x17a204: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A208u; }
        if (ctx->pc != 0x17A208u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A208u; }
        if (ctx->pc != 0x17A208u) { return; }
    }
    ctx->pc = 0x17A208u;
    // 0x17a208: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a208u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a20c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a20cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a210: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17a210u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17a214: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17a214u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17a218: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a218u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a21c: 0x0  nop
    ctx->pc = 0x17a21cu;
    // NOP
    // 0x17a220: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a220u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a224: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A224u;
    SET_GPR_U32(ctx, 31, 0x17A22Cu);
    ctx->pc = 0x17A228u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A224u;
            // 0x17a228: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A22Cu; }
        if (ctx->pc != 0x17A22Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A22Cu; }
        if (ctx->pc != 0x17A22Cu) { return; }
    }
    ctx->pc = 0x17A22Cu;
    // 0x17a22c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a22cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a230: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a230u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a234: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a234u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a238: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A238u;
    SET_GPR_U32(ctx, 31, 0x17A240u);
    ctx->pc = 0x17A23Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A238u;
            // 0x17a23c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A240u; }
        if (ctx->pc != 0x17A240u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A240u; }
        if (ctx->pc != 0x17A240u) { return; }
    }
    ctx->pc = 0x17A240u;
    // 0x17a240: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a240u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a244: 0x24060014  addiu       $a2, $zero, 0x14
    ctx->pc = 0x17a244u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 20));
    // 0x17a248: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a248u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a24c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a24cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a250: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A250u;
    SET_GPR_U32(ctx, 31, 0x17A258u);
    ctx->pc = 0x17A254u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A250u;
            // 0x17a254: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A258u; }
        if (ctx->pc != 0x17A258u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A258u; }
        if (ctx->pc != 0x17A258u) { return; }
    }
    ctx->pc = 0x17A258u;
    // 0x17a258: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a258u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a25c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a25cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a260: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a260u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a264: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A264u;
    SET_GPR_U32(ctx, 31, 0x17A26Cu);
    ctx->pc = 0x17A268u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A264u;
            // 0x17a268: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A26Cu; }
        if (ctx->pc != 0x17A26Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A26Cu; }
        if (ctx->pc != 0x17A26Cu) { return; }
    }
    ctx->pc = 0x17A26Cu;
    // 0x17a26c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a26cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a270: 0x24060064  addiu       $a2, $zero, 0x64
    ctx->pc = 0x17a270u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x17a274: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a274u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a278: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a278u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a27c: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A27Cu;
    SET_GPR_U32(ctx, 31, 0x17A284u);
    ctx->pc = 0x17A280u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A27Cu;
            // 0x17a280: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A284u; }
        if (ctx->pc != 0x17A284u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A284u; }
        if (ctx->pc != 0x17A284u) { return; }
    }
    ctx->pc = 0x17A284u;
    // 0x17a284: 0x0  nop
    ctx->pc = 0x17a284u;
    // NOP
label_17a288:
    // 0x17a288: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a288u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a28c: 0x24020019  addiu       $v0, $zero, 0x19
    ctx->pc = 0x17a28cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 25));
    // 0x17a290: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a290u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a294: 0x0  nop
    ctx->pc = 0x17a294u;
    // NOP
    // 0x17a298: 0x0  nop
    ctx->pc = 0x17a298u;
    // NOP
    // 0x17a29c: 0x1010  mfhi        $v0
    ctx->pc = 0x17a29cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a2a0: 0x144000d3  bnez        $v0, . + 4 + (0xD3 << 2)
    ctx->pc = 0x17A2A0u;
    {
        const bool branch_taken_0x17a2a0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a2a0) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x17A2A8u;
    // 0x17a2a8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a2a8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a2ac: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a2acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a2b0: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x17a2b0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x17a2b4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A2B4u;
    SET_GPR_U32(ctx, 31, 0x17A2BCu);
    ctx->pc = 0x17A2B8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A2B4u;
            // 0x17a2b8: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A2BCu; }
        if (ctx->pc != 0x17A2BCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A2BCu; }
        if (ctx->pc != 0x17A2BCu) { return; }
    }
    ctx->pc = 0x17A2BCu;
    // 0x17a2bc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a2bcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a2c0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a2c0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a2c4: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x17a2c4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x17a2c8: 0xc06560c  jal         func_195830
    ctx->pc = 0x17A2C8u;
    SET_GPR_U32(ctx, 31, 0x17A2D0u);
    ctx->pc = 0x17A2CCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A2C8u;
            // 0x17a2cc: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A2D0u; }
        if (ctx->pc != 0x17A2D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A2D0u; }
        if (ctx->pc != 0x17A2D0u) { return; }
    }
    ctx->pc = 0x17A2D0u;
    // 0x17a2d0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a2d0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a2d4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a2d4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a2d8: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x17a2d8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x17a2dc: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A2DCu;
    SET_GPR_U32(ctx, 31, 0x17A2E4u);
    ctx->pc = 0x17A2E0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A2DCu;
            // 0x17a2e0: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A2E4u; }
        if (ctx->pc != 0x17A2E4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A2E4u; }
        if (ctx->pc != 0x17A2E4u) { return; }
    }
    ctx->pc = 0x17A2E4u;
    // 0x17a2e4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a2e4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a2e8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a2e8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a2ec: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x17a2ecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x17a2f0: 0xc06560c  jal         func_195830
    ctx->pc = 0x17A2F0u;
    SET_GPR_U32(ctx, 31, 0x17A2F8u);
    ctx->pc = 0x17A2F4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A2F0u;
            // 0x17a2f4: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A2F8u; }
        if (ctx->pc != 0x17A2F8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A2F8u; }
        if (ctx->pc != 0x17A2F8u) { return; }
    }
    ctx->pc = 0x17A2F8u;
    // 0x17a2f8: 0x100000bd  b           . + 4 + (0xBD << 2)
    ctx->pc = 0x17A2F8u;
    {
        const bool branch_taken_0x17a2f8 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17a2f8) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x17A300u;
label_17a300:
    // 0x17a300: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a300u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a304: 0x240200b4  addiu       $v0, $zero, 0xB4
    ctx->pc = 0x17a304u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 180));
    // 0x17a308: 0x24630014  addiu       $v1, $v1, 0x14
    ctx->pc = 0x17a308u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 20));
    // 0x17a30c: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a30cu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a310: 0x0  nop
    ctx->pc = 0x17a310u;
    // NOP
    // 0x17a314: 0x0  nop
    ctx->pc = 0x17a314u;
    // NOP
    // 0x17a318: 0x1010  mfhi        $v0
    ctx->pc = 0x17a318u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a31c: 0x14400034  bnez        $v0, . + 4 + (0x34 << 2)
    ctx->pc = 0x17A31Cu;
    {
        const bool branch_taken_0x17a31c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a31c) {
            ctx->pc = 0x17A3F0u;
            goto label_17a3f0;
        }
    }
    ctx->pc = 0x17A324u;
    // 0x17a324: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a324u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a328: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a328u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a32c: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17a32cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17a330: 0x24420010  addiu       $v0, $v0, 0x10
    ctx->pc = 0x17a330u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 16));
    // 0x17a334: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a334u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a338: 0x0  nop
    ctx->pc = 0x17a338u;
    // NOP
    // 0x17a33c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a33cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a340: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A340u;
    SET_GPR_U32(ctx, 31, 0x17A348u);
    ctx->pc = 0x17A344u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A340u;
            // 0x17a344: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A348u; }
        if (ctx->pc != 0x17A348u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A348u; }
        if (ctx->pc != 0x17A348u) { return; }
    }
    ctx->pc = 0x17A348u;
    // 0x17a348: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a348u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a34c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a34cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a350: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17a350u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17a354: 0x2442fff0  addiu       $v0, $v0, -0x10
    ctx->pc = 0x17a354u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x17a358: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a358u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a35c: 0x0  nop
    ctx->pc = 0x17a35cu;
    // NOP
    // 0x17a360: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a360u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a364: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A364u;
    SET_GPR_U32(ctx, 31, 0x17A36Cu);
    ctx->pc = 0x17A368u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A364u;
            // 0x17a368: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A36Cu; }
        if (ctx->pc != 0x17A36Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A36Cu; }
        if (ctx->pc != 0x17A36Cu) { return; }
    }
    ctx->pc = 0x17A36Cu;
    // 0x17a36c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a36cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a370: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x17a370u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a374: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A374u;
    SET_GPR_U32(ctx, 31, 0x17A37Cu);
    ctx->pc = 0x17A378u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A374u;
            // 0x17a378: 0x2445fff0  addiu       $a1, $v0, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A37Cu; }
        if (ctx->pc != 0x17A37Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A37Cu; }
        if (ctx->pc != 0x17A37Cu) { return; }
    }
    ctx->pc = 0x17A37Cu;
    // 0x17a37c: 0x8fa30038  lw          $v1, 0x38($sp)
    ctx->pc = 0x17a37cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a380: 0x3c024090  lui         $v0, 0x4090
    ctx->pc = 0x17a380u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16528 << 16));
    // 0x17a384: 0x8fa4003c  lw          $a0, 0x3C($sp)
    ctx->pc = 0x17a384u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a388: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17a388u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17a38c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a38cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a390: 0xc065480  jal         func_195200
    ctx->pc = 0x17A390u;
    SET_GPR_U32(ctx, 31, 0x17A398u);
    ctx->pc = 0x17A394u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A390u;
            // 0x17a394: 0x2465fff0  addiu       $a1, $v1, -0x10 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967280));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A398u; }
        if (ctx->pc != 0x17A398u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A398u; }
        if (ctx->pc != 0x17A398u) { return; }
    }
    ctx->pc = 0x17A398u;
    // 0x17a398: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a398u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a39c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a39cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a3a0: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x17a3a0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x17a3a4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A3A4u;
    SET_GPR_U32(ctx, 31, 0x17A3ACu);
    ctx->pc = 0x17A3A8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A3A4u;
            // 0x17a3a8: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A3ACu; }
        if (ctx->pc != 0x17A3ACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A3ACu; }
        if (ctx->pc != 0x17A3ACu) { return; }
    }
    ctx->pc = 0x17A3ACu;
    // 0x17a3ac: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a3acu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a3b0: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a3b0u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a3b4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a3b4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a3b8: 0x2464fffc  addiu       $a0, $v1, -0x4
    ctx->pc = 0x17a3b8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x17a3bc: 0xc065508  jal         func_195420
    ctx->pc = 0x17A3BCu;
    SET_GPR_U32(ctx, 31, 0x17A3C4u);
    ctx->pc = 0x17A3C0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A3BCu;
            // 0x17a3c0: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A3C4u; }
        if (ctx->pc != 0x17A3C4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A3C4u; }
        if (ctx->pc != 0x17A3C4u) { return; }
    }
    ctx->pc = 0x17A3C4u;
    // 0x17a3c4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a3c4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a3c8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a3c8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a3cc: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x17a3ccu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x17a3d0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A3D0u;
    SET_GPR_U32(ctx, 31, 0x17A3D8u);
    ctx->pc = 0x17A3D4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A3D0u;
            // 0x17a3d4: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A3D8u; }
        if (ctx->pc != 0x17A3D8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A3D8u; }
        if (ctx->pc != 0x17A3D8u) { return; }
    }
    ctx->pc = 0x17A3D8u;
    // 0x17a3d8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a3d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a3dc: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a3dcu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a3e0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a3e0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a3e4: 0x24640004  addiu       $a0, $v1, 0x4
    ctx->pc = 0x17a3e4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4));
    // 0x17a3e8: 0xc065508  jal         func_195420
    ctx->pc = 0x17A3E8u;
    SET_GPR_U32(ctx, 31, 0x17A3F0u);
    ctx->pc = 0x17A3ECu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A3E8u;
            // 0x17a3ec: 0x2445fff8  addiu       $a1, $v0, -0x8 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A3F0u; }
        if (ctx->pc != 0x17A3F0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A3F0u; }
        if (ctx->pc != 0x17A3F0u) { return; }
    }
    ctx->pc = 0x17A3F0u;
label_17a3f0:
    // 0x17a3f0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a3f0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a3f4: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x17a3f4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x17a3f8: 0x2463000f  addiu       $v1, $v1, 0xF
    ctx->pc = 0x17a3f8u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 15));
    // 0x17a3fc: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a3fcu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a400: 0x0  nop
    ctx->pc = 0x17a400u;
    // NOP
    // 0x17a404: 0x0  nop
    ctx->pc = 0x17a404u;
    // NOP
    // 0x17a408: 0x1010  mfhi        $v0
    ctx->pc = 0x17a408u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a40c: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x17A40Cu;
    {
        const bool branch_taken_0x17a40c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a40c) {
            ctx->pc = 0x17A4B8u;
            goto label_17a4b8;
        }
    }
    ctx->pc = 0x17A414u;
    // 0x17a414: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a414u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a418: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a418u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a41c: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17a41cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17a420: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17a420u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17a424: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a424u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a428: 0x0  nop
    ctx->pc = 0x17a428u;
    // NOP
    // 0x17a42c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a42cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a430: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A430u;
    SET_GPR_U32(ctx, 31, 0x17A438u);
    ctx->pc = 0x17A434u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A430u;
            // 0x17a434: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A438u; }
        if (ctx->pc != 0x17A438u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A438u; }
        if (ctx->pc != 0x17A438u) { return; }
    }
    ctx->pc = 0x17A438u;
    // 0x17a438: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a438u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a43c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a43cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a440: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17a440u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17a444: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17a444u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17a448: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a448u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a44c: 0x0  nop
    ctx->pc = 0x17a44cu;
    // NOP
    // 0x17a450: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a450u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a454: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A454u;
    SET_GPR_U32(ctx, 31, 0x17A45Cu);
    ctx->pc = 0x17A458u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A454u;
            // 0x17a458: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A45Cu; }
        if (ctx->pc != 0x17A45Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A45Cu; }
        if (ctx->pc != 0x17A45Cu) { return; }
    }
    ctx->pc = 0x17A45Cu;
    // 0x17a45c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a45cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a460: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a460u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a464: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a464u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a468: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A468u;
    SET_GPR_U32(ctx, 31, 0x17A470u);
    ctx->pc = 0x17A46Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A468u;
            // 0x17a46c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A470u; }
        if (ctx->pc != 0x17A470u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A470u; }
        if (ctx->pc != 0x17A470u) { return; }
    }
    ctx->pc = 0x17A470u;
    // 0x17a470: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a470u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a474: 0x2406000a  addiu       $a2, $zero, 0xA
    ctx->pc = 0x17a474u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 10));
    // 0x17a478: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a478u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a47c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a47cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a480: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A480u;
    SET_GPR_U32(ctx, 31, 0x17A488u);
    ctx->pc = 0x17A484u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A480u;
            // 0x17a484: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A488u; }
        if (ctx->pc != 0x17A488u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A488u; }
        if (ctx->pc != 0x17A488u) { return; }
    }
    ctx->pc = 0x17A488u;
    // 0x17a488: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a488u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a48c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a48cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a490: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a490u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a494: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A494u;
    SET_GPR_U32(ctx, 31, 0x17A49Cu);
    ctx->pc = 0x17A498u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A494u;
            // 0x17a498: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A49Cu; }
        if (ctx->pc != 0x17A49Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A49Cu; }
        if (ctx->pc != 0x17A49Cu) { return; }
    }
    ctx->pc = 0x17A49Cu;
    // 0x17a49c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a49cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a4a0: 0x2406006e  addiu       $a2, $zero, 0x6E
    ctx->pc = 0x17a4a0u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 110));
    // 0x17a4a4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a4a4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a4a8: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a4a8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a4ac: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A4ACu;
    SET_GPR_U32(ctx, 31, 0x17A4B4u);
    ctx->pc = 0x17A4B0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A4ACu;
            // 0x17a4b0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A4B4u; }
        if (ctx->pc != 0x17A4B4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A4B4u; }
        if (ctx->pc != 0x17A4B4u) { return; }
    }
    ctx->pc = 0x17A4B4u;
    // 0x17a4b4: 0x0  nop
    ctx->pc = 0x17a4b4u;
    // NOP
label_17a4b8:
    // 0x17a4b8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a4b8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a4bc: 0x24020064  addiu       $v0, $zero, 0x64
    ctx->pc = 0x17a4bcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x17a4c0: 0x24630005  addiu       $v1, $v1, 0x5
    ctx->pc = 0x17a4c0u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 5));
    // 0x17a4c4: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a4c4u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a4c8: 0x0  nop
    ctx->pc = 0x17a4c8u;
    // NOP
    // 0x17a4cc: 0x0  nop
    ctx->pc = 0x17a4ccu;
    // NOP
    // 0x17a4d0: 0x1010  mfhi        $v0
    ctx->pc = 0x17a4d0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a4d4: 0x1440002a  bnez        $v0, . + 4 + (0x2A << 2)
    ctx->pc = 0x17A4D4u;
    {
        const bool branch_taken_0x17a4d4 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a4d4) {
            ctx->pc = 0x17A580u;
            goto label_17a580;
        }
    }
    ctx->pc = 0x17A4DCu;
    // 0x17a4dc: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a4dcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a4e0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a4e0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a4e4: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17a4e4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17a4e8: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17a4e8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17a4ec: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a4ecu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a4f0: 0x0  nop
    ctx->pc = 0x17a4f0u;
    // NOP
    // 0x17a4f4: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a4f4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a4f8: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A4F8u;
    SET_GPR_U32(ctx, 31, 0x17A500u);
    ctx->pc = 0x17A4FCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A4F8u;
            // 0x17a4fc: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A500u; }
        if (ctx->pc != 0x17A500u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A500u; }
        if (ctx->pc != 0x17A500u) { return; }
    }
    ctx->pc = 0x17A500u;
    // 0x17a500: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a500u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a504: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a504u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a508: 0x24040037  addiu       $a0, $zero, 0x37
    ctx->pc = 0x17a508u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 55));
    // 0x17a50c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17a50cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17a510: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a510u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a514: 0x0  nop
    ctx->pc = 0x17a514u;
    // NOP
    // 0x17a518: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a518u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a51c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A51Cu;
    SET_GPR_U32(ctx, 31, 0x17A524u);
    ctx->pc = 0x17A520u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A51Cu;
            // 0x17a520: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A524u; }
        if (ctx->pc != 0x17A524u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A524u; }
        if (ctx->pc != 0x17A524u) { return; }
    }
    ctx->pc = 0x17A524u;
    // 0x17a524: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a524u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a528: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a528u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a52c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a52cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a530: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A530u;
    SET_GPR_U32(ctx, 31, 0x17A538u);
    ctx->pc = 0x17A534u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A530u;
            // 0x17a534: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A538u; }
        if (ctx->pc != 0x17A538u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A538u; }
        if (ctx->pc != 0x17A538u) { return; }
    }
    ctx->pc = 0x17A538u;
    // 0x17a538: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a538u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a53c: 0x24060014  addiu       $a2, $zero, 0x14
    ctx->pc = 0x17a53cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 20));
    // 0x17a540: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a540u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a544: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a544u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a548: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A548u;
    SET_GPR_U32(ctx, 31, 0x17A550u);
    ctx->pc = 0x17A54Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A548u;
            // 0x17a54c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A550u; }
        if (ctx->pc != 0x17A550u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A550u; }
        if (ctx->pc != 0x17A550u) { return; }
    }
    ctx->pc = 0x17A550u;
    // 0x17a550: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a550u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a554: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a554u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a558: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a558u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a55c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A55Cu;
    SET_GPR_U32(ctx, 31, 0x17A564u);
    ctx->pc = 0x17A560u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A55Cu;
            // 0x17a560: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A564u; }
        if (ctx->pc != 0x17A564u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A564u; }
        if (ctx->pc != 0x17A564u) { return; }
    }
    ctx->pc = 0x17A564u;
    // 0x17a564: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a564u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a568: 0x24060064  addiu       $a2, $zero, 0x64
    ctx->pc = 0x17a568u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x17a56c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a56cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a570: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a570u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a574: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A574u;
    SET_GPR_U32(ctx, 31, 0x17A57Cu);
    ctx->pc = 0x17A578u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A574u;
            // 0x17a578: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A57Cu; }
        if (ctx->pc != 0x17A57Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A57Cu; }
        if (ctx->pc != 0x17A57Cu) { return; }
    }
    ctx->pc = 0x17A57Cu;
    // 0x17a57c: 0x0  nop
    ctx->pc = 0x17a57cu;
    // NOP
label_17a580:
    // 0x17a580: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a580u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a584: 0x24020032  addiu       $v0, $zero, 0x32
    ctx->pc = 0x17a584u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 50));
    // 0x17a588: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a588u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a58c: 0x0  nop
    ctx->pc = 0x17a58cu;
    // NOP
    // 0x17a590: 0x0  nop
    ctx->pc = 0x17a590u;
    // NOP
    // 0x17a594: 0x1010  mfhi        $v0
    ctx->pc = 0x17a594u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a598: 0x14400015  bnez        $v0, . + 4 + (0x15 << 2)
    ctx->pc = 0x17A598u;
    {
        const bool branch_taken_0x17a598 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a598) {
            ctx->pc = 0x17A5F0u;
            goto label_17a5f0;
        }
    }
    ctx->pc = 0x17A5A0u;
    // 0x17a5a0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a5a0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a5a4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a5a4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a5a8: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x17a5a8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x17a5ac: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A5ACu;
    SET_GPR_U32(ctx, 31, 0x17A5B4u);
    ctx->pc = 0x17A5B0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A5ACu;
            // 0x17a5b0: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A5B4u; }
        if (ctx->pc != 0x17A5B4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A5B4u; }
        if (ctx->pc != 0x17A5B4u) { return; }
    }
    ctx->pc = 0x17A5B4u;
    // 0x17a5b4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a5b4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a5b8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a5b8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a5bc: 0x2464ff9e  addiu       $a0, $v1, -0x62
    ctx->pc = 0x17a5bcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967198));
    // 0x17a5c0: 0xc06560c  jal         func_195830
    ctx->pc = 0x17A5C0u;
    SET_GPR_U32(ctx, 31, 0x17A5C8u);
    ctx->pc = 0x17A5C4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A5C0u;
            // 0x17a5c4: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A5C8u; }
        if (ctx->pc != 0x17A5C8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A5C8u; }
        if (ctx->pc != 0x17A5C8u) { return; }
    }
    ctx->pc = 0x17A5C8u;
    // 0x17a5c8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a5c8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a5cc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a5ccu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a5d0: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x17a5d0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x17a5d4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A5D4u;
    SET_GPR_U32(ctx, 31, 0x17A5DCu);
    ctx->pc = 0x17A5D8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A5D4u;
            // 0x17a5d8: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A5DCu; }
        if (ctx->pc != 0x17A5DCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A5DCu; }
        if (ctx->pc != 0x17A5DCu) { return; }
    }
    ctx->pc = 0x17A5DCu;
    // 0x17a5dc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a5dcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a5e0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a5e0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a5e4: 0x24640062  addiu       $a0, $v1, 0x62
    ctx->pc = 0x17a5e4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 98));
    // 0x17a5e8: 0xc06560c  jal         func_195830
    ctx->pc = 0x17A5E8u;
    SET_GPR_U32(ctx, 31, 0x17A5F0u);
    ctx->pc = 0x17A5ECu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A5E8u;
            // 0x17a5ec: 0x2445ffa2  addiu       $a1, $v0, -0x5E (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967202));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195830u;
    if (runtime->hasFunction(0x195830u)) {
        auto targetFn = runtime->lookupFunction(0x195830u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A5F0u; }
        if (ctx->pc != 0x17A5F0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Nerai_0x195830(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A5F0u; }
        if (ctx->pc != 0x17A5F0u) { return; }
    }
    ctx->pc = 0x17A5F0u;
label_17a5f0:
    // 0x17a5f0: 0x8e220024  lw          $v0, 0x24($s1)
    ctx->pc = 0x17a5f0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a5f4: 0x28410259  slti        $at, $v0, 0x259
    ctx->pc = 0x17a5f4u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)601) ? 1 : 0);
    // 0x17a5f8: 0x14200825  bnez        $at, . + 4 + (0x825 << 2)
    ctx->pc = 0x17A5F8u;
    {
        const bool branch_taken_0x17a5f8 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a5f8) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A600u;
    // 0x17a600: 0xae200024  sw          $zero, 0x24($s1)
    ctx->pc = 0x17a600u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
    // 0x17a604: 0x24020004  addiu       $v0, $zero, 0x4
    ctx->pc = 0x17a604u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 4));
    // 0x17a608: 0xae2000d0  sw          $zero, 0xD0($s1)
    ctx->pc = 0x17a608u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 208), GPR_U32(ctx, 0));
    // 0x17a60c: 0xae2000d4  sw          $zero, 0xD4($s1)
    ctx->pc = 0x17a60cu;
    WRITE32(ADD32(GPR_U32(ctx, 17), 212), GPR_U32(ctx, 0));
    // 0x17a610: 0x1000081f  b           . + 4 + (0x81F << 2)
    ctx->pc = 0x17A610u;
    {
        const bool branch_taken_0x17a610 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x17A614u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17A610u;
            // 0x17a614: 0xae220028  sw          $v0, 0x28($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 2));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17a610) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A618u;
label_17a618:
    // 0x17a618: 0x8e220024  lw          $v0, 0x24($s1)
    ctx->pc = 0x17a618u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a61c: 0x28410079  slti        $at, $v0, 0x79
    ctx->pc = 0x17a61cu;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)121) ? 1 : 0);
    // 0x17a620: 0x1420081b  bnez        $at, . + 4 + (0x81B << 2)
    ctx->pc = 0x17A620u;
    {
        const bool branch_taken_0x17a620 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a620) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A628u;
    // 0x17a628: 0xae200024  sw          $zero, 0x24($s1)
    ctx->pc = 0x17a628u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
    // 0x17a62c: 0x24020005  addiu       $v0, $zero, 0x5
    ctx->pc = 0x17a62cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 5));
    // 0x17a630: 0xae220028  sw          $v0, 0x28($s1)
    ctx->pc = 0x17a630u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 2));
    // 0x17a634: 0xc05b994  jal         func_16E650
    ctx->pc = 0x17A634u;
    SET_GPR_U32(ctx, 31, 0x17A63Cu);
    ctx->pc = 0x17A638u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A634u;
            // 0x17a638: 0x220202d  daddu       $a0, $s1, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x16E650u;
    if (runtime->hasFunction(0x16E650u)) {
        auto targetFn = runtime->lookupFunction(0x16E650u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A63Cu; }
        if (ctx->pc != 0x17A63Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Enemy_BloadCast_Child_DeadEnd_0x16e650(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A63Cu; }
        if (ctx->pc != 0x17A63Cu) { return; }
    }
    ctx->pc = 0x17A63Cu;
    // 0x17a63c: 0x10000814  b           . + 4 + (0x814 << 2)
    ctx->pc = 0x17A63Cu;
    {
        const bool branch_taken_0x17a63c = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x17A640u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17A63Cu;
            // 0x17a640: 0xae220110  sw          $v0, 0x110($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 272), GPR_U32(ctx, 2));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17a63c) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A644u;
    // 0x17a644: 0x0  nop
    ctx->pc = 0x17a644u;
    // NOP
label_17a648:
    // 0x17a648: 0x8e220024  lw          $v0, 0x24($s1)
    ctx->pc = 0x17a648u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a64c: 0x284100b5  slti        $at, $v0, 0xB5
    ctx->pc = 0x17a64cu;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)181) ? 1 : 0);
    // 0x17a650: 0x14200007  bnez        $at, . + 4 + (0x7 << 2)
    ctx->pc = 0x17A650u;
    {
        const bool branch_taken_0x17a650 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a650) {
            ctx->pc = 0x17A670u;
            goto label_17a670;
        }
    }
    ctx->pc = 0x17A658u;
    // 0x17a658: 0xae200024  sw          $zero, 0x24($s1)
    ctx->pc = 0x17a658u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
    // 0x17a65c: 0x24020003  addiu       $v0, $zero, 0x3
    ctx->pc = 0x17a65cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
    // 0x17a660: 0xae220028  sw          $v0, 0x28($s1)
    ctx->pc = 0x17a660u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 2));
    // 0x17a664: 0xc05f2f8  jal         func_17CBE0
    ctx->pc = 0x17A664u;
    SET_GPR_U32(ctx, 31, 0x17A66Cu);
    ctx->pc = 0x17A668u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A664u;
            // 0x17a668: 0x220202d  daddu       $a0, $s1, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x17CBE0u;
    if (runtime->hasFunction(0x17CBE0u)) {
        auto targetFn = runtime->lookupFunction(0x17CBE0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A66Cu; }
        if (ctx->pc != 0x17A66Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        BossAddingVector_0x17cbe0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A66Cu; }
        if (ctx->pc != 0x17A66Cu) { return; }
    }
    ctx->pc = 0x17A66Cu;
    // 0x17a66c: 0x0  nop
    ctx->pc = 0x17a66cu;
    // NOP
label_17a670:
    // 0x17a670: 0x8e220000  lw          $v0, 0x0($s1)
    ctx->pc = 0x17a670u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17a674: 0x27a4003c  addiu       $a0, $sp, 0x3C
    ctx->pc = 0x17a674u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 29), 60));
    // 0x17a678: 0xc44c0120  lwc1        $f12, 0x120($v0)
    ctx->pc = 0x17a678u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 288)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[12] = f; }
    // 0x17a67c: 0xc44d0124  lwc1        $f13, 0x124($v0)
    ctx->pc = 0x17a67cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 292)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[13] = f; }
    // 0x17a680: 0xc05f3cc  jal         func_17CF30
    ctx->pc = 0x17A680u;
    SET_GPR_U32(ctx, 31, 0x17A688u);
    ctx->pc = 0x17A684u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A680u;
            // 0x17a684: 0x27a50038  addiu       $a1, $sp, 0x38 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 29), 56));
        ctx->in_delay_slot = false;
    ctx->pc = 0x17CF30u;
    if (runtime->hasFunction(0x17CF30u)) {
        auto targetFn = runtime->lookupFunction(0x17CF30u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A688u; }
        if (ctx->pc != 0x17A688u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Trans3Dto2D_0x17cf30(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A688u; }
        if (ctx->pc != 0x17A688u) { return; }
    }
    ctx->pc = 0x17A688u;
    // 0x17a688: 0x8e230110  lw          $v1, 0x110($s1)
    ctx->pc = 0x17a688u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x17a68c: 0x24020004  addiu       $v0, $zero, 0x4
    ctx->pc = 0x17a68cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 4));
    // 0x17a690: 0x10620465  beq         $v1, $v0, . + 4 + (0x465 << 2)
    ctx->pc = 0x17A690u;
    {
        const bool branch_taken_0x17a690 = (GPR_U64(ctx, 3) == GPR_U64(ctx, 2));
        ctx->pc = 0x17A694u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17A690u;
            // 0x17a694: 0x24020003  addiu       $v0, $zero, 0x3 (Delay Slot)
        SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17a690) {
            ctx->pc = 0x17B828u;
            goto label_17b828;
        }
    }
    ctx->pc = 0x17A698u;
    // 0x17a698: 0x106202a3  beq         $v1, $v0, . + 4 + (0x2A3 << 2)
    ctx->pc = 0x17A698u;
    {
        const bool branch_taken_0x17a698 = (GPR_U64(ctx, 3) == GPR_U64(ctx, 2));
        if (branch_taken_0x17a698) {
            ctx->pc = 0x17B128u;
            goto label_17b128;
        }
    }
    ctx->pc = 0x17A6A0u;
    // 0x17a6a0: 0x24020002  addiu       $v0, $zero, 0x2
    ctx->pc = 0x17a6a0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 2));
    // 0x17a6a4: 0x10620118  beq         $v1, $v0, . + 4 + (0x118 << 2)
    ctx->pc = 0x17A6A4u;
    {
        const bool branch_taken_0x17a6a4 = (GPR_U64(ctx, 3) == GPR_U64(ctx, 2));
        ctx->pc = 0x17A6A8u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17A6A4u;
            // 0x17a6a8: 0x24020001  addiu       $v0, $zero, 0x1 (Delay Slot)
        SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17a6a4) {
            ctx->pc = 0x17AB08u;
            goto label_17ab08;
        }
    }
    ctx->pc = 0x17A6ACu;
    // 0x17a6ac: 0x10620082  beq         $v1, $v0, . + 4 + (0x82 << 2)
    ctx->pc = 0x17A6ACu;
    {
        const bool branch_taken_0x17a6ac = (GPR_U64(ctx, 3) == GPR_U64(ctx, 2));
        if (branch_taken_0x17a6ac) {
            ctx->pc = 0x17A8B8u;
            goto label_17a8b8;
        }
    }
    ctx->pc = 0x17A6B4u;
    // 0x17a6b4: 0x10600004  beqz        $v1, . + 4 + (0x4 << 2)
    ctx->pc = 0x17A6B4u;
    {
        const bool branch_taken_0x17a6b4 = (GPR_U64(ctx, 3) == GPR_U64(ctx, 0));
        if (branch_taken_0x17a6b4) {
            ctx->pc = 0x17A6C8u;
            goto label_17a6c8;
        }
    }
    ctx->pc = 0x17A6BCu;
    // 0x17a6bc: 0x100007f4  b           . + 4 + (0x7F4 << 2)
    ctx->pc = 0x17A6BCu;
    {
        const bool branch_taken_0x17a6bc = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17a6bc) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A6C4u;
    // 0x17a6c4: 0x0  nop
    ctx->pc = 0x17a6c4u;
    // NOP
label_17a6c8:
    // 0x17a6c8: 0xc065d00  jal         func_197400
    ctx->pc = 0x17A6C8u;
    SET_GPR_U32(ctx, 31, 0x17A6D0u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A6D0u; }
        if (ctx->pc != 0x17A6D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A6D0u; }
        if (ctx->pc != 0x17A6D0u) { return; }
    }
    ctx->pc = 0x17A6D0u;
    // 0x17a6d0: 0x28410002  slti        $at, $v0, 0x2
    ctx->pc = 0x17a6d0u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)2) ? 1 : 0);
    // 0x17a6d4: 0x14200034  bnez        $at, . + 4 + (0x34 << 2)
    ctx->pc = 0x17A6D4u;
    {
        const bool branch_taken_0x17a6d4 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a6d4) {
            ctx->pc = 0x17A7A8u;
            goto label_17a7a8;
        }
    }
    ctx->pc = 0x17A6DCu;
    // 0x17a6dc: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a6dcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a6e0: 0x24020014  addiu       $v0, $zero, 0x14
    ctx->pc = 0x17a6e0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 20));
    // 0x17a6e4: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a6e4u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a6e8: 0x0  nop
    ctx->pc = 0x17a6e8u;
    // NOP
    // 0x17a6ec: 0x0  nop
    ctx->pc = 0x17a6ecu;
    // NOP
    // 0x17a6f0: 0x1010  mfhi        $v0
    ctx->pc = 0x17a6f0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a6f4: 0x144007e6  bnez        $v0, . + 4 + (0x7E6 << 2)
    ctx->pc = 0x17A6F4u;
    {
        const bool branch_taken_0x17a6f4 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a6f4) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A6FCu;
    // 0x17a6fc: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a6fcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a700: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a700u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a704: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17a704u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17a708: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17a708u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17a70c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a70cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a710: 0x0  nop
    ctx->pc = 0x17a710u;
    // NOP
    // 0x17a714: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a714u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a718: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A718u;
    SET_GPR_U32(ctx, 31, 0x17A720u);
    ctx->pc = 0x17A71Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A718u;
            // 0x17a71c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A720u; }
        if (ctx->pc != 0x17A720u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A720u; }
        if (ctx->pc != 0x17A720u) { return; }
    }
    ctx->pc = 0x17A720u;
    // 0x17a720: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a720u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a724: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a724u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a728: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17a728u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17a72c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17a72cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17a730: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a730u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a734: 0x0  nop
    ctx->pc = 0x17a734u;
    // NOP
    // 0x17a738: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a738u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a73c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A73Cu;
    SET_GPR_U32(ctx, 31, 0x17A744u);
    ctx->pc = 0x17A740u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A73Cu;
            // 0x17a740: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A744u; }
        if (ctx->pc != 0x17A744u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A744u; }
        if (ctx->pc != 0x17A744u) { return; }
    }
    ctx->pc = 0x17A744u;
    // 0x17a744: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a744u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a748: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a748u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a74c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a74cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a750: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A750u;
    SET_GPR_U32(ctx, 31, 0x17A758u);
    ctx->pc = 0x17A754u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A750u;
            // 0x17a754: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A758u; }
        if (ctx->pc != 0x17A758u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A758u; }
        if (ctx->pc != 0x17A758u) { return; }
    }
    ctx->pc = 0x17A758u;
    // 0x17a758: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a758u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a75c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a75cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a760: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a760u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a764: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a764u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a768: 0xc065508  jal         func_195420
    ctx->pc = 0x17A768u;
    SET_GPR_U32(ctx, 31, 0x17A770u);
    ctx->pc = 0x17A76Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A768u;
            // 0x17a76c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A770u; }
        if (ctx->pc != 0x17A770u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A770u; }
        if (ctx->pc != 0x17A770u) { return; }
    }
    ctx->pc = 0x17A770u;
    // 0x17a770: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a770u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a774: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a774u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a778: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a778u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a77c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A77Cu;
    SET_GPR_U32(ctx, 31, 0x17A784u);
    ctx->pc = 0x17A780u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A77Cu;
            // 0x17a780: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A784u; }
        if (ctx->pc != 0x17A784u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A784u; }
        if (ctx->pc != 0x17A784u) { return; }
    }
    ctx->pc = 0x17A784u;
    // 0x17a784: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a784u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a788: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a788u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a78c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a78cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a790: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a790u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a794: 0xc065508  jal         func_195420
    ctx->pc = 0x17A794u;
    SET_GPR_U32(ctx, 31, 0x17A79Cu);
    ctx->pc = 0x17A798u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A794u;
            // 0x17a798: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A79Cu; }
        if (ctx->pc != 0x17A79Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A79Cu; }
        if (ctx->pc != 0x17A79Cu) { return; }
    }
    ctx->pc = 0x17A79Cu;
    // 0x17a79c: 0x100007bc  b           . + 4 + (0x7BC << 2)
    ctx->pc = 0x17A79Cu;
    {
        const bool branch_taken_0x17a79c = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17a79c) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A7A4u;
    // 0x17a7a4: 0x0  nop
    ctx->pc = 0x17a7a4u;
    // NOP
label_17a7a8:
    // 0x17a7a8: 0xc065d00  jal         func_197400
    ctx->pc = 0x17A7A8u;
    SET_GPR_U32(ctx, 31, 0x17A7B0u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A7B0u; }
        if (ctx->pc != 0x17A7B0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A7B0u; }
        if (ctx->pc != 0x17A7B0u) { return; }
    }
    ctx->pc = 0x17A7B0u;
    // 0x17a7b0: 0x18400021  blez        $v0, . + 4 + (0x21 << 2)
    ctx->pc = 0x17A7B0u;
    {
        const bool branch_taken_0x17a7b0 = (GPR_S32(ctx, 2) <= 0);
        if (branch_taken_0x17a7b0) {
            ctx->pc = 0x17A838u;
            goto label_17a838;
        }
    }
    ctx->pc = 0x17A7B8u;
    // 0x17a7b8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a7b8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a7bc: 0x24020028  addiu       $v0, $zero, 0x28
    ctx->pc = 0x17a7bcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 40));
    // 0x17a7c0: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a7c0u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a7c4: 0x0  nop
    ctx->pc = 0x17a7c4u;
    // NOP
    // 0x17a7c8: 0x0  nop
    ctx->pc = 0x17a7c8u;
    // NOP
    // 0x17a7cc: 0x1010  mfhi        $v0
    ctx->pc = 0x17a7ccu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a7d0: 0x144007af  bnez        $v0, . + 4 + (0x7AF << 2)
    ctx->pc = 0x17A7D0u;
    {
        const bool branch_taken_0x17a7d0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a7d0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A7D8u;
    // 0x17a7d8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a7d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a7dc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a7dcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a7e0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a7e0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a7e4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A7E4u;
    SET_GPR_U32(ctx, 31, 0x17A7ECu);
    ctx->pc = 0x17A7E8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A7E4u;
            // 0x17a7e8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A7ECu; }
        if (ctx->pc != 0x17A7ECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A7ECu; }
        if (ctx->pc != 0x17A7ECu) { return; }
    }
    ctx->pc = 0x17A7ECu;
    // 0x17a7ec: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a7ecu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a7f0: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a7f0u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a7f4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a7f4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a7f8: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a7f8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a7fc: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A7FCu;
    SET_GPR_U32(ctx, 31, 0x17A804u);
    ctx->pc = 0x17A800u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A7FCu;
            // 0x17a800: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A804u; }
        if (ctx->pc != 0x17A804u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A804u; }
        if (ctx->pc != 0x17A804u) { return; }
    }
    ctx->pc = 0x17A804u;
    // 0x17a804: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a804u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a808: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a808u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a80c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a80cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a810: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A810u;
    SET_GPR_U32(ctx, 31, 0x17A818u);
    ctx->pc = 0x17A814u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A810u;
            // 0x17a814: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A818u; }
        if (ctx->pc != 0x17A818u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A818u; }
        if (ctx->pc != 0x17A818u) { return; }
    }
    ctx->pc = 0x17A818u;
    // 0x17a818: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a818u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a81c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a81cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a820: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a820u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a824: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a824u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a828: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A828u;
    SET_GPR_U32(ctx, 31, 0x17A830u);
    ctx->pc = 0x17A82Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A828u;
            // 0x17a82c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A830u; }
        if (ctx->pc != 0x17A830u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A830u; }
        if (ctx->pc != 0x17A830u) { return; }
    }
    ctx->pc = 0x17A830u;
    // 0x17a830: 0x10000797  b           . + 4 + (0x797 << 2)
    ctx->pc = 0x17A830u;
    {
        const bool branch_taken_0x17a830 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17a830) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A838u;
label_17a838:
    // 0x17a838: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a838u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a83c: 0x24020050  addiu       $v0, $zero, 0x50
    ctx->pc = 0x17a83cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 80));
    // 0x17a840: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a840u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a844: 0x0  nop
    ctx->pc = 0x17a844u;
    // NOP
    // 0x17a848: 0x0  nop
    ctx->pc = 0x17a848u;
    // NOP
    // 0x17a84c: 0x1010  mfhi        $v0
    ctx->pc = 0x17a84cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a850: 0x1440078f  bnez        $v0, . + 4 + (0x78F << 2)
    ctx->pc = 0x17A850u;
    {
        const bool branch_taken_0x17a850 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a850) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A858u;
    // 0x17a858: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a858u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a85c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a85cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a860: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a860u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a864: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A864u;
    SET_GPR_U32(ctx, 31, 0x17A86Cu);
    ctx->pc = 0x17A868u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A864u;
            // 0x17a868: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A86Cu; }
        if (ctx->pc != 0x17A86Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A86Cu; }
        if (ctx->pc != 0x17A86Cu) { return; }
    }
    ctx->pc = 0x17A86Cu;
    // 0x17a86c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a86cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a870: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a870u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a874: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a874u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a878: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a878u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a87c: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A87Cu;
    SET_GPR_U32(ctx, 31, 0x17A884u);
    ctx->pc = 0x17A880u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A87Cu;
            // 0x17a880: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A884u; }
        if (ctx->pc != 0x17A884u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A884u; }
        if (ctx->pc != 0x17A884u) { return; }
    }
    ctx->pc = 0x17A884u;
    // 0x17a884: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a884u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a888: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a888u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a88c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a88cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a890: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A890u;
    SET_GPR_U32(ctx, 31, 0x17A898u);
    ctx->pc = 0x17A894u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A890u;
            // 0x17a894: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A898u; }
        if (ctx->pc != 0x17A898u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A898u; }
        if (ctx->pc != 0x17A898u) { return; }
    }
    ctx->pc = 0x17A898u;
    // 0x17a898: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a898u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a89c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a89cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a8a0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a8a0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a8a4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a8a4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a8a8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17A8A8u;
    SET_GPR_U32(ctx, 31, 0x17A8B0u);
    ctx->pc = 0x17A8ACu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A8A8u;
            // 0x17a8ac: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A8B0u; }
        if (ctx->pc != 0x17A8B0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A8B0u; }
        if (ctx->pc != 0x17A8B0u) { return; }
    }
    ctx->pc = 0x17A8B0u;
    // 0x17a8b0: 0x10000777  b           . + 4 + (0x777 << 2)
    ctx->pc = 0x17A8B0u;
    {
        const bool branch_taken_0x17a8b0 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17a8b0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A8B8u;
label_17a8b8:
    // 0x17a8b8: 0xc065d00  jal         func_197400
    ctx->pc = 0x17A8B8u;
    SET_GPR_U32(ctx, 31, 0x17A8C0u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A8C0u; }
        if (ctx->pc != 0x17A8C0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A8C0u; }
        if (ctx->pc != 0x17A8C0u) { return; }
    }
    ctx->pc = 0x17A8C0u;
    // 0x17a8c0: 0x28410002  slti        $at, $v0, 0x2
    ctx->pc = 0x17a8c0u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)2) ? 1 : 0);
    // 0x17a8c4: 0x14200040  bnez        $at, . + 4 + (0x40 << 2)
    ctx->pc = 0x17A8C4u;
    {
        const bool branch_taken_0x17a8c4 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a8c4) {
            ctx->pc = 0x17A9C8u;
            goto label_17a9c8;
        }
    }
    ctx->pc = 0x17A8CCu;
    // 0x17a8cc: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a8ccu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a8d0: 0x2402000f  addiu       $v0, $zero, 0xF
    ctx->pc = 0x17a8d0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 15));
    // 0x17a8d4: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a8d4u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a8d8: 0x0  nop
    ctx->pc = 0x17a8d8u;
    // NOP
    // 0x17a8dc: 0x0  nop
    ctx->pc = 0x17a8dcu;
    // NOP
    // 0x17a8e0: 0x1010  mfhi        $v0
    ctx->pc = 0x17a8e0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a8e4: 0x1440076a  bnez        $v0, . + 4 + (0x76A << 2)
    ctx->pc = 0x17A8E4u;
    {
        const bool branch_taken_0x17a8e4 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a8e4) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A8ECu;
    // 0x17a8ec: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a8ecu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a8f0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a8f0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a8f4: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17a8f4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17a8f8: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17a8f8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17a8fc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a8fcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a900: 0x0  nop
    ctx->pc = 0x17a900u;
    // NOP
    // 0x17a904: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a904u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a908: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A908u;
    SET_GPR_U32(ctx, 31, 0x17A910u);
    ctx->pc = 0x17A90Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A908u;
            // 0x17a90c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A910u; }
        if (ctx->pc != 0x17A910u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A910u; }
        if (ctx->pc != 0x17A910u) { return; }
    }
    ctx->pc = 0x17A910u;
    // 0x17a910: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17a910u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a914: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17a914u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17a918: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17a918u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17a91c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17a91cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17a920: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17a920u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17a924: 0x0  nop
    ctx->pc = 0x17a924u;
    // NOP
    // 0x17a928: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17a928u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17a92c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17A92Cu;
    SET_GPR_U32(ctx, 31, 0x17A934u);
    ctx->pc = 0x17A930u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A92Cu;
            // 0x17a930: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A934u; }
        if (ctx->pc != 0x17A934u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A934u; }
        if (ctx->pc != 0x17A934u) { return; }
    }
    ctx->pc = 0x17A934u;
    // 0x17a934: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a934u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a938: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a938u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a93c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a93cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a940: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A940u;
    SET_GPR_U32(ctx, 31, 0x17A948u);
    ctx->pc = 0x17A944u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A940u;
            // 0x17a944: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A948u; }
        if (ctx->pc != 0x17A948u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A948u; }
        if (ctx->pc != 0x17A948u) { return; }
    }
    ctx->pc = 0x17A948u;
    // 0x17a948: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a948u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a94c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a94cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a950: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a950u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a954: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17A954u;
    SET_GPR_U32(ctx, 31, 0x17A95Cu);
    ctx->pc = 0x17A958u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A954u;
            // 0x17a958: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A95Cu; }
        if (ctx->pc != 0x17A95Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A95Cu; }
        if (ctx->pc != 0x17A95Cu) { return; }
    }
    ctx->pc = 0x17A95Cu;
    // 0x17a95c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a95cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a960: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a960u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a964: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a964u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a968: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a968u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a96c: 0xc065508  jal         func_195420
    ctx->pc = 0x17A96Cu;
    SET_GPR_U32(ctx, 31, 0x17A974u);
    ctx->pc = 0x17A970u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A96Cu;
            // 0x17a970: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A974u; }
        if (ctx->pc != 0x17A974u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A974u; }
        if (ctx->pc != 0x17A974u) { return; }
    }
    ctx->pc = 0x17A974u;
    // 0x17a974: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a974u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a978: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17a978u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17a97c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a97cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a980: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a980u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a984: 0xc065508  jal         func_195420
    ctx->pc = 0x17A984u;
    SET_GPR_U32(ctx, 31, 0x17A98Cu);
    ctx->pc = 0x17A988u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A984u;
            // 0x17a988: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A98Cu; }
        if (ctx->pc != 0x17A98Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A98Cu; }
        if (ctx->pc != 0x17A98Cu) { return; }
    }
    ctx->pc = 0x17A98Cu;
    // 0x17a98c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a98cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a990: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17a990u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17a994: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a994u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a998: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17a998u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17a99c: 0xc065508  jal         func_195420
    ctx->pc = 0x17A99Cu;
    SET_GPR_U32(ctx, 31, 0x17A9A4u);
    ctx->pc = 0x17A9A0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A99Cu;
            // 0x17a9a0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A9A4u; }
        if (ctx->pc != 0x17A9A4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A9A4u; }
        if (ctx->pc != 0x17A9A4u) { return; }
    }
    ctx->pc = 0x17A9A4u;
    // 0x17a9a4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a9a4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a9a8: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17a9a8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17a9ac: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a9acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17a9b0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17a9b0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17a9b4: 0xc065508  jal         func_195420
    ctx->pc = 0x17A9B4u;
    SET_GPR_U32(ctx, 31, 0x17A9BCu);
    ctx->pc = 0x17A9B8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17A9B4u;
            // 0x17a9b8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A9BCu; }
        if (ctx->pc != 0x17A9BCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A9BCu; }
        if (ctx->pc != 0x17A9BCu) { return; }
    }
    ctx->pc = 0x17A9BCu;
    // 0x17a9bc: 0x10000734  b           . + 4 + (0x734 << 2)
    ctx->pc = 0x17A9BCu;
    {
        const bool branch_taken_0x17a9bc = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17a9bc) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A9C4u;
    // 0x17a9c4: 0x0  nop
    ctx->pc = 0x17a9c4u;
    // NOP
label_17a9c8:
    // 0x17a9c8: 0xc065d00  jal         func_197400
    ctx->pc = 0x17A9C8u;
    SET_GPR_U32(ctx, 31, 0x17A9D0u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A9D0u; }
        if (ctx->pc != 0x17A9D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17A9D0u; }
        if (ctx->pc != 0x17A9D0u) { return; }
    }
    ctx->pc = 0x17A9D0u;
    // 0x17a9d0: 0x1840002d  blez        $v0, . + 4 + (0x2D << 2)
    ctx->pc = 0x17A9D0u;
    {
        const bool branch_taken_0x17a9d0 = (GPR_S32(ctx, 2) <= 0);
        if (branch_taken_0x17a9d0) {
            ctx->pc = 0x17AA88u;
            goto label_17aa88;
        }
    }
    ctx->pc = 0x17A9D8u;
    // 0x17a9d8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17a9d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17a9dc: 0x2402001e  addiu       $v0, $zero, 0x1E
    ctx->pc = 0x17a9dcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 30));
    // 0x17a9e0: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17a9e0u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17a9e4: 0x0  nop
    ctx->pc = 0x17a9e4u;
    // NOP
    // 0x17a9e8: 0x0  nop
    ctx->pc = 0x17a9e8u;
    // NOP
    // 0x17a9ec: 0x1010  mfhi        $v0
    ctx->pc = 0x17a9ecu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17a9f0: 0x14400727  bnez        $v0, . + 4 + (0x727 << 2)
    ctx->pc = 0x17A9F0u;
    {
        const bool branch_taken_0x17a9f0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17a9f0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17A9F8u;
    // 0x17a9f8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17a9f8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17a9fc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17a9fcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aa00: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17aa00u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17aa04: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17AA04u;
    SET_GPR_U32(ctx, 31, 0x17AA0Cu);
    ctx->pc = 0x17AA08u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AA04u;
            // 0x17aa08: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA0Cu; }
        if (ctx->pc != 0x17AA0Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA0Cu; }
        if (ctx->pc != 0x17AA0Cu) { return; }
    }
    ctx->pc = 0x17AA0Cu;
    // 0x17aa0c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aa0cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aa10: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aa10u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aa14: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17aa14u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17aa18: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17AA18u;
    SET_GPR_U32(ctx, 31, 0x17AA20u);
    ctx->pc = 0x17AA1Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AA18u;
            // 0x17aa1c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA20u; }
        if (ctx->pc != 0x17AA20u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA20u; }
        if (ctx->pc != 0x17AA20u) { return; }
    }
    ctx->pc = 0x17AA20u;
    // 0x17aa20: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aa20u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aa24: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17aa24u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17aa28: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aa28u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aa2c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17aa2cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17aa30: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AA30u;
    SET_GPR_U32(ctx, 31, 0x17AA38u);
    ctx->pc = 0x17AA34u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AA30u;
            // 0x17aa34: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA38u; }
        if (ctx->pc != 0x17AA38u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA38u; }
        if (ctx->pc != 0x17AA38u) { return; }
    }
    ctx->pc = 0x17AA38u;
    // 0x17aa38: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aa38u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aa3c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17aa3cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17aa40: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aa40u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aa44: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17aa44u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17aa48: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AA48u;
    SET_GPR_U32(ctx, 31, 0x17AA50u);
    ctx->pc = 0x17AA4Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AA48u;
            // 0x17aa4c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA50u; }
        if (ctx->pc != 0x17AA50u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA50u; }
        if (ctx->pc != 0x17AA50u) { return; }
    }
    ctx->pc = 0x17AA50u;
    // 0x17aa50: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aa50u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aa54: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17aa54u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17aa58: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aa58u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aa5c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17aa5cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17aa60: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AA60u;
    SET_GPR_U32(ctx, 31, 0x17AA68u);
    ctx->pc = 0x17AA64u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AA60u;
            // 0x17aa64: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA68u; }
        if (ctx->pc != 0x17AA68u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA68u; }
        if (ctx->pc != 0x17AA68u) { return; }
    }
    ctx->pc = 0x17AA68u;
    // 0x17aa68: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aa68u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aa6c: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17aa6cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17aa70: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aa70u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aa74: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17aa74u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17aa78: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AA78u;
    SET_GPR_U32(ctx, 31, 0x17AA80u);
    ctx->pc = 0x17AA7Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AA78u;
            // 0x17aa7c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA80u; }
        if (ctx->pc != 0x17AA80u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AA80u; }
        if (ctx->pc != 0x17AA80u) { return; }
    }
    ctx->pc = 0x17AA80u;
    // 0x17aa80: 0x10000703  b           . + 4 + (0x703 << 2)
    ctx->pc = 0x17AA80u;
    {
        const bool branch_taken_0x17aa80 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17aa80) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17AA88u;
label_17aa88:
    // 0x17aa88: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17aa88u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17aa8c: 0x2402003c  addiu       $v0, $zero, 0x3C
    ctx->pc = 0x17aa8cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 60));
    // 0x17aa90: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17aa90u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17aa94: 0x0  nop
    ctx->pc = 0x17aa94u;
    // NOP
    // 0x17aa98: 0x0  nop
    ctx->pc = 0x17aa98u;
    // NOP
    // 0x17aa9c: 0x1010  mfhi        $v0
    ctx->pc = 0x17aa9cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17aaa0: 0x144006fb  bnez        $v0, . + 4 + (0x6FB << 2)
    ctx->pc = 0x17AAA0u;
    {
        const bool branch_taken_0x17aaa0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17aaa0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17AAA8u;
    // 0x17aaa8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aaa8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aaac: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aaacu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aab0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17aab0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17aab4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17AAB4u;
    SET_GPR_U32(ctx, 31, 0x17AABCu);
    ctx->pc = 0x17AAB8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AAB4u;
            // 0x17aab8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AABCu; }
        if (ctx->pc != 0x17AABCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AABCu; }
        if (ctx->pc != 0x17AABCu) { return; }
    }
    ctx->pc = 0x17AABCu;
    // 0x17aabc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aabcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aac0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aac0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aac4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17aac4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17aac8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17AAC8u;
    SET_GPR_U32(ctx, 31, 0x17AAD0u);
    ctx->pc = 0x17AACCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AAC8u;
            // 0x17aacc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AAD0u; }
        if (ctx->pc != 0x17AAD0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AAD0u; }
        if (ctx->pc != 0x17AAD0u) { return; }
    }
    ctx->pc = 0x17AAD0u;
    // 0x17aad0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aad0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aad4: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17aad4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17aad8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aad8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aadc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17aadcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17aae0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AAE0u;
    SET_GPR_U32(ctx, 31, 0x17AAE8u);
    ctx->pc = 0x17AAE4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AAE0u;
            // 0x17aae4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AAE8u; }
        if (ctx->pc != 0x17AAE8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AAE8u; }
        if (ctx->pc != 0x17AAE8u) { return; }
    }
    ctx->pc = 0x17AAE8u;
    // 0x17aae8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aae8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aaec: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17aaecu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17aaf0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aaf0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aaf4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17aaf4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17aaf8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AAF8u;
    SET_GPR_U32(ctx, 31, 0x17AB00u);
    ctx->pc = 0x17AAFCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AAF8u;
            // 0x17aafc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AB00u; }
        if (ctx->pc != 0x17AB00u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AB00u; }
        if (ctx->pc != 0x17AB00u) { return; }
    }
    ctx->pc = 0x17AB00u;
    // 0x17ab00: 0x100006e3  b           . + 4 + (0x6E3 << 2)
    ctx->pc = 0x17AB00u;
    {
        const bool branch_taken_0x17ab00 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17ab00) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17AB08u;
label_17ab08:
    // 0x17ab08: 0xc065d00  jal         func_197400
    ctx->pc = 0x17AB08u;
    SET_GPR_U32(ctx, 31, 0x17AB10u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AB10u; }
        if (ctx->pc != 0x17AB10u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AB10u; }
        if (ctx->pc != 0x17AB10u) { return; }
    }
    ctx->pc = 0x17AB10u;
    // 0x17ab10: 0x28410002  slti        $at, $v0, 0x2
    ctx->pc = 0x17ab10u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)2) ? 1 : 0);
    // 0x17ab14: 0x142000a0  bnez        $at, . + 4 + (0xA0 << 2)
    ctx->pc = 0x17AB14u;
    {
        const bool branch_taken_0x17ab14 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x17ab14) {
            ctx->pc = 0x17AD98u;
            goto label_17ad98;
        }
    }
    ctx->pc = 0x17AB1Cu;
    // 0x17ab1c: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17ab1cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17ab20: 0x2402000c  addiu       $v0, $zero, 0xC
    ctx->pc = 0x17ab20u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17ab24: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17ab24u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17ab28: 0x0  nop
    ctx->pc = 0x17ab28u;
    // NOP
    // 0x17ab2c: 0x0  nop
    ctx->pc = 0x17ab2cu;
    // NOP
    // 0x17ab30: 0x1010  mfhi        $v0
    ctx->pc = 0x17ab30u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17ab34: 0x1440004e  bnez        $v0, . + 4 + (0x4E << 2)
    ctx->pc = 0x17AB34u;
    {
        const bool branch_taken_0x17ab34 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17ab34) {
            ctx->pc = 0x17AC70u;
            goto label_17ac70;
        }
    }
    ctx->pc = 0x17AB3Cu;
    // 0x17ab3c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17ab3cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ab40: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17ab40u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17ab44: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17ab44u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17ab48: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17ab48u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17ab4c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17ab4cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17ab50: 0x0  nop
    ctx->pc = 0x17ab50u;
    // NOP
    // 0x17ab54: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17ab54u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17ab58: 0xc05d080  jal         func_174200
    ctx->pc = 0x17AB58u;
    SET_GPR_U32(ctx, 31, 0x17AB60u);
    ctx->pc = 0x17AB5Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AB58u;
            // 0x17ab5c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AB60u; }
        if (ctx->pc != 0x17AB60u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AB60u; }
        if (ctx->pc != 0x17AB60u) { return; }
    }
    ctx->pc = 0x17AB60u;
    // 0x17ab60: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17ab60u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ab64: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17ab64u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17ab68: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17ab68u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17ab6c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17ab6cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17ab70: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17ab70u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17ab74: 0x0  nop
    ctx->pc = 0x17ab74u;
    // NOP
    // 0x17ab78: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17ab78u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17ab7c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17AB7Cu;
    SET_GPR_U32(ctx, 31, 0x17AB84u);
    ctx->pc = 0x17AB80u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AB7Cu;
            // 0x17ab80: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AB84u; }
        if (ctx->pc != 0x17AB84u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AB84u; }
        if (ctx->pc != 0x17AB84u) { return; }
    }
    ctx->pc = 0x17AB84u;
    // 0x17ab84: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ab84u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ab88: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ab88u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ab8c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ab8cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ab90: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17AB90u;
    SET_GPR_U32(ctx, 31, 0x17AB98u);
    ctx->pc = 0x17AB94u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AB90u;
            // 0x17ab94: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AB98u; }
        if (ctx->pc != 0x17AB98u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AB98u; }
        if (ctx->pc != 0x17AB98u) { return; }
    }
    ctx->pc = 0x17AB98u;
    // 0x17ab98: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ab98u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ab9c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ab9cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aba0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17aba0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17aba4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17ABA4u;
    SET_GPR_U32(ctx, 31, 0x17ABACu);
    ctx->pc = 0x17ABA8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17ABA4u;
            // 0x17aba8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ABACu; }
        if (ctx->pc != 0x17ABACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ABACu; }
        if (ctx->pc != 0x17ABACu) { return; }
    }
    ctx->pc = 0x17ABACu;
    // 0x17abac: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17abacu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17abb0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17abb0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17abb4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17abb4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17abb8: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17abb8u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17abbc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17abbcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17abc0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17abc0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17abc4: 0xc065480  jal         func_195200
    ctx->pc = 0x17ABC4u;
    SET_GPR_U32(ctx, 31, 0x17ABCCu);
    ctx->pc = 0x17ABC8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17ABC4u;
            // 0x17abc8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ABCCu; }
        if (ctx->pc != 0x17ABCCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ABCCu; }
        if (ctx->pc != 0x17ABCCu) { return; }
    }
    ctx->pc = 0x17ABCCu;
    // 0x17abcc: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17abccu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17abd0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17abd0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17abd4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17abd4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17abd8: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17abd8u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17abdc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17abdcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17abe0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17abe0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17abe4: 0xc065480  jal         func_195200
    ctx->pc = 0x17ABE4u;
    SET_GPR_U32(ctx, 31, 0x17ABECu);
    ctx->pc = 0x17ABE8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17ABE4u;
            // 0x17abe8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ABECu; }
        if (ctx->pc != 0x17ABECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ABECu; }
        if (ctx->pc != 0x17ABECu) { return; }
    }
    ctx->pc = 0x17ABECu;
    // 0x17abec: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17abecu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17abf0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17abf0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17abf4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17abf4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17abf8: 0x24060006  addiu       $a2, $zero, 0x6
    ctx->pc = 0x17abf8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 6));
    // 0x17abfc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17abfcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ac00: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ac00u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ac04: 0xc065480  jal         func_195200
    ctx->pc = 0x17AC04u;
    SET_GPR_U32(ctx, 31, 0x17AC0Cu);
    ctx->pc = 0x17AC08u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AC04u;
            // 0x17ac08: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AC0Cu; }
        if (ctx->pc != 0x17AC0Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AC0Cu; }
        if (ctx->pc != 0x17AC0Cu) { return; }
    }
    ctx->pc = 0x17AC0Cu;
    // 0x17ac0c: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17ac0cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17ac10: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ac10u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ac14: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17ac14u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17ac18: 0x24060072  addiu       $a2, $zero, 0x72
    ctx->pc = 0x17ac18u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 114));
    // 0x17ac1c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ac1cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ac20: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17ac20u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17ac24: 0xc065480  jal         func_195200
    ctx->pc = 0x17AC24u;
    SET_GPR_U32(ctx, 31, 0x17AC2Cu);
    ctx->pc = 0x17AC28u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AC24u;
            // 0x17ac28: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AC2Cu; }
        if (ctx->pc != 0x17AC2Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AC2Cu; }
        if (ctx->pc != 0x17AC2Cu) { return; }
    }
    ctx->pc = 0x17AC2Cu;
    // 0x17ac2c: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17ac2cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17ac30: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ac30u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ac34: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17ac34u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17ac38: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17ac38u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17ac3c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ac3cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ac40: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ac40u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ac44: 0xc065480  jal         func_195200
    ctx->pc = 0x17AC44u;
    SET_GPR_U32(ctx, 31, 0x17AC4Cu);
    ctx->pc = 0x17AC48u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AC44u;
            // 0x17ac48: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AC4Cu; }
        if (ctx->pc != 0x17AC4Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AC4Cu; }
        if (ctx->pc != 0x17AC4Cu) { return; }
    }
    ctx->pc = 0x17AC4Cu;
    // 0x17ac4c: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17ac4cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17ac50: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ac50u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ac54: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17ac54u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17ac58: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17ac58u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17ac5c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ac5cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ac60: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17ac60u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17ac64: 0xc065480  jal         func_195200
    ctx->pc = 0x17AC64u;
    SET_GPR_U32(ctx, 31, 0x17AC6Cu);
    ctx->pc = 0x17AC68u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AC64u;
            // 0x17ac68: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AC6Cu; }
        if (ctx->pc != 0x17AC6Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AC6Cu; }
        if (ctx->pc != 0x17AC6Cu) { return; }
    }
    ctx->pc = 0x17AC6Cu;
    // 0x17ac6c: 0x0  nop
    ctx->pc = 0x17ac6cu;
    // NOP
label_17ac70:
    // 0x17ac70: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17ac70u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17ac74: 0x2402001e  addiu       $v0, $zero, 0x1E
    ctx->pc = 0x17ac74u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 30));
    // 0x17ac78: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17ac78u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17ac7c: 0x0  nop
    ctx->pc = 0x17ac7cu;
    // NOP
    // 0x17ac80: 0x0  nop
    ctx->pc = 0x17ac80u;
    // NOP
    // 0x17ac84: 0x1010  mfhi        $v0
    ctx->pc = 0x17ac84u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17ac88: 0x14400681  bnez        $v0, . + 4 + (0x681 << 2)
    ctx->pc = 0x17AC88u;
    {
        const bool branch_taken_0x17ac88 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17ac88) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17AC90u;
    // 0x17ac90: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17ac90u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ac94: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17ac94u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17ac98: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17ac98u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17ac9c: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17ac9cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17aca0: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17aca0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17aca4: 0x0  nop
    ctx->pc = 0x17aca4u;
    // NOP
    // 0x17aca8: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17aca8u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17acac: 0xc05d080  jal         func_174200
    ctx->pc = 0x17ACACu;
    SET_GPR_U32(ctx, 31, 0x17ACB4u);
    ctx->pc = 0x17ACB0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17ACACu;
            // 0x17acb0: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ACB4u; }
        if (ctx->pc != 0x17ACB4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ACB4u; }
        if (ctx->pc != 0x17ACB4u) { return; }
    }
    ctx->pc = 0x17ACB4u;
    // 0x17acb4: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17acb4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17acb8: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17acb8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17acbc: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17acbcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17acc0: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17acc0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17acc4: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17acc4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17acc8: 0x0  nop
    ctx->pc = 0x17acc8u;
    // NOP
    // 0x17accc: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17acccu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17acd0: 0xc05d080  jal         func_174200
    ctx->pc = 0x17ACD0u;
    SET_GPR_U32(ctx, 31, 0x17ACD8u);
    ctx->pc = 0x17ACD4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17ACD0u;
            // 0x17acd4: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ACD8u; }
        if (ctx->pc != 0x17ACD8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ACD8u; }
        if (ctx->pc != 0x17ACD8u) { return; }
    }
    ctx->pc = 0x17ACD8u;
    // 0x17acd8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17acd8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17acdc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17acdcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ace0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ace0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ace4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17ACE4u;
    SET_GPR_U32(ctx, 31, 0x17ACECu);
    ctx->pc = 0x17ACE8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17ACE4u;
            // 0x17ace8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ACECu; }
        if (ctx->pc != 0x17ACECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ACECu; }
        if (ctx->pc != 0x17ACECu) { return; }
    }
    ctx->pc = 0x17ACECu;
    // 0x17acec: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17acecu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17acf0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17acf0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17acf4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17acf4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17acf8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17ACF8u;
    SET_GPR_U32(ctx, 31, 0x17AD00u);
    ctx->pc = 0x17ACFCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17ACF8u;
            // 0x17acfc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD00u; }
        if (ctx->pc != 0x17AD00u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD00u; }
        if (ctx->pc != 0x17AD00u) { return; }
    }
    ctx->pc = 0x17AD00u;
    // 0x17ad00: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ad00u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ad04: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17ad04u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17ad08: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ad08u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ad0c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ad0cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ad10: 0xc065508  jal         func_195420
    ctx->pc = 0x17AD10u;
    SET_GPR_U32(ctx, 31, 0x17AD18u);
    ctx->pc = 0x17AD14u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AD10u;
            // 0x17ad14: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD18u; }
        if (ctx->pc != 0x17AD18u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD18u; }
        if (ctx->pc != 0x17AD18u) { return; }
    }
    ctx->pc = 0x17AD18u;
    // 0x17ad18: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ad18u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ad1c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17ad1cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17ad20: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ad20u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ad24: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17ad24u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17ad28: 0xc065508  jal         func_195420
    ctx->pc = 0x17AD28u;
    SET_GPR_U32(ctx, 31, 0x17AD30u);
    ctx->pc = 0x17AD2Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AD28u;
            // 0x17ad2c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD30u; }
        if (ctx->pc != 0x17AD30u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD30u; }
        if (ctx->pc != 0x17AD30u) { return; }
    }
    ctx->pc = 0x17AD30u;
    // 0x17ad30: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ad30u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ad34: 0x24060072  addiu       $a2, $zero, 0x72
    ctx->pc = 0x17ad34u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 114));
    // 0x17ad38: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ad38u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ad3c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ad3cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ad40: 0xc065508  jal         func_195420
    ctx->pc = 0x17AD40u;
    SET_GPR_U32(ctx, 31, 0x17AD48u);
    ctx->pc = 0x17AD44u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AD40u;
            // 0x17ad44: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD48u; }
        if (ctx->pc != 0x17AD48u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD48u; }
        if (ctx->pc != 0x17AD48u) { return; }
    }
    ctx->pc = 0x17AD48u;
    // 0x17ad48: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ad48u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ad4c: 0x24060006  addiu       $a2, $zero, 0x6
    ctx->pc = 0x17ad4cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 6));
    // 0x17ad50: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ad50u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ad54: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17ad54u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17ad58: 0xc065508  jal         func_195420
    ctx->pc = 0x17AD58u;
    SET_GPR_U32(ctx, 31, 0x17AD60u);
    ctx->pc = 0x17AD5Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AD58u;
            // 0x17ad5c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD60u; }
        if (ctx->pc != 0x17AD60u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD60u; }
        if (ctx->pc != 0x17AD60u) { return; }
    }
    ctx->pc = 0x17AD60u;
    // 0x17ad60: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ad60u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ad64: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17ad64u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17ad68: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ad68u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ad6c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ad6cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ad70: 0xc065508  jal         func_195420
    ctx->pc = 0x17AD70u;
    SET_GPR_U32(ctx, 31, 0x17AD78u);
    ctx->pc = 0x17AD74u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AD70u;
            // 0x17ad74: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD78u; }
        if (ctx->pc != 0x17AD78u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD78u; }
        if (ctx->pc != 0x17AD78u) { return; }
    }
    ctx->pc = 0x17AD78u;
    // 0x17ad78: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ad78u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ad7c: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17ad7cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17ad80: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ad80u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ad84: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17ad84u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17ad88: 0xc065508  jal         func_195420
    ctx->pc = 0x17AD88u;
    SET_GPR_U32(ctx, 31, 0x17AD90u);
    ctx->pc = 0x17AD8Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AD88u;
            // 0x17ad8c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD90u; }
        if (ctx->pc != 0x17AD90u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AD90u; }
        if (ctx->pc != 0x17AD90u) { return; }
    }
    ctx->pc = 0x17AD90u;
    // 0x17ad90: 0x1000063f  b           . + 4 + (0x63F << 2)
    ctx->pc = 0x17AD90u;
    {
        const bool branch_taken_0x17ad90 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17ad90) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17AD98u;
label_17ad98:
    // 0x17ad98: 0xc065d00  jal         func_197400
    ctx->pc = 0x17AD98u;
    SET_GPR_U32(ctx, 31, 0x17ADA0u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ADA0u; }
        if (ctx->pc != 0x17ADA0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ADA0u; }
        if (ctx->pc != 0x17ADA0u) { return; }
    }
    ctx->pc = 0x17ADA0u;
    // 0x17ada0: 0x1840008d  blez        $v0, . + 4 + (0x8D << 2)
    ctx->pc = 0x17ADA0u;
    {
        const bool branch_taken_0x17ada0 = (GPR_S32(ctx, 2) <= 0);
        if (branch_taken_0x17ada0) {
            ctx->pc = 0x17AFD8u;
            goto label_17afd8;
        }
    }
    ctx->pc = 0x17ADA8u;
    // 0x17ada8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17ada8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17adac: 0x24020018  addiu       $v0, $zero, 0x18
    ctx->pc = 0x17adacu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 24));
    // 0x17adb0: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17adb0u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17adb4: 0x0  nop
    ctx->pc = 0x17adb4u;
    // NOP
    // 0x17adb8: 0x0  nop
    ctx->pc = 0x17adb8u;
    // NOP
    // 0x17adbc: 0x1010  mfhi        $v0
    ctx->pc = 0x17adbcu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17adc0: 0x1440004d  bnez        $v0, . + 4 + (0x4D << 2)
    ctx->pc = 0x17ADC0u;
    {
        const bool branch_taken_0x17adc0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17adc0) {
            ctx->pc = 0x17AEF8u;
            goto label_17aef8;
        }
    }
    ctx->pc = 0x17ADC8u;
    // 0x17adc8: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17adc8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17adcc: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17adccu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17add0: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17add0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17add4: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17add4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17add8: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17add8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17addc: 0x0  nop
    ctx->pc = 0x17addcu;
    // NOP
    // 0x17ade0: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17ade0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17ade4: 0xc05d080  jal         func_174200
    ctx->pc = 0x17ADE4u;
    SET_GPR_U32(ctx, 31, 0x17ADECu);
    ctx->pc = 0x17ADE8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17ADE4u;
            // 0x17ade8: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ADECu; }
        if (ctx->pc != 0x17ADECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17ADECu; }
        if (ctx->pc != 0x17ADECu) { return; }
    }
    ctx->pc = 0x17ADECu;
    // 0x17adec: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17adecu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17adf0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17adf0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17adf4: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17adf4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17adf8: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17adf8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17adfc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17adfcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17ae00: 0x0  nop
    ctx->pc = 0x17ae00u;
    // NOP
    // 0x17ae04: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17ae04u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17ae08: 0xc05d080  jal         func_174200
    ctx->pc = 0x17AE08u;
    SET_GPR_U32(ctx, 31, 0x17AE10u);
    ctx->pc = 0x17AE0Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AE08u;
            // 0x17ae0c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE10u; }
        if (ctx->pc != 0x17AE10u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE10u; }
        if (ctx->pc != 0x17AE10u) { return; }
    }
    ctx->pc = 0x17AE10u;
    // 0x17ae10: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ae10u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ae14: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ae14u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ae18: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ae18u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ae1c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17AE1Cu;
    SET_GPR_U32(ctx, 31, 0x17AE24u);
    ctx->pc = 0x17AE20u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AE1Cu;
            // 0x17ae20: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE24u; }
        if (ctx->pc != 0x17AE24u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE24u; }
        if (ctx->pc != 0x17AE24u) { return; }
    }
    ctx->pc = 0x17AE24u;
    // 0x17ae24: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ae24u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ae28: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ae28u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ae2c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17ae2cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17ae30: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17AE30u;
    SET_GPR_U32(ctx, 31, 0x17AE38u);
    ctx->pc = 0x17AE34u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AE30u;
            // 0x17ae34: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE38u; }
        if (ctx->pc != 0x17AE38u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE38u; }
        if (ctx->pc != 0x17AE38u) { return; }
    }
    ctx->pc = 0x17AE38u;
    // 0x17ae38: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17ae38u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17ae3c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ae3cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ae40: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17ae40u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17ae44: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17ae44u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17ae48: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ae48u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ae4c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ae4cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ae50: 0xc065480  jal         func_195200
    ctx->pc = 0x17AE50u;
    SET_GPR_U32(ctx, 31, 0x17AE58u);
    ctx->pc = 0x17AE54u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AE50u;
            // 0x17ae54: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE58u; }
        if (ctx->pc != 0x17AE58u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE58u; }
        if (ctx->pc != 0x17AE58u) { return; }
    }
    ctx->pc = 0x17AE58u;
    // 0x17ae58: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17ae58u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17ae5c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ae5cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ae60: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17ae60u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17ae64: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17ae64u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17ae68: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ae68u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ae6c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17ae6cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17ae70: 0xc065480  jal         func_195200
    ctx->pc = 0x17AE70u;
    SET_GPR_U32(ctx, 31, 0x17AE78u);
    ctx->pc = 0x17AE74u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AE70u;
            // 0x17ae74: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE78u; }
        if (ctx->pc != 0x17AE78u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE78u; }
        if (ctx->pc != 0x17AE78u) { return; }
    }
    ctx->pc = 0x17AE78u;
    // 0x17ae78: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17ae78u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17ae7c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ae7cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ae80: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17ae80u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17ae84: 0x24060006  addiu       $a2, $zero, 0x6
    ctx->pc = 0x17ae84u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 6));
    // 0x17ae88: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ae88u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ae8c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ae8cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ae90: 0xc065480  jal         func_195200
    ctx->pc = 0x17AE90u;
    SET_GPR_U32(ctx, 31, 0x17AE98u);
    ctx->pc = 0x17AE94u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AE90u;
            // 0x17ae94: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE98u; }
        if (ctx->pc != 0x17AE98u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AE98u; }
        if (ctx->pc != 0x17AE98u) { return; }
    }
    ctx->pc = 0x17AE98u;
    // 0x17ae98: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17ae98u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17ae9c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ae9cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aea0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17aea0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17aea4: 0x24060072  addiu       $a2, $zero, 0x72
    ctx->pc = 0x17aea4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 114));
    // 0x17aea8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aea8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aeac: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17aeacu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17aeb0: 0xc065480  jal         func_195200
    ctx->pc = 0x17AEB0u;
    SET_GPR_U32(ctx, 31, 0x17AEB8u);
    ctx->pc = 0x17AEB4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AEB0u;
            // 0x17aeb4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AEB8u; }
        if (ctx->pc != 0x17AEB8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AEB8u; }
        if (ctx->pc != 0x17AEB8u) { return; }
    }
    ctx->pc = 0x17AEB8u;
    // 0x17aeb8: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17aeb8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17aebc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aebcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aec0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17aec0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17aec4: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17aec4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17aec8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aec8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aecc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17aeccu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17aed0: 0xc065480  jal         func_195200
    ctx->pc = 0x17AED0u;
    SET_GPR_U32(ctx, 31, 0x17AED8u);
    ctx->pc = 0x17AED4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AED0u;
            // 0x17aed4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AED8u; }
        if (ctx->pc != 0x17AED8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AED8u; }
        if (ctx->pc != 0x17AED8u) { return; }
    }
    ctx->pc = 0x17AED8u;
    // 0x17aed8: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17aed8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17aedc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17aedcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17aee0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17aee0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17aee4: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17aee4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17aee8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17aee8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17aeec: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17aeecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17aef0: 0xc065480  jal         func_195200
    ctx->pc = 0x17AEF0u;
    SET_GPR_U32(ctx, 31, 0x17AEF8u);
    ctx->pc = 0x17AEF4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AEF0u;
            // 0x17aef4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AEF8u; }
        if (ctx->pc != 0x17AEF8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AEF8u; }
        if (ctx->pc != 0x17AEF8u) { return; }
    }
    ctx->pc = 0x17AEF8u;
label_17aef8:
    // 0x17aef8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17aef8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17aefc: 0x2402003c  addiu       $v0, $zero, 0x3C
    ctx->pc = 0x17aefcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 60));
    // 0x17af00: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17af00u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17af04: 0x0  nop
    ctx->pc = 0x17af04u;
    // NOP
    // 0x17af08: 0x0  nop
    ctx->pc = 0x17af08u;
    // NOP
    // 0x17af0c: 0x1010  mfhi        $v0
    ctx->pc = 0x17af0cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17af10: 0x144005df  bnez        $v0, . + 4 + (0x5DF << 2)
    ctx->pc = 0x17AF10u;
    {
        const bool branch_taken_0x17af10 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17af10) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17AF18u;
    // 0x17af18: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17af18u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17af1c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17af1cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17af20: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17af20u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17af24: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17AF24u;
    SET_GPR_U32(ctx, 31, 0x17AF2Cu);
    ctx->pc = 0x17AF28u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AF24u;
            // 0x17af28: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AF2Cu; }
        if (ctx->pc != 0x17AF2Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AF2Cu; }
        if (ctx->pc != 0x17AF2Cu) { return; }
    }
    ctx->pc = 0x17AF2Cu;
    // 0x17af2c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17af2cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17af30: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17af30u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17af34: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17af34u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17af38: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17AF38u;
    SET_GPR_U32(ctx, 31, 0x17AF40u);
    ctx->pc = 0x17AF3Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AF38u;
            // 0x17af3c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AF40u; }
        if (ctx->pc != 0x17AF40u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AF40u; }
        if (ctx->pc != 0x17AF40u) { return; }
    }
    ctx->pc = 0x17AF40u;
    // 0x17af40: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17af40u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17af44: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17af44u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17af48: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17af48u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17af4c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17af4cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17af50: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AF50u;
    SET_GPR_U32(ctx, 31, 0x17AF58u);
    ctx->pc = 0x17AF54u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AF50u;
            // 0x17af54: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AF58u; }
        if (ctx->pc != 0x17AF58u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AF58u; }
        if (ctx->pc != 0x17AF58u) { return; }
    }
    ctx->pc = 0x17AF58u;
    // 0x17af58: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17af58u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17af5c: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17af5cu;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17af60: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17af60u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17af64: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17af64u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17af68: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AF68u;
    SET_GPR_U32(ctx, 31, 0x17AF70u);
    ctx->pc = 0x17AF6Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AF68u;
            // 0x17af6c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AF70u; }
        if (ctx->pc != 0x17AF70u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AF70u; }
        if (ctx->pc != 0x17AF70u) { return; }
    }
    ctx->pc = 0x17AF70u;
    // 0x17af70: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17af70u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17af74: 0x24060072  addiu       $a2, $zero, 0x72
    ctx->pc = 0x17af74u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 114));
    // 0x17af78: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17af78u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17af7c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17af7cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17af80: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AF80u;
    SET_GPR_U32(ctx, 31, 0x17AF88u);
    ctx->pc = 0x17AF84u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AF80u;
            // 0x17af84: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AF88u; }
        if (ctx->pc != 0x17AF88u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AF88u; }
        if (ctx->pc != 0x17AF88u) { return; }
    }
    ctx->pc = 0x17AF88u;
    // 0x17af88: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17af88u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17af8c: 0x24060006  addiu       $a2, $zero, 0x6
    ctx->pc = 0x17af8cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 6));
    // 0x17af90: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17af90u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17af94: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17af94u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17af98: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AF98u;
    SET_GPR_U32(ctx, 31, 0x17AFA0u);
    ctx->pc = 0x17AF9Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AF98u;
            // 0x17af9c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AFA0u; }
        if (ctx->pc != 0x17AFA0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AFA0u; }
        if (ctx->pc != 0x17AFA0u) { return; }
    }
    ctx->pc = 0x17AFA0u;
    // 0x17afa0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17afa0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17afa4: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17afa4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17afa8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17afa8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17afac: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17afacu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17afb0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AFB0u;
    SET_GPR_U32(ctx, 31, 0x17AFB8u);
    ctx->pc = 0x17AFB4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AFB0u;
            // 0x17afb4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AFB8u; }
        if (ctx->pc != 0x17AFB8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AFB8u; }
        if (ctx->pc != 0x17AFB8u) { return; }
    }
    ctx->pc = 0x17AFB8u;
    // 0x17afb8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17afb8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17afbc: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17afbcu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17afc0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17afc0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17afc4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17afc4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17afc8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17AFC8u;
    SET_GPR_U32(ctx, 31, 0x17AFD0u);
    ctx->pc = 0x17AFCCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17AFC8u;
            // 0x17afcc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AFD0u; }
        if (ctx->pc != 0x17AFD0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17AFD0u; }
        if (ctx->pc != 0x17AFD0u) { return; }
    }
    ctx->pc = 0x17AFD0u;
    // 0x17afd0: 0x100005af  b           . + 4 + (0x5AF << 2)
    ctx->pc = 0x17AFD0u;
    {
        const bool branch_taken_0x17afd0 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17afd0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17AFD8u;
label_17afd8:
    // 0x17afd8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17afd8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17afdc: 0x24020030  addiu       $v0, $zero, 0x30
    ctx->pc = 0x17afdcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 48));
    // 0x17afe0: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17afe0u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17afe4: 0x0  nop
    ctx->pc = 0x17afe4u;
    // NOP
    // 0x17afe8: 0x0  nop
    ctx->pc = 0x17afe8u;
    // NOP
    // 0x17afec: 0x1010  mfhi        $v0
    ctx->pc = 0x17afecu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17aff0: 0x1440002d  bnez        $v0, . + 4 + (0x2D << 2)
    ctx->pc = 0x17AFF0u;
    {
        const bool branch_taken_0x17aff0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17aff0) {
            ctx->pc = 0x17B0A8u;
            goto label_17b0a8;
        }
    }
    ctx->pc = 0x17AFF8u;
    // 0x17aff8: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17aff8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17affc: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17affcu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b000: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b000u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b004: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17b004u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17b008: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b008u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b00c: 0x0  nop
    ctx->pc = 0x17b00cu;
    // NOP
    // 0x17b010: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b010u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b014: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B014u;
    SET_GPR_U32(ctx, 31, 0x17B01Cu);
    ctx->pc = 0x17B018u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B014u;
            // 0x17b018: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B01Cu; }
        if (ctx->pc != 0x17B01Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B01Cu; }
        if (ctx->pc != 0x17B01Cu) { return; }
    }
    ctx->pc = 0x17B01Cu;
    // 0x17b01c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b01cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b020: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b020u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b024: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b024u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b028: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17b028u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17b02c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b02cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b030: 0x0  nop
    ctx->pc = 0x17b030u;
    // NOP
    // 0x17b034: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b034u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b038: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B038u;
    SET_GPR_U32(ctx, 31, 0x17B040u);
    ctx->pc = 0x17B03Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B038u;
            // 0x17b03c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B040u; }
        if (ctx->pc != 0x17B040u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B040u; }
        if (ctx->pc != 0x17B040u) { return; }
    }
    ctx->pc = 0x17B040u;
    // 0x17b040: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b040u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b044: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b044u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b048: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b048u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b04c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B04Cu;
    SET_GPR_U32(ctx, 31, 0x17B054u);
    ctx->pc = 0x17B050u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B04Cu;
            // 0x17b050: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B054u; }
        if (ctx->pc != 0x17B054u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B054u; }
        if (ctx->pc != 0x17B054u) { return; }
    }
    ctx->pc = 0x17B054u;
    // 0x17b054: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b054u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b058: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b058u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b05c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b05cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b060: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B060u;
    SET_GPR_U32(ctx, 31, 0x17B068u);
    ctx->pc = 0x17B064u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B060u;
            // 0x17b064: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B068u; }
        if (ctx->pc != 0x17B068u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B068u; }
        if (ctx->pc != 0x17B068u) { return; }
    }
    ctx->pc = 0x17B068u;
    // 0x17b068: 0x3c023fc0  lui         $v0, 0x3FC0
    ctx->pc = 0x17b068u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16320 << 16));
    // 0x17b06c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b06cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b070: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b070u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b074: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17b074u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17b078: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b078u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b07c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b07cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b080: 0xc065480  jal         func_195200
    ctx->pc = 0x17B080u;
    SET_GPR_U32(ctx, 31, 0x17B088u);
    ctx->pc = 0x17B084u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B080u;
            // 0x17b084: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B088u; }
        if (ctx->pc != 0x17B088u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B088u; }
        if (ctx->pc != 0x17B088u) { return; }
    }
    ctx->pc = 0x17B088u;
    // 0x17b088: 0x3c023fc0  lui         $v0, 0x3FC0
    ctx->pc = 0x17b088u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16320 << 16));
    // 0x17b08c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b08cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b090: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b090u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b094: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17b094u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17b098: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b098u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b09c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b09cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b0a0: 0xc065480  jal         func_195200
    ctx->pc = 0x17B0A0u;
    SET_GPR_U32(ctx, 31, 0x17B0A8u);
    ctx->pc = 0x17B0A4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B0A0u;
            // 0x17b0a4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B0A8u; }
        if (ctx->pc != 0x17B0A8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B0A8u; }
        if (ctx->pc != 0x17B0A8u) { return; }
    }
    ctx->pc = 0x17B0A8u;
label_17b0a8:
    // 0x17b0a8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17b0a8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17b0ac: 0x24020078  addiu       $v0, $zero, 0x78
    ctx->pc = 0x17b0acu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 120));
    // 0x17b0b0: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17b0b0u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17b0b4: 0x0  nop
    ctx->pc = 0x17b0b4u;
    // NOP
    // 0x17b0b8: 0x0  nop
    ctx->pc = 0x17b0b8u;
    // NOP
    // 0x17b0bc: 0x1010  mfhi        $v0
    ctx->pc = 0x17b0bcu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17b0c0: 0x14400573  bnez        $v0, . + 4 + (0x573 << 2)
    ctx->pc = 0x17B0C0u;
    {
        const bool branch_taken_0x17b0c0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17b0c0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17B0C8u;
    // 0x17b0c8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b0c8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b0cc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b0ccu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b0d0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b0d0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b0d4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B0D4u;
    SET_GPR_U32(ctx, 31, 0x17B0DCu);
    ctx->pc = 0x17B0D8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B0D4u;
            // 0x17b0d8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B0DCu; }
        if (ctx->pc != 0x17B0DCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B0DCu; }
        if (ctx->pc != 0x17B0DCu) { return; }
    }
    ctx->pc = 0x17B0DCu;
    // 0x17b0dc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b0dcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b0e0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b0e0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b0e4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b0e4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b0e8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B0E8u;
    SET_GPR_U32(ctx, 31, 0x17B0F0u);
    ctx->pc = 0x17B0ECu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B0E8u;
            // 0x17b0ec: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B0F0u; }
        if (ctx->pc != 0x17B0F0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B0F0u; }
        if (ctx->pc != 0x17B0F0u) { return; }
    }
    ctx->pc = 0x17B0F0u;
    // 0x17b0f0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b0f0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b0f4: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17b0f4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17b0f8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b0f8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b0fc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b0fcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b100: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B100u;
    SET_GPR_U32(ctx, 31, 0x17B108u);
    ctx->pc = 0x17B104u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B100u;
            // 0x17b104: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B108u; }
        if (ctx->pc != 0x17B108u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B108u; }
        if (ctx->pc != 0x17B108u) { return; }
    }
    ctx->pc = 0x17B108u;
    // 0x17b108: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b108u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b10c: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17b10cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17b110: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b110u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b114: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b114u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b118: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B118u;
    SET_GPR_U32(ctx, 31, 0x17B120u);
    ctx->pc = 0x17B11Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B118u;
            // 0x17b11c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B120u; }
        if (ctx->pc != 0x17B120u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B120u; }
        if (ctx->pc != 0x17B120u) { return; }
    }
    ctx->pc = 0x17B120u;
    // 0x17b120: 0x1000055b  b           . + 4 + (0x55B << 2)
    ctx->pc = 0x17B120u;
    {
        const bool branch_taken_0x17b120 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17b120) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17B128u;
label_17b128:
    // 0x17b128: 0xc065d00  jal         func_197400
    ctx->pc = 0x17B128u;
    SET_GPR_U32(ctx, 31, 0x17B130u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B130u; }
        if (ctx->pc != 0x17B130u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B130u; }
        if (ctx->pc != 0x17B130u) { return; }
    }
    ctx->pc = 0x17B130u;
    // 0x17b130: 0x28410002  slti        $at, $v0, 0x2
    ctx->pc = 0x17b130u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)2) ? 1 : 0);
    // 0x17b134: 0x142000bc  bnez        $at, . + 4 + (0xBC << 2)
    ctx->pc = 0x17B134u;
    {
        const bool branch_taken_0x17b134 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x17b134) {
            ctx->pc = 0x17B428u;
            goto label_17b428;
        }
    }
    ctx->pc = 0x17B13Cu;
    // 0x17b13c: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17b13cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17b140: 0x2402000a  addiu       $v0, $zero, 0xA
    ctx->pc = 0x17b140u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 10));
    // 0x17b144: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17b144u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17b148: 0x0  nop
    ctx->pc = 0x17b148u;
    // NOP
    // 0x17b14c: 0x0  nop
    ctx->pc = 0x17b14cu;
    // NOP
    // 0x17b150: 0x1010  mfhi        $v0
    ctx->pc = 0x17b150u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17b154: 0x1440005e  bnez        $v0, . + 4 + (0x5E << 2)
    ctx->pc = 0x17B154u;
    {
        const bool branch_taken_0x17b154 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17b154) {
            ctx->pc = 0x17B2D0u;
            goto label_17b2d0;
        }
    }
    ctx->pc = 0x17B15Cu;
    // 0x17b15c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b15cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b160: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b160u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b164: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b164u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b168: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17b168u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17b16c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b16cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b170: 0x0  nop
    ctx->pc = 0x17b170u;
    // NOP
    // 0x17b174: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b174u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b178: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B178u;
    SET_GPR_U32(ctx, 31, 0x17B180u);
    ctx->pc = 0x17B17Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B178u;
            // 0x17b17c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B180u; }
        if (ctx->pc != 0x17B180u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B180u; }
        if (ctx->pc != 0x17B180u) { return; }
    }
    ctx->pc = 0x17B180u;
    // 0x17b180: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b180u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b184: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b184u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b188: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b188u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b18c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17b18cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17b190: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b190u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b194: 0x0  nop
    ctx->pc = 0x17b194u;
    // NOP
    // 0x17b198: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b198u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b19c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B19Cu;
    SET_GPR_U32(ctx, 31, 0x17B1A4u);
    ctx->pc = 0x17B1A0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B19Cu;
            // 0x17b1a0: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B1A4u; }
        if (ctx->pc != 0x17B1A4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B1A4u; }
        if (ctx->pc != 0x17B1A4u) { return; }
    }
    ctx->pc = 0x17B1A4u;
    // 0x17b1a4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b1a4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b1a8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b1a8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b1ac: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b1acu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b1b0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B1B0u;
    SET_GPR_U32(ctx, 31, 0x17B1B8u);
    ctx->pc = 0x17B1B4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B1B0u;
            // 0x17b1b4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B1B8u; }
        if (ctx->pc != 0x17B1B8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B1B8u; }
        if (ctx->pc != 0x17B1B8u) { return; }
    }
    ctx->pc = 0x17B1B8u;
    // 0x17b1b8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b1b8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b1bc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b1bcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b1c0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b1c0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b1c4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B1C4u;
    SET_GPR_U32(ctx, 31, 0x17B1CCu);
    ctx->pc = 0x17B1C8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B1C4u;
            // 0x17b1c8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B1CCu; }
        if (ctx->pc != 0x17B1CCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B1CCu; }
        if (ctx->pc != 0x17B1CCu) { return; }
    }
    ctx->pc = 0x17B1CCu;
    // 0x17b1cc: 0x3c024060  lui         $v0, 0x4060
    ctx->pc = 0x17b1ccu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16480 << 16));
    // 0x17b1d0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b1d0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b1d4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b1d4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b1d8: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17b1d8u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17b1dc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b1dcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b1e0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b1e0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b1e4: 0xc065480  jal         func_195200
    ctx->pc = 0x17B1E4u;
    SET_GPR_U32(ctx, 31, 0x17B1ECu);
    ctx->pc = 0x17B1E8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B1E4u;
            // 0x17b1e8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B1ECu; }
        if (ctx->pc != 0x17B1ECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B1ECu; }
        if (ctx->pc != 0x17B1ECu) { return; }
    }
    ctx->pc = 0x17B1ECu;
    // 0x17b1ec: 0x3c024060  lui         $v0, 0x4060
    ctx->pc = 0x17b1ecu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16480 << 16));
    // 0x17b1f0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b1f0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b1f4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b1f4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b1f8: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17b1f8u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17b1fc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b1fcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b200: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b200u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b204: 0xc065480  jal         func_195200
    ctx->pc = 0x17B204u;
    SET_GPR_U32(ctx, 31, 0x17B20Cu);
    ctx->pc = 0x17B208u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B204u;
            // 0x17b208: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B20Cu; }
        if (ctx->pc != 0x17B20Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B20Cu; }
        if (ctx->pc != 0x17B20Cu) { return; }
    }
    ctx->pc = 0x17B20Cu;
    // 0x17b20c: 0x3c024060  lui         $v0, 0x4060
    ctx->pc = 0x17b20cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16480 << 16));
    // 0x17b210: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b210u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b214: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b214u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b218: 0x24060005  addiu       $a2, $zero, 0x5
    ctx->pc = 0x17b218u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 5));
    // 0x17b21c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b21cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b220: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b220u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b224: 0xc065480  jal         func_195200
    ctx->pc = 0x17B224u;
    SET_GPR_U32(ctx, 31, 0x17B22Cu);
    ctx->pc = 0x17B228u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B224u;
            // 0x17b228: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B22Cu; }
        if (ctx->pc != 0x17B22Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B22Cu; }
        if (ctx->pc != 0x17B22Cu) { return; }
    }
    ctx->pc = 0x17B22Cu;
    // 0x17b22c: 0x3c024060  lui         $v0, 0x4060
    ctx->pc = 0x17b22cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16480 << 16));
    // 0x17b230: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b230u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b234: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b234u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b238: 0x24060073  addiu       $a2, $zero, 0x73
    ctx->pc = 0x17b238u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 115));
    // 0x17b23c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b23cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b240: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b240u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b244: 0xc065480  jal         func_195200
    ctx->pc = 0x17B244u;
    SET_GPR_U32(ctx, 31, 0x17B24Cu);
    ctx->pc = 0x17B248u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B244u;
            // 0x17b248: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B24Cu; }
        if (ctx->pc != 0x17B24Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B24Cu; }
        if (ctx->pc != 0x17B24Cu) { return; }
    }
    ctx->pc = 0x17B24Cu;
    // 0x17b24c: 0x3c024060  lui         $v0, 0x4060
    ctx->pc = 0x17b24cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16480 << 16));
    // 0x17b250: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b250u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b254: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b254u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b258: 0x2406000a  addiu       $a2, $zero, 0xA
    ctx->pc = 0x17b258u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 10));
    // 0x17b25c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b25cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b260: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b260u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b264: 0xc065480  jal         func_195200
    ctx->pc = 0x17B264u;
    SET_GPR_U32(ctx, 31, 0x17B26Cu);
    ctx->pc = 0x17B268u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B264u;
            // 0x17b268: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B26Cu; }
        if (ctx->pc != 0x17B26Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B26Cu; }
        if (ctx->pc != 0x17B26Cu) { return; }
    }
    ctx->pc = 0x17B26Cu;
    // 0x17b26c: 0x3c024060  lui         $v0, 0x4060
    ctx->pc = 0x17b26cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16480 << 16));
    // 0x17b270: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b270u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b274: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b274u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b278: 0x2406006e  addiu       $a2, $zero, 0x6E
    ctx->pc = 0x17b278u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 110));
    // 0x17b27c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b27cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b280: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b280u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b284: 0xc065480  jal         func_195200
    ctx->pc = 0x17B284u;
    SET_GPR_U32(ctx, 31, 0x17B28Cu);
    ctx->pc = 0x17B288u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B284u;
            // 0x17b288: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B28Cu; }
        if (ctx->pc != 0x17B28Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B28Cu; }
        if (ctx->pc != 0x17B28Cu) { return; }
    }
    ctx->pc = 0x17B28Cu;
    // 0x17b28c: 0x3c024060  lui         $v0, 0x4060
    ctx->pc = 0x17b28cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16480 << 16));
    // 0x17b290: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b290u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b294: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b294u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b298: 0x2406000f  addiu       $a2, $zero, 0xF
    ctx->pc = 0x17b298u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 15));
    // 0x17b29c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b29cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b2a0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b2a0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b2a4: 0xc065480  jal         func_195200
    ctx->pc = 0x17B2A4u;
    SET_GPR_U32(ctx, 31, 0x17B2ACu);
    ctx->pc = 0x17B2A8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B2A4u;
            // 0x17b2a8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B2ACu; }
        if (ctx->pc != 0x17B2ACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B2ACu; }
        if (ctx->pc != 0x17B2ACu) { return; }
    }
    ctx->pc = 0x17B2ACu;
    // 0x17b2ac: 0x3c024060  lui         $v0, 0x4060
    ctx->pc = 0x17b2acu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16480 << 16));
    // 0x17b2b0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b2b0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b2b4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b2b4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b2b8: 0x24060069  addiu       $a2, $zero, 0x69
    ctx->pc = 0x17b2b8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 105));
    // 0x17b2bc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b2bcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b2c0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b2c0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b2c4: 0xc065480  jal         func_195200
    ctx->pc = 0x17B2C4u;
    SET_GPR_U32(ctx, 31, 0x17B2CCu);
    ctx->pc = 0x17B2C8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B2C4u;
            // 0x17b2c8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B2CCu; }
        if (ctx->pc != 0x17B2CCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B2CCu; }
        if (ctx->pc != 0x17B2CCu) { return; }
    }
    ctx->pc = 0x17B2CCu;
    // 0x17b2cc: 0x0  nop
    ctx->pc = 0x17b2ccu;
    // NOP
label_17b2d0:
    // 0x17b2d0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17b2d0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17b2d4: 0x24020014  addiu       $v0, $zero, 0x14
    ctx->pc = 0x17b2d4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 20));
    // 0x17b2d8: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17b2d8u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17b2dc: 0x0  nop
    ctx->pc = 0x17b2dcu;
    // NOP
    // 0x17b2e0: 0x0  nop
    ctx->pc = 0x17b2e0u;
    // NOP
    // 0x17b2e4: 0x1010  mfhi        $v0
    ctx->pc = 0x17b2e4u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17b2e8: 0x144004e9  bnez        $v0, . + 4 + (0x4E9 << 2)
    ctx->pc = 0x17B2E8u;
    {
        const bool branch_taken_0x17b2e8 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17b2e8) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17B2F0u;
    // 0x17b2f0: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b2f0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b2f4: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b2f4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b2f8: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b2f8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b2fc: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17b2fcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17b300: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b300u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b304: 0x0  nop
    ctx->pc = 0x17b304u;
    // NOP
    // 0x17b308: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b308u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b30c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B30Cu;
    SET_GPR_U32(ctx, 31, 0x17B314u);
    ctx->pc = 0x17B310u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B30Cu;
            // 0x17b310: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B314u; }
        if (ctx->pc != 0x17B314u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B314u; }
        if (ctx->pc != 0x17B314u) { return; }
    }
    ctx->pc = 0x17B314u;
    // 0x17b314: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b314u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b318: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b318u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b31c: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b31cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b320: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17b320u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17b324: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b324u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b328: 0x0  nop
    ctx->pc = 0x17b328u;
    // NOP
    // 0x17b32c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b32cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b330: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B330u;
    SET_GPR_U32(ctx, 31, 0x17B338u);
    ctx->pc = 0x17B334u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B330u;
            // 0x17b334: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B338u; }
        if (ctx->pc != 0x17B338u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B338u; }
        if (ctx->pc != 0x17B338u) { return; }
    }
    ctx->pc = 0x17B338u;
    // 0x17b338: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b338u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b33c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b33cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b340: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b340u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b344: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B344u;
    SET_GPR_U32(ctx, 31, 0x17B34Cu);
    ctx->pc = 0x17B348u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B344u;
            // 0x17b348: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B34Cu; }
        if (ctx->pc != 0x17B34Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B34Cu; }
        if (ctx->pc != 0x17B34Cu) { return; }
    }
    ctx->pc = 0x17B34Cu;
    // 0x17b34c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b34cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b350: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b350u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b354: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b354u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b358: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B358u;
    SET_GPR_U32(ctx, 31, 0x17B360u);
    ctx->pc = 0x17B35Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B358u;
            // 0x17b35c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B360u; }
        if (ctx->pc != 0x17B360u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B360u; }
        if (ctx->pc != 0x17B360u) { return; }
    }
    ctx->pc = 0x17B360u;
    // 0x17b360: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b360u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b364: 0x24060073  addiu       $a2, $zero, 0x73
    ctx->pc = 0x17b364u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 115));
    // 0x17b368: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b368u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b36c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b36cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b370: 0xc065508  jal         func_195420
    ctx->pc = 0x17B370u;
    SET_GPR_U32(ctx, 31, 0x17B378u);
    ctx->pc = 0x17B374u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B370u;
            // 0x17b374: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B378u; }
        if (ctx->pc != 0x17B378u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B378u; }
        if (ctx->pc != 0x17B378u) { return; }
    }
    ctx->pc = 0x17B378u;
    // 0x17b378: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b378u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b37c: 0x24060005  addiu       $a2, $zero, 0x5
    ctx->pc = 0x17b37cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 5));
    // 0x17b380: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b380u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b384: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b384u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b388: 0xc065508  jal         func_195420
    ctx->pc = 0x17B388u;
    SET_GPR_U32(ctx, 31, 0x17B390u);
    ctx->pc = 0x17B38Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B388u;
            // 0x17b38c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B390u; }
        if (ctx->pc != 0x17B390u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B390u; }
        if (ctx->pc != 0x17B390u) { return; }
    }
    ctx->pc = 0x17B390u;
    // 0x17b390: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b390u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b394: 0x2406006e  addiu       $a2, $zero, 0x6E
    ctx->pc = 0x17b394u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 110));
    // 0x17b398: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b398u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b39c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b39cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b3a0: 0xc065508  jal         func_195420
    ctx->pc = 0x17B3A0u;
    SET_GPR_U32(ctx, 31, 0x17B3A8u);
    ctx->pc = 0x17B3A4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B3A0u;
            // 0x17b3a4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B3A8u; }
        if (ctx->pc != 0x17B3A8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B3A8u; }
        if (ctx->pc != 0x17B3A8u) { return; }
    }
    ctx->pc = 0x17B3A8u;
    // 0x17b3a8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b3a8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b3ac: 0x2406000a  addiu       $a2, $zero, 0xA
    ctx->pc = 0x17b3acu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 10));
    // 0x17b3b0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b3b0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b3b4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b3b4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b3b8: 0xc065508  jal         func_195420
    ctx->pc = 0x17B3B8u;
    SET_GPR_U32(ctx, 31, 0x17B3C0u);
    ctx->pc = 0x17B3BCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B3B8u;
            // 0x17b3bc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B3C0u; }
        if (ctx->pc != 0x17B3C0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B3C0u; }
        if (ctx->pc != 0x17B3C0u) { return; }
    }
    ctx->pc = 0x17B3C0u;
    // 0x17b3c0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b3c0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b3c4: 0x24060069  addiu       $a2, $zero, 0x69
    ctx->pc = 0x17b3c4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 105));
    // 0x17b3c8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b3c8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b3cc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b3ccu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b3d0: 0xc065508  jal         func_195420
    ctx->pc = 0x17B3D0u;
    SET_GPR_U32(ctx, 31, 0x17B3D8u);
    ctx->pc = 0x17B3D4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B3D0u;
            // 0x17b3d4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B3D8u; }
        if (ctx->pc != 0x17B3D8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B3D8u; }
        if (ctx->pc != 0x17B3D8u) { return; }
    }
    ctx->pc = 0x17B3D8u;
    // 0x17b3d8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b3d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b3dc: 0x2406000f  addiu       $a2, $zero, 0xF
    ctx->pc = 0x17b3dcu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 15));
    // 0x17b3e0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b3e0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b3e4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b3e4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b3e8: 0xc065508  jal         func_195420
    ctx->pc = 0x17B3E8u;
    SET_GPR_U32(ctx, 31, 0x17B3F0u);
    ctx->pc = 0x17B3ECu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B3E8u;
            // 0x17b3ec: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B3F0u; }
        if (ctx->pc != 0x17B3F0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B3F0u; }
        if (ctx->pc != 0x17B3F0u) { return; }
    }
    ctx->pc = 0x17B3F0u;
    // 0x17b3f0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b3f0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b3f4: 0x24060064  addiu       $a2, $zero, 0x64
    ctx->pc = 0x17b3f4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x17b3f8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b3f8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b3fc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b3fcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b400: 0xc065508  jal         func_195420
    ctx->pc = 0x17B400u;
    SET_GPR_U32(ctx, 31, 0x17B408u);
    ctx->pc = 0x17B404u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B400u;
            // 0x17b404: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B408u; }
        if (ctx->pc != 0x17B408u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B408u; }
        if (ctx->pc != 0x17B408u) { return; }
    }
    ctx->pc = 0x17B408u;
    // 0x17b408: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b408u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b40c: 0x24060014  addiu       $a2, $zero, 0x14
    ctx->pc = 0x17b40cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 20));
    // 0x17b410: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b410u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b414: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b414u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b418: 0xc065508  jal         func_195420
    ctx->pc = 0x17B418u;
    SET_GPR_U32(ctx, 31, 0x17B420u);
    ctx->pc = 0x17B41Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B418u;
            // 0x17b41c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B420u; }
        if (ctx->pc != 0x17B420u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B420u; }
        if (ctx->pc != 0x17B420u) { return; }
    }
    ctx->pc = 0x17B420u;
    // 0x17b420: 0x1000049b  b           . + 4 + (0x49B << 2)
    ctx->pc = 0x17B420u;
    {
        const bool branch_taken_0x17b420 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17b420) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17B428u;
label_17b428:
    // 0x17b428: 0xc065d00  jal         func_197400
    ctx->pc = 0x17B428u;
    SET_GPR_U32(ctx, 31, 0x17B430u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B430u; }
        if (ctx->pc != 0x17B430u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B430u; }
        if (ctx->pc != 0x17B430u) { return; }
    }
    ctx->pc = 0x17B430u;
    // 0x17b430: 0x1840008d  blez        $v0, . + 4 + (0x8D << 2)
    ctx->pc = 0x17B430u;
    {
        const bool branch_taken_0x17b430 = (GPR_S32(ctx, 2) <= 0);
        if (branch_taken_0x17b430) {
            ctx->pc = 0x17B668u;
            goto label_17b668;
        }
    }
    ctx->pc = 0x17B438u;
    // 0x17b438: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17b438u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17b43c: 0x24020014  addiu       $v0, $zero, 0x14
    ctx->pc = 0x17b43cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 20));
    // 0x17b440: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17b440u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17b444: 0x0  nop
    ctx->pc = 0x17b444u;
    // NOP
    // 0x17b448: 0x0  nop
    ctx->pc = 0x17b448u;
    // NOP
    // 0x17b44c: 0x1010  mfhi        $v0
    ctx->pc = 0x17b44cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17b450: 0x1440004d  bnez        $v0, . + 4 + (0x4D << 2)
    ctx->pc = 0x17B450u;
    {
        const bool branch_taken_0x17b450 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17b450) {
            ctx->pc = 0x17B588u;
            goto label_17b588;
        }
    }
    ctx->pc = 0x17B458u;
    // 0x17b458: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b458u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b45c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b45cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b460: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b460u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b464: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17b464u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17b468: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b468u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b46c: 0x0  nop
    ctx->pc = 0x17b46cu;
    // NOP
    // 0x17b470: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b470u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b474: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B474u;
    SET_GPR_U32(ctx, 31, 0x17B47Cu);
    ctx->pc = 0x17B478u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B474u;
            // 0x17b478: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B47Cu; }
        if (ctx->pc != 0x17B47Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B47Cu; }
        if (ctx->pc != 0x17B47Cu) { return; }
    }
    ctx->pc = 0x17B47Cu;
    // 0x17b47c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b47cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b480: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b480u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b484: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b484u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b488: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17b488u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17b48c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b48cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b490: 0x0  nop
    ctx->pc = 0x17b490u;
    // NOP
    // 0x17b494: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b494u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b498: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B498u;
    SET_GPR_U32(ctx, 31, 0x17B4A0u);
    ctx->pc = 0x17B49Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B498u;
            // 0x17b49c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B4A0u; }
        if (ctx->pc != 0x17B4A0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B4A0u; }
        if (ctx->pc != 0x17B4A0u) { return; }
    }
    ctx->pc = 0x17B4A0u;
    // 0x17b4a0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b4a0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b4a4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b4a4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b4a8: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b4a8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b4ac: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B4ACu;
    SET_GPR_U32(ctx, 31, 0x17B4B4u);
    ctx->pc = 0x17B4B0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B4ACu;
            // 0x17b4b0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B4B4u; }
        if (ctx->pc != 0x17B4B4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B4B4u; }
        if (ctx->pc != 0x17B4B4u) { return; }
    }
    ctx->pc = 0x17B4B4u;
    // 0x17b4b4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b4b4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b4b8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b4b8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b4bc: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b4bcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b4c0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B4C0u;
    SET_GPR_U32(ctx, 31, 0x17B4C8u);
    ctx->pc = 0x17B4C4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B4C0u;
            // 0x17b4c4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B4C8u; }
        if (ctx->pc != 0x17B4C8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B4C8u; }
        if (ctx->pc != 0x17B4C8u) { return; }
    }
    ctx->pc = 0x17B4C8u;
    // 0x17b4c8: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17b4c8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17b4cc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b4ccu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b4d0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b4d0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b4d4: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17b4d4u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17b4d8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b4d8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b4dc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b4dcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b4e0: 0xc065480  jal         func_195200
    ctx->pc = 0x17B4E0u;
    SET_GPR_U32(ctx, 31, 0x17B4E8u);
    ctx->pc = 0x17B4E4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B4E0u;
            // 0x17b4e4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B4E8u; }
        if (ctx->pc != 0x17B4E8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B4E8u; }
        if (ctx->pc != 0x17B4E8u) { return; }
    }
    ctx->pc = 0x17B4E8u;
    // 0x17b4e8: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17b4e8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17b4ec: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b4ecu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b4f0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b4f0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b4f4: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17b4f4u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17b4f8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b4f8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b4fc: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b4fcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b500: 0xc065480  jal         func_195200
    ctx->pc = 0x17B500u;
    SET_GPR_U32(ctx, 31, 0x17B508u);
    ctx->pc = 0x17B504u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B500u;
            // 0x17b504: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B508u; }
        if (ctx->pc != 0x17B508u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B508u; }
        if (ctx->pc != 0x17B508u) { return; }
    }
    ctx->pc = 0x17B508u;
    // 0x17b508: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17b508u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17b50c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b50cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b510: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b510u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b514: 0x24060005  addiu       $a2, $zero, 0x5
    ctx->pc = 0x17b514u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 5));
    // 0x17b518: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b518u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b51c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b51cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b520: 0xc065480  jal         func_195200
    ctx->pc = 0x17B520u;
    SET_GPR_U32(ctx, 31, 0x17B528u);
    ctx->pc = 0x17B524u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B520u;
            // 0x17b524: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B528u; }
        if (ctx->pc != 0x17B528u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B528u; }
        if (ctx->pc != 0x17B528u) { return; }
    }
    ctx->pc = 0x17B528u;
    // 0x17b528: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17b528u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17b52c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b52cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b530: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b530u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b534: 0x24060073  addiu       $a2, $zero, 0x73
    ctx->pc = 0x17b534u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 115));
    // 0x17b538: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b538u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b53c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b53cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b540: 0xc065480  jal         func_195200
    ctx->pc = 0x17B540u;
    SET_GPR_U32(ctx, 31, 0x17B548u);
    ctx->pc = 0x17B544u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B540u;
            // 0x17b544: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B548u; }
        if (ctx->pc != 0x17B548u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B548u; }
        if (ctx->pc != 0x17B548u) { return; }
    }
    ctx->pc = 0x17B548u;
    // 0x17b548: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17b548u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17b54c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b54cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b550: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b550u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b554: 0x2406000a  addiu       $a2, $zero, 0xA
    ctx->pc = 0x17b554u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 10));
    // 0x17b558: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b558u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b55c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b55cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b560: 0xc065480  jal         func_195200
    ctx->pc = 0x17B560u;
    SET_GPR_U32(ctx, 31, 0x17B568u);
    ctx->pc = 0x17B564u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B560u;
            // 0x17b564: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B568u; }
        if (ctx->pc != 0x17B568u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B568u; }
        if (ctx->pc != 0x17B568u) { return; }
    }
    ctx->pc = 0x17B568u;
    // 0x17b568: 0x3c024020  lui         $v0, 0x4020
    ctx->pc = 0x17b568u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16416 << 16));
    // 0x17b56c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b56cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b570: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b570u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b574: 0x2406006e  addiu       $a2, $zero, 0x6E
    ctx->pc = 0x17b574u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 110));
    // 0x17b578: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b578u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b57c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b57cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b580: 0xc065480  jal         func_195200
    ctx->pc = 0x17B580u;
    SET_GPR_U32(ctx, 31, 0x17B588u);
    ctx->pc = 0x17B584u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B580u;
            // 0x17b584: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B588u; }
        if (ctx->pc != 0x17B588u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B588u; }
        if (ctx->pc != 0x17B588u) { return; }
    }
    ctx->pc = 0x17B588u;
label_17b588:
    // 0x17b588: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17b588u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17b58c: 0x24020028  addiu       $v0, $zero, 0x28
    ctx->pc = 0x17b58cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 40));
    // 0x17b590: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17b590u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17b594: 0x0  nop
    ctx->pc = 0x17b594u;
    // NOP
    // 0x17b598: 0x0  nop
    ctx->pc = 0x17b598u;
    // NOP
    // 0x17b59c: 0x1010  mfhi        $v0
    ctx->pc = 0x17b59cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17b5a0: 0x1440043b  bnez        $v0, . + 4 + (0x43B << 2)
    ctx->pc = 0x17B5A0u;
    {
        const bool branch_taken_0x17b5a0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17b5a0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17B5A8u;
    // 0x17b5a8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b5a8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b5ac: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b5acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b5b0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b5b0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b5b4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B5B4u;
    SET_GPR_U32(ctx, 31, 0x17B5BCu);
    ctx->pc = 0x17B5B8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B5B4u;
            // 0x17b5b8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B5BCu; }
        if (ctx->pc != 0x17B5BCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B5BCu; }
        if (ctx->pc != 0x17B5BCu) { return; }
    }
    ctx->pc = 0x17B5BCu;
    // 0x17b5bc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b5bcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b5c0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b5c0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b5c4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b5c4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b5c8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B5C8u;
    SET_GPR_U32(ctx, 31, 0x17B5D0u);
    ctx->pc = 0x17B5CCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B5C8u;
            // 0x17b5cc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B5D0u; }
        if (ctx->pc != 0x17B5D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B5D0u; }
        if (ctx->pc != 0x17B5D0u) { return; }
    }
    ctx->pc = 0x17B5D0u;
    // 0x17b5d0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b5d0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b5d4: 0x24060073  addiu       $a2, $zero, 0x73
    ctx->pc = 0x17b5d4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 115));
    // 0x17b5d8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b5d8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b5dc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b5dcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b5e0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B5E0u;
    SET_GPR_U32(ctx, 31, 0x17B5E8u);
    ctx->pc = 0x17B5E4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B5E0u;
            // 0x17b5e4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B5E8u; }
        if (ctx->pc != 0x17B5E8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B5E8u; }
        if (ctx->pc != 0x17B5E8u) { return; }
    }
    ctx->pc = 0x17B5E8u;
    // 0x17b5e8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b5e8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b5ec: 0x24060005  addiu       $a2, $zero, 0x5
    ctx->pc = 0x17b5ecu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 5));
    // 0x17b5f0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b5f0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b5f4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b5f4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b5f8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B5F8u;
    SET_GPR_U32(ctx, 31, 0x17B600u);
    ctx->pc = 0x17B5FCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B5F8u;
            // 0x17b5fc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B600u; }
        if (ctx->pc != 0x17B600u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B600u; }
        if (ctx->pc != 0x17B600u) { return; }
    }
    ctx->pc = 0x17B600u;
    // 0x17b600: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b600u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b604: 0x2406006e  addiu       $a2, $zero, 0x6E
    ctx->pc = 0x17b604u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 110));
    // 0x17b608: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b608u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b60c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b60cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b610: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B610u;
    SET_GPR_U32(ctx, 31, 0x17B618u);
    ctx->pc = 0x17B614u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B610u;
            // 0x17b614: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B618u; }
        if (ctx->pc != 0x17B618u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B618u; }
        if (ctx->pc != 0x17B618u) { return; }
    }
    ctx->pc = 0x17B618u;
    // 0x17b618: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b618u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b61c: 0x2406000a  addiu       $a2, $zero, 0xA
    ctx->pc = 0x17b61cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 10));
    // 0x17b620: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b620u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b624: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b624u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b628: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B628u;
    SET_GPR_U32(ctx, 31, 0x17B630u);
    ctx->pc = 0x17B62Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B628u;
            // 0x17b62c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B630u; }
        if (ctx->pc != 0x17B630u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B630u; }
        if (ctx->pc != 0x17B630u) { return; }
    }
    ctx->pc = 0x17B630u;
    // 0x17b630: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b630u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b634: 0x24060069  addiu       $a2, $zero, 0x69
    ctx->pc = 0x17b634u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 105));
    // 0x17b638: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b638u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b63c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b63cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b640: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B640u;
    SET_GPR_U32(ctx, 31, 0x17B648u);
    ctx->pc = 0x17B644u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B640u;
            // 0x17b644: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B648u; }
        if (ctx->pc != 0x17B648u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B648u; }
        if (ctx->pc != 0x17B648u) { return; }
    }
    ctx->pc = 0x17B648u;
    // 0x17b648: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b648u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b64c: 0x2406000f  addiu       $a2, $zero, 0xF
    ctx->pc = 0x17b64cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 15));
    // 0x17b650: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b650u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b654: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b654u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b658: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B658u;
    SET_GPR_U32(ctx, 31, 0x17B660u);
    ctx->pc = 0x17B65Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B658u;
            // 0x17b65c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B660u; }
        if (ctx->pc != 0x17B660u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B660u; }
        if (ctx->pc != 0x17B660u) { return; }
    }
    ctx->pc = 0x17B660u;
    // 0x17b660: 0x1000040b  b           . + 4 + (0x40B << 2)
    ctx->pc = 0x17B660u;
    {
        const bool branch_taken_0x17b660 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17b660) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17B668u;
label_17b668:
    // 0x17b668: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17b668u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17b66c: 0x24020028  addiu       $v0, $zero, 0x28
    ctx->pc = 0x17b66cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 40));
    // 0x17b670: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17b670u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17b674: 0x0  nop
    ctx->pc = 0x17b674u;
    // NOP
    // 0x17b678: 0x0  nop
    ctx->pc = 0x17b678u;
    // NOP
    // 0x17b67c: 0x1010  mfhi        $v0
    ctx->pc = 0x17b67cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17b680: 0x1440003d  bnez        $v0, . + 4 + (0x3D << 2)
    ctx->pc = 0x17B680u;
    {
        const bool branch_taken_0x17b680 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17b680) {
            ctx->pc = 0x17B778u;
            goto label_17b778;
        }
    }
    ctx->pc = 0x17B688u;
    // 0x17b688: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b688u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b68c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b68cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b690: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b690u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b694: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17b694u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17b698: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b698u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b69c: 0x0  nop
    ctx->pc = 0x17b69cu;
    // NOP
    // 0x17b6a0: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b6a0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b6a4: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B6A4u;
    SET_GPR_U32(ctx, 31, 0x17B6ACu);
    ctx->pc = 0x17B6A8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B6A4u;
            // 0x17b6a8: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B6ACu; }
        if (ctx->pc != 0x17B6ACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B6ACu; }
        if (ctx->pc != 0x17B6ACu) { return; }
    }
    ctx->pc = 0x17B6ACu;
    // 0x17b6ac: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b6acu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b6b0: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b6b0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b6b4: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b6b4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b6b8: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17b6b8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17b6bc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b6bcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b6c0: 0x0  nop
    ctx->pc = 0x17b6c0u;
    // NOP
    // 0x17b6c4: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b6c4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b6c8: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B6C8u;
    SET_GPR_U32(ctx, 31, 0x17B6D0u);
    ctx->pc = 0x17B6CCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B6C8u;
            // 0x17b6cc: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B6D0u; }
        if (ctx->pc != 0x17B6D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B6D0u; }
        if (ctx->pc != 0x17B6D0u) { return; }
    }
    ctx->pc = 0x17B6D0u;
    // 0x17b6d0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b6d0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b6d4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b6d4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b6d8: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b6d8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b6dc: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B6DCu;
    SET_GPR_U32(ctx, 31, 0x17B6E4u);
    ctx->pc = 0x17B6E0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B6DCu;
            // 0x17b6e0: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B6E4u; }
        if (ctx->pc != 0x17B6E4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B6E4u; }
        if (ctx->pc != 0x17B6E4u) { return; }
    }
    ctx->pc = 0x17B6E4u;
    // 0x17b6e4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b6e4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b6e8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b6e8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b6ec: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b6ecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b6f0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B6F0u;
    SET_GPR_U32(ctx, 31, 0x17B6F8u);
    ctx->pc = 0x17B6F4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B6F0u;
            // 0x17b6f4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B6F8u; }
        if (ctx->pc != 0x17B6F8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B6F8u; }
        if (ctx->pc != 0x17B6F8u) { return; }
    }
    ctx->pc = 0x17B6F8u;
    // 0x17b6f8: 0x3c023fc0  lui         $v0, 0x3FC0
    ctx->pc = 0x17b6f8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16320 << 16));
    // 0x17b6fc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b6fcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b700: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b700u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b704: 0x2406000a  addiu       $a2, $zero, 0xA
    ctx->pc = 0x17b704u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 10));
    // 0x17b708: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b708u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b70c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b70cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b710: 0xc065480  jal         func_195200
    ctx->pc = 0x17B710u;
    SET_GPR_U32(ctx, 31, 0x17B718u);
    ctx->pc = 0x17B714u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B710u;
            // 0x17b714: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B718u; }
        if (ctx->pc != 0x17B718u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B718u; }
        if (ctx->pc != 0x17B718u) { return; }
    }
    ctx->pc = 0x17B718u;
    // 0x17b718: 0x3c023fc0  lui         $v0, 0x3FC0
    ctx->pc = 0x17b718u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16320 << 16));
    // 0x17b71c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b71cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b720: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b720u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b724: 0x2406006e  addiu       $a2, $zero, 0x6E
    ctx->pc = 0x17b724u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 110));
    // 0x17b728: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b728u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b72c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b72cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b730: 0xc065480  jal         func_195200
    ctx->pc = 0x17B730u;
    SET_GPR_U32(ctx, 31, 0x17B738u);
    ctx->pc = 0x17B734u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B730u;
            // 0x17b734: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B738u; }
        if (ctx->pc != 0x17B738u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B738u; }
        if (ctx->pc != 0x17B738u) { return; }
    }
    ctx->pc = 0x17B738u;
    // 0x17b738: 0x3c023fc0  lui         $v0, 0x3FC0
    ctx->pc = 0x17b738u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16320 << 16));
    // 0x17b73c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b73cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b740: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b740u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b744: 0x2406000f  addiu       $a2, $zero, 0xF
    ctx->pc = 0x17b744u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 15));
    // 0x17b748: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b748u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b74c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b74cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b750: 0xc065480  jal         func_195200
    ctx->pc = 0x17B750u;
    SET_GPR_U32(ctx, 31, 0x17B758u);
    ctx->pc = 0x17B754u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B750u;
            // 0x17b754: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B758u; }
        if (ctx->pc != 0x17B758u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B758u; }
        if (ctx->pc != 0x17B758u) { return; }
    }
    ctx->pc = 0x17B758u;
    // 0x17b758: 0x3c023fc0  lui         $v0, 0x3FC0
    ctx->pc = 0x17b758u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16320 << 16));
    // 0x17b75c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b75cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b760: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b760u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b764: 0x24060069  addiu       $a2, $zero, 0x69
    ctx->pc = 0x17b764u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 105));
    // 0x17b768: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b768u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b76c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b76cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b770: 0xc065480  jal         func_195200
    ctx->pc = 0x17B770u;
    SET_GPR_U32(ctx, 31, 0x17B778u);
    ctx->pc = 0x17B774u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B770u;
            // 0x17b774: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B778u; }
        if (ctx->pc != 0x17B778u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B778u; }
        if (ctx->pc != 0x17B778u) { return; }
    }
    ctx->pc = 0x17B778u;
label_17b778:
    // 0x17b778: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17b778u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17b77c: 0x24020050  addiu       $v0, $zero, 0x50
    ctx->pc = 0x17b77cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 80));
    // 0x17b780: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17b780u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17b784: 0x0  nop
    ctx->pc = 0x17b784u;
    // NOP
    // 0x17b788: 0x0  nop
    ctx->pc = 0x17b788u;
    // NOP
    // 0x17b78c: 0x1010  mfhi        $v0
    ctx->pc = 0x17b78cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17b790: 0x144003bf  bnez        $v0, . + 4 + (0x3BF << 2)
    ctx->pc = 0x17B790u;
    {
        const bool branch_taken_0x17b790 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17b790) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17B798u;
    // 0x17b798: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b798u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b79c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b79cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b7a0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b7a0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b7a4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B7A4u;
    SET_GPR_U32(ctx, 31, 0x17B7ACu);
    ctx->pc = 0x17B7A8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B7A4u;
            // 0x17b7a8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B7ACu; }
        if (ctx->pc != 0x17B7ACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B7ACu; }
        if (ctx->pc != 0x17B7ACu) { return; }
    }
    ctx->pc = 0x17B7ACu;
    // 0x17b7ac: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b7acu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b7b0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b7b0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b7b4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b7b4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b7b8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B7B8u;
    SET_GPR_U32(ctx, 31, 0x17B7C0u);
    ctx->pc = 0x17B7BCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B7B8u;
            // 0x17b7bc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B7C0u; }
        if (ctx->pc != 0x17B7C0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B7C0u; }
        if (ctx->pc != 0x17B7C0u) { return; }
    }
    ctx->pc = 0x17B7C0u;
    // 0x17b7c0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b7c0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b7c4: 0x24060069  addiu       $a2, $zero, 0x69
    ctx->pc = 0x17b7c4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 105));
    // 0x17b7c8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b7c8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b7cc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b7ccu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b7d0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B7D0u;
    SET_GPR_U32(ctx, 31, 0x17B7D8u);
    ctx->pc = 0x17B7D4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B7D0u;
            // 0x17b7d4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B7D8u; }
        if (ctx->pc != 0x17B7D8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B7D8u; }
        if (ctx->pc != 0x17B7D8u) { return; }
    }
    ctx->pc = 0x17B7D8u;
    // 0x17b7d8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b7d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b7dc: 0x2406000f  addiu       $a2, $zero, 0xF
    ctx->pc = 0x17b7dcu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 15));
    // 0x17b7e0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b7e0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b7e4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b7e4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b7e8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B7E8u;
    SET_GPR_U32(ctx, 31, 0x17B7F0u);
    ctx->pc = 0x17B7ECu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B7E8u;
            // 0x17b7ec: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B7F0u; }
        if (ctx->pc != 0x17B7F0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B7F0u; }
        if (ctx->pc != 0x17B7F0u) { return; }
    }
    ctx->pc = 0x17B7F0u;
    // 0x17b7f0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b7f0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b7f4: 0x24060064  addiu       $a2, $zero, 0x64
    ctx->pc = 0x17b7f4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x17b7f8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b7f8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b7fc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b7fcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b800: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B800u;
    SET_GPR_U32(ctx, 31, 0x17B808u);
    ctx->pc = 0x17B804u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B800u;
            // 0x17b804: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B808u; }
        if (ctx->pc != 0x17B808u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B808u; }
        if (ctx->pc != 0x17B808u) { return; }
    }
    ctx->pc = 0x17B808u;
    // 0x17b808: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b808u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b80c: 0x24060014  addiu       $a2, $zero, 0x14
    ctx->pc = 0x17b80cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 20));
    // 0x17b810: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b810u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b814: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b814u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b818: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17B818u;
    SET_GPR_U32(ctx, 31, 0x17B820u);
    ctx->pc = 0x17B81Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B818u;
            // 0x17b81c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B820u; }
        if (ctx->pc != 0x17B820u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B820u; }
        if (ctx->pc != 0x17B820u) { return; }
    }
    ctx->pc = 0x17B820u;
    // 0x17b820: 0x1000039b  b           . + 4 + (0x39B << 2)
    ctx->pc = 0x17B820u;
    {
        const bool branch_taken_0x17b820 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17b820) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17B828u;
label_17b828:
    // 0x17b828: 0xc065d00  jal         func_197400
    ctx->pc = 0x17B828u;
    SET_GPR_U32(ctx, 31, 0x17B830u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B830u; }
        if (ctx->pc != 0x17B830u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B830u; }
        if (ctx->pc != 0x17B830u) { return; }
    }
    ctx->pc = 0x17B830u;
    // 0x17b830: 0x28410002  slti        $at, $v0, 0x2
    ctx->pc = 0x17b830u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 2) < (int64_t)(int32_t)2) ? 1 : 0);
    // 0x17b834: 0x142000f0  bnez        $at, . + 4 + (0xF0 << 2)
    ctx->pc = 0x17B834u;
    {
        const bool branch_taken_0x17b834 = (GPR_U64(ctx, 1) != GPR_U64(ctx, 0));
        if (branch_taken_0x17b834) {
            ctx->pc = 0x17BBF8u;
            goto label_17bbf8;
        }
    }
    ctx->pc = 0x17B83Cu;
    // 0x17b83c: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17b83cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17b840: 0x4610004  bgez        $v1, . + 4 + (0x4 << 2)
    ctx->pc = 0x17B840u;
    {
        const bool branch_taken_0x17b840 = (GPR_S32(ctx, 3) >= 0);
        ctx->pc = 0x17B844u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17B840u;
            // 0x17b844: 0x30620007  andi        $v0, $v1, 0x7 (Delay Slot)
        SET_GPR_VEC(ctx, 2, PS2_PAND(GPR_VEC(ctx, 3), _mm_cvtsi32_si128((int)7u)));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17b840) {
            ctx->pc = 0x17B854u;
            goto label_17b854;
        }
    }
    ctx->pc = 0x17B848u;
    // 0x17b848: 0x10400002  beqz        $v0, . + 4 + (0x2 << 2)
    ctx->pc = 0x17B848u;
    {
        const bool branch_taken_0x17b848 = (GPR_U64(ctx, 2) == GPR_U64(ctx, 0));
        if (branch_taken_0x17b848) {
            ctx->pc = 0x17B854u;
            goto label_17b854;
        }
    }
    ctx->pc = 0x17B850u;
    // 0x17b850: 0x2442fff8  addiu       $v0, $v0, -0x8
    ctx->pc = 0x17b850u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967288));
label_17b854:
    // 0x17b854: 0x1440006e  bnez        $v0, . + 4 + (0x6E << 2)
    ctx->pc = 0x17B854u;
    {
        const bool branch_taken_0x17b854 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17b854) {
            ctx->pc = 0x17BA10u;
            goto label_17ba10;
        }
    }
    ctx->pc = 0x17B85Cu;
    // 0x17b85c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b85cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b860: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b860u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b864: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b864u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b868: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17b868u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17b86c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b86cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b870: 0x0  nop
    ctx->pc = 0x17b870u;
    // NOP
    // 0x17b874: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b874u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b878: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B878u;
    SET_GPR_U32(ctx, 31, 0x17B880u);
    ctx->pc = 0x17B87Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B878u;
            // 0x17b87c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B880u; }
        if (ctx->pc != 0x17B880u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B880u; }
        if (ctx->pc != 0x17B880u) { return; }
    }
    ctx->pc = 0x17B880u;
    // 0x17b880: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17b880u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b884: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17b884u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17b888: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17b888u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17b88c: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17b88cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17b890: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17b890u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17b894: 0x0  nop
    ctx->pc = 0x17b894u;
    // NOP
    // 0x17b898: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17b898u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17b89c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17B89Cu;
    SET_GPR_U32(ctx, 31, 0x17B8A4u);
    ctx->pc = 0x17B8A0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B89Cu;
            // 0x17b8a0: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B8A4u; }
        if (ctx->pc != 0x17B8A4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B8A4u; }
        if (ctx->pc != 0x17B8A4u) { return; }
    }
    ctx->pc = 0x17B8A4u;
    // 0x17b8a4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b8a4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b8a8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b8a8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b8ac: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b8acu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b8b0: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B8B0u;
    SET_GPR_U32(ctx, 31, 0x17B8B8u);
    ctx->pc = 0x17B8B4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B8B0u;
            // 0x17b8b4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B8B8u; }
        if (ctx->pc != 0x17B8B8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B8B8u; }
        if (ctx->pc != 0x17B8B8u) { return; }
    }
    ctx->pc = 0x17B8B8u;
    // 0x17b8b8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b8b8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b8bc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b8bcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b8c0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b8c0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b8c4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17B8C4u;
    SET_GPR_U32(ctx, 31, 0x17B8CCu);
    ctx->pc = 0x17B8C8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B8C4u;
            // 0x17b8c8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B8CCu; }
        if (ctx->pc != 0x17B8CCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B8CCu; }
        if (ctx->pc != 0x17B8CCu) { return; }
    }
    ctx->pc = 0x17B8CCu;
    // 0x17b8cc: 0x3c024080  lui         $v0, 0x4080
    ctx->pc = 0x17b8ccu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16512 << 16));
    // 0x17b8d0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b8d0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b8d4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b8d4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b8d8: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17b8d8u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17b8dc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b8dcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b8e0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b8e0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b8e4: 0xc065480  jal         func_195200
    ctx->pc = 0x17B8E4u;
    SET_GPR_U32(ctx, 31, 0x17B8ECu);
    ctx->pc = 0x17B8E8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B8E4u;
            // 0x17b8e8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B8ECu; }
        if (ctx->pc != 0x17B8ECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B8ECu; }
        if (ctx->pc != 0x17B8ECu) { return; }
    }
    ctx->pc = 0x17B8ECu;
    // 0x17b8ec: 0x3c024080  lui         $v0, 0x4080
    ctx->pc = 0x17b8ecu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16512 << 16));
    // 0x17b8f0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b8f0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b8f4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b8f4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b8f8: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17b8f8u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17b8fc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b8fcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b900: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b900u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b904: 0xc065480  jal         func_195200
    ctx->pc = 0x17B904u;
    SET_GPR_U32(ctx, 31, 0x17B90Cu);
    ctx->pc = 0x17B908u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B904u;
            // 0x17b908: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B90Cu; }
        if (ctx->pc != 0x17B90Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B90Cu; }
        if (ctx->pc != 0x17B90Cu) { return; }
    }
    ctx->pc = 0x17B90Cu;
    // 0x17b90c: 0x3c024080  lui         $v0, 0x4080
    ctx->pc = 0x17b90cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16512 << 16));
    // 0x17b910: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b910u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b914: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b914u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b918: 0x24060004  addiu       $a2, $zero, 0x4
    ctx->pc = 0x17b918u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 4));
    // 0x17b91c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b91cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b920: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b920u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b924: 0xc065480  jal         func_195200
    ctx->pc = 0x17B924u;
    SET_GPR_U32(ctx, 31, 0x17B92Cu);
    ctx->pc = 0x17B928u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B924u;
            // 0x17b928: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B92Cu; }
        if (ctx->pc != 0x17B92Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B92Cu; }
        if (ctx->pc != 0x17B92Cu) { return; }
    }
    ctx->pc = 0x17B92Cu;
    // 0x17b92c: 0x3c024080  lui         $v0, 0x4080
    ctx->pc = 0x17b92cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16512 << 16));
    // 0x17b930: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b930u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b934: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b934u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b938: 0x24060074  addiu       $a2, $zero, 0x74
    ctx->pc = 0x17b938u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 116));
    // 0x17b93c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b93cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b940: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b940u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b944: 0xc065480  jal         func_195200
    ctx->pc = 0x17B944u;
    SET_GPR_U32(ctx, 31, 0x17B94Cu);
    ctx->pc = 0x17B948u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B944u;
            // 0x17b948: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B94Cu; }
        if (ctx->pc != 0x17B94Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B94Cu; }
        if (ctx->pc != 0x17B94Cu) { return; }
    }
    ctx->pc = 0x17B94Cu;
    // 0x17b94c: 0x3c024080  lui         $v0, 0x4080
    ctx->pc = 0x17b94cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16512 << 16));
    // 0x17b950: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b950u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b954: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b954u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b958: 0x24060008  addiu       $a2, $zero, 0x8
    ctx->pc = 0x17b958u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 8));
    // 0x17b95c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b95cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b960: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b960u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b964: 0xc065480  jal         func_195200
    ctx->pc = 0x17B964u;
    SET_GPR_U32(ctx, 31, 0x17B96Cu);
    ctx->pc = 0x17B968u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B964u;
            // 0x17b968: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B96Cu; }
        if (ctx->pc != 0x17B96Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B96Cu; }
        if (ctx->pc != 0x17B96Cu) { return; }
    }
    ctx->pc = 0x17B96Cu;
    // 0x17b96c: 0x3c024080  lui         $v0, 0x4080
    ctx->pc = 0x17b96cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16512 << 16));
    // 0x17b970: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b970u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b974: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b974u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b978: 0x24060070  addiu       $a2, $zero, 0x70
    ctx->pc = 0x17b978u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 112));
    // 0x17b97c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b97cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b980: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b980u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b984: 0xc065480  jal         func_195200
    ctx->pc = 0x17B984u;
    SET_GPR_U32(ctx, 31, 0x17B98Cu);
    ctx->pc = 0x17B988u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B984u;
            // 0x17b988: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B98Cu; }
        if (ctx->pc != 0x17B98Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B98Cu; }
        if (ctx->pc != 0x17B98Cu) { return; }
    }
    ctx->pc = 0x17B98Cu;
    // 0x17b98c: 0x3c024080  lui         $v0, 0x4080
    ctx->pc = 0x17b98cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16512 << 16));
    // 0x17b990: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b990u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b994: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b994u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b998: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17b998u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17b99c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b99cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b9a0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b9a0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b9a4: 0xc065480  jal         func_195200
    ctx->pc = 0x17B9A4u;
    SET_GPR_U32(ctx, 31, 0x17B9ACu);
    ctx->pc = 0x17B9A8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B9A4u;
            // 0x17b9a8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B9ACu; }
        if (ctx->pc != 0x17B9ACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B9ACu; }
        if (ctx->pc != 0x17B9ACu) { return; }
    }
    ctx->pc = 0x17B9ACu;
    // 0x17b9ac: 0x3c024080  lui         $v0, 0x4080
    ctx->pc = 0x17b9acu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16512 << 16));
    // 0x17b9b0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b9b0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b9b4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b9b4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b9b8: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17b9b8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17b9bc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b9bcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b9c0: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17b9c0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17b9c4: 0xc065480  jal         func_195200
    ctx->pc = 0x17B9C4u;
    SET_GPR_U32(ctx, 31, 0x17B9CCu);
    ctx->pc = 0x17B9C8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B9C4u;
            // 0x17b9c8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B9CCu; }
        if (ctx->pc != 0x17B9CCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B9CCu; }
        if (ctx->pc != 0x17B9CCu) { return; }
    }
    ctx->pc = 0x17B9CCu;
    // 0x17b9cc: 0x3c024080  lui         $v0, 0x4080
    ctx->pc = 0x17b9ccu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16512 << 16));
    // 0x17b9d0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b9d0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b9d4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b9d4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b9d8: 0x24060010  addiu       $a2, $zero, 0x10
    ctx->pc = 0x17b9d8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 16));
    // 0x17b9dc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b9dcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17b9e0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17b9e0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17b9e4: 0xc065480  jal         func_195200
    ctx->pc = 0x17B9E4u;
    SET_GPR_U32(ctx, 31, 0x17B9ECu);
    ctx->pc = 0x17B9E8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17B9E4u;
            // 0x17b9e8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B9ECu; }
        if (ctx->pc != 0x17B9ECu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17B9ECu; }
        if (ctx->pc != 0x17B9ECu) { return; }
    }
    ctx->pc = 0x17B9ECu;
    // 0x17b9ec: 0x3c024080  lui         $v0, 0x4080
    ctx->pc = 0x17b9ecu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16512 << 16));
    // 0x17b9f0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17b9f0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17b9f4: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17b9f4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17b9f8: 0x24060068  addiu       $a2, $zero, 0x68
    ctx->pc = 0x17b9f8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 104));
    // 0x17b9fc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17b9fcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ba00: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17ba00u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17ba04: 0xc065480  jal         func_195200
    ctx->pc = 0x17BA04u;
    SET_GPR_U32(ctx, 31, 0x17BA0Cu);
    ctx->pc = 0x17BA08u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BA04u;
            // 0x17ba08: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BA0Cu; }
        if (ctx->pc != 0x17BA0Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BA0Cu; }
        if (ctx->pc != 0x17BA0Cu) { return; }
    }
    ctx->pc = 0x17BA0Cu;
    // 0x17ba0c: 0x0  nop
    ctx->pc = 0x17ba0cu;
    // NOP
label_17ba10:
    // 0x17ba10: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17ba10u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17ba14: 0x2402000c  addiu       $v0, $zero, 0xC
    ctx->pc = 0x17ba14u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17ba18: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17ba18u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17ba1c: 0x0  nop
    ctx->pc = 0x17ba1cu;
    // NOP
    // 0x17ba20: 0x0  nop
    ctx->pc = 0x17ba20u;
    // NOP
    // 0x17ba24: 0x1010  mfhi        $v0
    ctx->pc = 0x17ba24u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17ba28: 0x14400319  bnez        $v0, . + 4 + (0x319 << 2)
    ctx->pc = 0x17BA28u;
    {
        const bool branch_taken_0x17ba28 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17ba28) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17BA30u;
    // 0x17ba30: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17ba30u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ba34: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17ba34u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17ba38: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17ba38u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17ba3c: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17ba3cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17ba40: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17ba40u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17ba44: 0x0  nop
    ctx->pc = 0x17ba44u;
    // NOP
    // 0x17ba48: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17ba48u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17ba4c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17BA4Cu;
    SET_GPR_U32(ctx, 31, 0x17BA54u);
    ctx->pc = 0x17BA50u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BA4Cu;
            // 0x17ba50: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BA54u; }
        if (ctx->pc != 0x17BA54u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BA54u; }
        if (ctx->pc != 0x17BA54u) { return; }
    }
    ctx->pc = 0x17BA54u;
    // 0x17ba54: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17ba54u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ba58: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17ba58u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17ba5c: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17ba5cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17ba60: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17ba60u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17ba64: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17ba64u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17ba68: 0x0  nop
    ctx->pc = 0x17ba68u;
    // NOP
    // 0x17ba6c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17ba6cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17ba70: 0xc05d080  jal         func_174200
    ctx->pc = 0x17BA70u;
    SET_GPR_U32(ctx, 31, 0x17BA78u);
    ctx->pc = 0x17BA74u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BA70u;
            // 0x17ba74: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BA78u; }
        if (ctx->pc != 0x17BA78u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BA78u; }
        if (ctx->pc != 0x17BA78u) { return; }
    }
    ctx->pc = 0x17BA78u;
    // 0x17ba78: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ba78u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ba7c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ba7cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ba80: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17ba80u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17ba84: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17BA84u;
    SET_GPR_U32(ctx, 31, 0x17BA8Cu);
    ctx->pc = 0x17BA88u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BA84u;
            // 0x17ba88: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BA8Cu; }
        if (ctx->pc != 0x17BA8Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BA8Cu; }
        if (ctx->pc != 0x17BA8Cu) { return; }
    }
    ctx->pc = 0x17BA8Cu;
    // 0x17ba8c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17ba8cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ba90: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ba90u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ba94: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17ba94u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17ba98: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17BA98u;
    SET_GPR_U32(ctx, 31, 0x17BAA0u);
    ctx->pc = 0x17BA9Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BA98u;
            // 0x17ba9c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BAA0u; }
        if (ctx->pc != 0x17BAA0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BAA0u; }
        if (ctx->pc != 0x17BAA0u) { return; }
    }
    ctx->pc = 0x17BAA0u;
    // 0x17baa0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17baa0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17baa4: 0x24060074  addiu       $a2, $zero, 0x74
    ctx->pc = 0x17baa4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 116));
    // 0x17baa8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17baa8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17baac: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17baacu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bab0: 0xc065508  jal         func_195420
    ctx->pc = 0x17BAB0u;
    SET_GPR_U32(ctx, 31, 0x17BAB8u);
    ctx->pc = 0x17BAB4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BAB0u;
            // 0x17bab4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BAB8u; }
        if (ctx->pc != 0x17BAB8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BAB8u; }
        if (ctx->pc != 0x17BAB8u) { return; }
    }
    ctx->pc = 0x17BAB8u;
    // 0x17bab8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bab8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17babc: 0x24060004  addiu       $a2, $zero, 0x4
    ctx->pc = 0x17babcu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 4));
    // 0x17bac0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bac0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bac4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bac4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bac8: 0xc065508  jal         func_195420
    ctx->pc = 0x17BAC8u;
    SET_GPR_U32(ctx, 31, 0x17BAD0u);
    ctx->pc = 0x17BACCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BAC8u;
            // 0x17bacc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BAD0u; }
        if (ctx->pc != 0x17BAD0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BAD0u; }
        if (ctx->pc != 0x17BAD0u) { return; }
    }
    ctx->pc = 0x17BAD0u;
    // 0x17bad0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bad0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bad4: 0x24060070  addiu       $a2, $zero, 0x70
    ctx->pc = 0x17bad4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 112));
    // 0x17bad8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bad8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17badc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17badcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bae0: 0xc065508  jal         func_195420
    ctx->pc = 0x17BAE0u;
    SET_GPR_U32(ctx, 31, 0x17BAE8u);
    ctx->pc = 0x17BAE4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BAE0u;
            // 0x17bae4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BAE8u; }
        if (ctx->pc != 0x17BAE8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BAE8u; }
        if (ctx->pc != 0x17BAE8u) { return; }
    }
    ctx->pc = 0x17BAE8u;
    // 0x17bae8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bae8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17baec: 0x24060008  addiu       $a2, $zero, 0x8
    ctx->pc = 0x17baecu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 8));
    // 0x17baf0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17baf0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17baf4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17baf4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17baf8: 0xc065508  jal         func_195420
    ctx->pc = 0x17BAF8u;
    SET_GPR_U32(ctx, 31, 0x17BB00u);
    ctx->pc = 0x17BAFCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BAF8u;
            // 0x17bafc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB00u; }
        if (ctx->pc != 0x17BB00u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB00u; }
        if (ctx->pc != 0x17BB00u) { return; }
    }
    ctx->pc = 0x17BB00u;
    // 0x17bb00: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bb00u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bb04: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17bb04u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17bb08: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bb08u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bb0c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bb0cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bb10: 0xc065508  jal         func_195420
    ctx->pc = 0x17BB10u;
    SET_GPR_U32(ctx, 31, 0x17BB18u);
    ctx->pc = 0x17BB14u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BB10u;
            // 0x17bb14: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB18u; }
        if (ctx->pc != 0x17BB18u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB18u; }
        if (ctx->pc != 0x17BB18u) { return; }
    }
    ctx->pc = 0x17BB18u;
    // 0x17bb18: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bb18u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bb1c: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17bb1cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17bb20: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bb20u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bb24: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bb24u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bb28: 0xc065508  jal         func_195420
    ctx->pc = 0x17BB28u;
    SET_GPR_U32(ctx, 31, 0x17BB30u);
    ctx->pc = 0x17BB2Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BB28u;
            // 0x17bb2c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB30u; }
        if (ctx->pc != 0x17BB30u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB30u; }
        if (ctx->pc != 0x17BB30u) { return; }
    }
    ctx->pc = 0x17BB30u;
    // 0x17bb30: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bb30u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bb34: 0x24060068  addiu       $a2, $zero, 0x68
    ctx->pc = 0x17bb34u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 104));
    // 0x17bb38: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bb38u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bb3c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bb3cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bb40: 0xc065508  jal         func_195420
    ctx->pc = 0x17BB40u;
    SET_GPR_U32(ctx, 31, 0x17BB48u);
    ctx->pc = 0x17BB44u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BB40u;
            // 0x17bb44: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB48u; }
        if (ctx->pc != 0x17BB48u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB48u; }
        if (ctx->pc != 0x17BB48u) { return; }
    }
    ctx->pc = 0x17BB48u;
    // 0x17bb48: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bb48u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bb4c: 0x24060010  addiu       $a2, $zero, 0x10
    ctx->pc = 0x17bb4cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 16));
    // 0x17bb50: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bb50u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bb54: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bb54u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bb58: 0xc065508  jal         func_195420
    ctx->pc = 0x17BB58u;
    SET_GPR_U32(ctx, 31, 0x17BB60u);
    ctx->pc = 0x17BB5Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BB58u;
            // 0x17bb5c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB60u; }
        if (ctx->pc != 0x17BB60u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB60u; }
        if (ctx->pc != 0x17BB60u) { return; }
    }
    ctx->pc = 0x17BB60u;
    // 0x17bb60: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bb60u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bb64: 0x24060064  addiu       $a2, $zero, 0x64
    ctx->pc = 0x17bb64u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 100));
    // 0x17bb68: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bb68u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bb6c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bb6cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bb70: 0xc065508  jal         func_195420
    ctx->pc = 0x17BB70u;
    SET_GPR_U32(ctx, 31, 0x17BB78u);
    ctx->pc = 0x17BB74u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BB70u;
            // 0x17bb74: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB78u; }
        if (ctx->pc != 0x17BB78u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB78u; }
        if (ctx->pc != 0x17BB78u) { return; }
    }
    ctx->pc = 0x17BB78u;
    // 0x17bb78: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bb78u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bb7c: 0x24060014  addiu       $a2, $zero, 0x14
    ctx->pc = 0x17bb7cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 20));
    // 0x17bb80: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bb80u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bb84: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bb84u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bb88: 0xc065508  jal         func_195420
    ctx->pc = 0x17BB88u;
    SET_GPR_U32(ctx, 31, 0x17BB90u);
    ctx->pc = 0x17BB8Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BB88u;
            // 0x17bb8c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB90u; }
        if (ctx->pc != 0x17BB90u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BB90u; }
        if (ctx->pc != 0x17BB90u) { return; }
    }
    ctx->pc = 0x17BB90u;
    // 0x17bb90: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bb90u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bb94: 0x24060060  addiu       $a2, $zero, 0x60
    ctx->pc = 0x17bb94u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 96));
    // 0x17bb98: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bb98u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bb9c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bb9cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bba0: 0xc065508  jal         func_195420
    ctx->pc = 0x17BBA0u;
    SET_GPR_U32(ctx, 31, 0x17BBA8u);
    ctx->pc = 0x17BBA4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BBA0u;
            // 0x17bba4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BBA8u; }
        if (ctx->pc != 0x17BBA8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BBA8u; }
        if (ctx->pc != 0x17BBA8u) { return; }
    }
    ctx->pc = 0x17BBA8u;
    // 0x17bba8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bba8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bbac: 0x24060018  addiu       $a2, $zero, 0x18
    ctx->pc = 0x17bbacu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 24));
    // 0x17bbb0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bbb0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bbb4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bbb4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bbb8: 0xc065508  jal         func_195420
    ctx->pc = 0x17BBB8u;
    SET_GPR_U32(ctx, 31, 0x17BBC0u);
    ctx->pc = 0x17BBBCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BBB8u;
            // 0x17bbbc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BBC0u; }
        if (ctx->pc != 0x17BBC0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BBC0u; }
        if (ctx->pc != 0x17BBC0u) { return; }
    }
    ctx->pc = 0x17BBC0u;
    // 0x17bbc0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bbc0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bbc4: 0x2406005c  addiu       $a2, $zero, 0x5C
    ctx->pc = 0x17bbc4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 92));
    // 0x17bbc8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bbc8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bbcc: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bbccu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bbd0: 0xc065508  jal         func_195420
    ctx->pc = 0x17BBD0u;
    SET_GPR_U32(ctx, 31, 0x17BBD8u);
    ctx->pc = 0x17BBD4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BBD0u;
            // 0x17bbd4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BBD8u; }
        if (ctx->pc != 0x17BBD8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BBD8u; }
        if (ctx->pc != 0x17BBD8u) { return; }
    }
    ctx->pc = 0x17BBD8u;
    // 0x17bbd8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bbd8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bbdc: 0x2406001c  addiu       $a2, $zero, 0x1C
    ctx->pc = 0x17bbdcu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 28));
    // 0x17bbe0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bbe0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bbe4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bbe4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bbe8: 0xc065508  jal         func_195420
    ctx->pc = 0x17BBE8u;
    SET_GPR_U32(ctx, 31, 0x17BBF0u);
    ctx->pc = 0x17BBECu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BBE8u;
            // 0x17bbec: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195420u;
    if (runtime->hasFunction(0x195420u)) {
        auto targetFn = runtime->lookupFunction(0x195420u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BBF0u; }
        if (ctx->pc != 0x17BBF0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_0x195420(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BBF0u; }
        if (ctx->pc != 0x17BBF0u) { return; }
    }
    ctx->pc = 0x17BBF0u;
    // 0x17bbf0: 0x100002a7  b           . + 4 + (0x2A7 << 2)
    ctx->pc = 0x17BBF0u;
    {
        const bool branch_taken_0x17bbf0 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17bbf0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17BBF8u;
label_17bbf8:
    // 0x17bbf8: 0xc065d00  jal         func_197400
    ctx->pc = 0x17BBF8u;
    SET_GPR_U32(ctx, 31, 0x17BC00u);
    ctx->pc = 0x197400u;
    if (runtime->hasFunction(0x197400u)) {
        auto targetFn = runtime->lookupFunction(0x197400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BC00u; }
        if (ctx->pc != 0x17BC00u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        GetDifficulty_0x197400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BC00u; }
        if (ctx->pc != 0x17BC00u) { return; }
    }
    ctx->pc = 0x17BC00u;
    // 0x17bc00: 0x184000cb  blez        $v0, . + 4 + (0xCB << 2)
    ctx->pc = 0x17BC00u;
    {
        const bool branch_taken_0x17bc00 = (GPR_S32(ctx, 2) <= 0);
        if (branch_taken_0x17bc00) {
            ctx->pc = 0x17BF30u;
            goto label_17bf30;
        }
    }
    ctx->pc = 0x17BC08u;
    // 0x17bc08: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17bc08u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17bc0c: 0x24020018  addiu       $v0, $zero, 0x18
    ctx->pc = 0x17bc0cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 24));
    // 0x17bc10: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17bc10u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17bc14: 0x0  nop
    ctx->pc = 0x17bc14u;
    // NOP
    // 0x17bc18: 0x0  nop
    ctx->pc = 0x17bc18u;
    // NOP
    // 0x17bc1c: 0x1010  mfhi        $v0
    ctx->pc = 0x17bc1cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17bc20: 0x1440006d  bnez        $v0, . + 4 + (0x6D << 2)
    ctx->pc = 0x17BC20u;
    {
        const bool branch_taken_0x17bc20 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17bc20) {
            ctx->pc = 0x17BDD8u;
            goto label_17bdd8;
        }
    }
    ctx->pc = 0x17BC28u;
    // 0x17bc28: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17bc28u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bc2c: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17bc2cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17bc30: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17bc30u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17bc34: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17bc34u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17bc38: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17bc38u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17bc3c: 0x0  nop
    ctx->pc = 0x17bc3cu;
    // NOP
    // 0x17bc40: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17bc40u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17bc44: 0xc05d080  jal         func_174200
    ctx->pc = 0x17BC44u;
    SET_GPR_U32(ctx, 31, 0x17BC4Cu);
    ctx->pc = 0x17BC48u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BC44u;
            // 0x17bc48: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BC4Cu; }
        if (ctx->pc != 0x17BC4Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BC4Cu; }
        if (ctx->pc != 0x17BC4Cu) { return; }
    }
    ctx->pc = 0x17BC4Cu;
    // 0x17bc4c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17bc4cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bc50: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17bc50u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17bc54: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17bc54u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17bc58: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17bc58u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17bc5c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17bc5cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17bc60: 0x0  nop
    ctx->pc = 0x17bc60u;
    // NOP
    // 0x17bc64: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17bc64u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17bc68: 0xc05d080  jal         func_174200
    ctx->pc = 0x17BC68u;
    SET_GPR_U32(ctx, 31, 0x17BC70u);
    ctx->pc = 0x17BC6Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BC68u;
            // 0x17bc6c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BC70u; }
        if (ctx->pc != 0x17BC70u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BC70u; }
        if (ctx->pc != 0x17BC70u) { return; }
    }
    ctx->pc = 0x17BC70u;
    // 0x17bc70: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bc70u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bc74: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bc74u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bc78: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bc78u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bc7c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17BC7Cu;
    SET_GPR_U32(ctx, 31, 0x17BC84u);
    ctx->pc = 0x17BC80u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BC7Cu;
            // 0x17bc80: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BC84u; }
        if (ctx->pc != 0x17BC84u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BC84u; }
        if (ctx->pc != 0x17BC84u) { return; }
    }
    ctx->pc = 0x17BC84u;
    // 0x17bc84: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bc84u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bc88: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bc88u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bc8c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bc8cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bc90: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17BC90u;
    SET_GPR_U32(ctx, 31, 0x17BC98u);
    ctx->pc = 0x17BC94u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BC90u;
            // 0x17bc94: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BC98u; }
        if (ctx->pc != 0x17BC98u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BC98u; }
        if (ctx->pc != 0x17BC98u) { return; }
    }
    ctx->pc = 0x17BC98u;
    // 0x17bc98: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17bc98u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17bc9c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bc9cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bca0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bca0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bca4: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17bca4u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17bca8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bca8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bcac: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bcacu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bcb0: 0xc065480  jal         func_195200
    ctx->pc = 0x17BCB0u;
    SET_GPR_U32(ctx, 31, 0x17BCB8u);
    ctx->pc = 0x17BCB4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BCB0u;
            // 0x17bcb4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BCB8u; }
        if (ctx->pc != 0x17BCB8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BCB8u; }
        if (ctx->pc != 0x17BCB8u) { return; }
    }
    ctx->pc = 0x17BCB8u;
    // 0x17bcb8: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17bcb8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17bcbc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bcbcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bcc0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bcc0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bcc4: 0x302d  daddu       $a2, $zero, $zero
    ctx->pc = 0x17bcc4u;
    SET_GPR_U64(ctx, 6, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17bcc8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bcc8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bccc: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bcccu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bcd0: 0xc065480  jal         func_195200
    ctx->pc = 0x17BCD0u;
    SET_GPR_U32(ctx, 31, 0x17BCD8u);
    ctx->pc = 0x17BCD4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BCD0u;
            // 0x17bcd4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BCD8u; }
        if (ctx->pc != 0x17BCD8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BCD8u; }
        if (ctx->pc != 0x17BCD8u) { return; }
    }
    ctx->pc = 0x17BCD8u;
    // 0x17bcd8: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17bcd8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17bcdc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bcdcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bce0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bce0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bce4: 0x24060004  addiu       $a2, $zero, 0x4
    ctx->pc = 0x17bce4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 4));
    // 0x17bce8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bce8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bcec: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bcecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bcf0: 0xc065480  jal         func_195200
    ctx->pc = 0x17BCF0u;
    SET_GPR_U32(ctx, 31, 0x17BCF8u);
    ctx->pc = 0x17BCF4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BCF0u;
            // 0x17bcf4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BCF8u; }
        if (ctx->pc != 0x17BCF8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BCF8u; }
        if (ctx->pc != 0x17BCF8u) { return; }
    }
    ctx->pc = 0x17BCF8u;
    // 0x17bcf8: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17bcf8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17bcfc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bcfcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bd00: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bd00u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bd04: 0x24060074  addiu       $a2, $zero, 0x74
    ctx->pc = 0x17bd04u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 116));
    // 0x17bd08: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bd08u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bd0c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bd0cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bd10: 0xc065480  jal         func_195200
    ctx->pc = 0x17BD10u;
    SET_GPR_U32(ctx, 31, 0x17BD18u);
    ctx->pc = 0x17BD14u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BD10u;
            // 0x17bd14: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BD18u; }
        if (ctx->pc != 0x17BD18u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BD18u; }
        if (ctx->pc != 0x17BD18u) { return; }
    }
    ctx->pc = 0x17BD18u;
    // 0x17bd18: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17bd18u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17bd1c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bd1cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bd20: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bd20u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bd24: 0x24060008  addiu       $a2, $zero, 0x8
    ctx->pc = 0x17bd24u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 8));
    // 0x17bd28: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bd28u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bd2c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bd2cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bd30: 0xc065480  jal         func_195200
    ctx->pc = 0x17BD30u;
    SET_GPR_U32(ctx, 31, 0x17BD38u);
    ctx->pc = 0x17BD34u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BD30u;
            // 0x17bd34: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BD38u; }
        if (ctx->pc != 0x17BD38u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BD38u; }
        if (ctx->pc != 0x17BD38u) { return; }
    }
    ctx->pc = 0x17BD38u;
    // 0x17bd38: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17bd38u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17bd3c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bd3cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bd40: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bd40u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bd44: 0x24060070  addiu       $a2, $zero, 0x70
    ctx->pc = 0x17bd44u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 112));
    // 0x17bd48: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bd48u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bd4c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bd4cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bd50: 0xc065480  jal         func_195200
    ctx->pc = 0x17BD50u;
    SET_GPR_U32(ctx, 31, 0x17BD58u);
    ctx->pc = 0x17BD54u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BD50u;
            // 0x17bd54: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BD58u; }
        if (ctx->pc != 0x17BD58u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BD58u; }
        if (ctx->pc != 0x17BD58u) { return; }
    }
    ctx->pc = 0x17BD58u;
    // 0x17bd58: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17bd58u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17bd5c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bd5cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bd60: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bd60u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bd64: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17bd64u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17bd68: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bd68u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bd6c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bd6cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bd70: 0xc065480  jal         func_195200
    ctx->pc = 0x17BD70u;
    SET_GPR_U32(ctx, 31, 0x17BD78u);
    ctx->pc = 0x17BD74u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BD70u;
            // 0x17bd74: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BD78u; }
        if (ctx->pc != 0x17BD78u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BD78u; }
        if (ctx->pc != 0x17BD78u) { return; }
    }
    ctx->pc = 0x17BD78u;
    // 0x17bd78: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17bd78u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17bd7c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bd7cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bd80: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bd80u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bd84: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17bd84u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17bd88: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bd88u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bd8c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bd8cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bd90: 0xc065480  jal         func_195200
    ctx->pc = 0x17BD90u;
    SET_GPR_U32(ctx, 31, 0x17BD98u);
    ctx->pc = 0x17BD94u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BD90u;
            // 0x17bd94: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BD98u; }
        if (ctx->pc != 0x17BD98u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BD98u; }
        if (ctx->pc != 0x17BD98u) { return; }
    }
    ctx->pc = 0x17BD98u;
    // 0x17bd98: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17bd98u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17bd9c: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bd9cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bda0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bda0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bda4: 0x24060010  addiu       $a2, $zero, 0x10
    ctx->pc = 0x17bda4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 16));
    // 0x17bda8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bda8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bdac: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bdacu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bdb0: 0xc065480  jal         func_195200
    ctx->pc = 0x17BDB0u;
    SET_GPR_U32(ctx, 31, 0x17BDB8u);
    ctx->pc = 0x17BDB4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BDB0u;
            // 0x17bdb4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BDB8u; }
        if (ctx->pc != 0x17BDB8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BDB8u; }
        if (ctx->pc != 0x17BDB8u) { return; }
    }
    ctx->pc = 0x17BDB8u;
    // 0x17bdb8: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17bdb8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17bdbc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bdbcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bdc0: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bdc0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bdc4: 0x24060068  addiu       $a2, $zero, 0x68
    ctx->pc = 0x17bdc4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 104));
    // 0x17bdc8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bdc8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bdcc: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bdccu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bdd0: 0xc065480  jal         func_195200
    ctx->pc = 0x17BDD0u;
    SET_GPR_U32(ctx, 31, 0x17BDD8u);
    ctx->pc = 0x17BDD4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BDD0u;
            // 0x17bdd4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BDD8u; }
        if (ctx->pc != 0x17BDD8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BDD8u; }
        if (ctx->pc != 0x17BDD8u) { return; }
    }
    ctx->pc = 0x17BDD8u;
label_17bdd8:
    // 0x17bdd8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17bdd8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17bddc: 0x24020024  addiu       $v0, $zero, 0x24
    ctx->pc = 0x17bddcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 36));
    // 0x17bde0: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17bde0u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17bde4: 0x0  nop
    ctx->pc = 0x17bde4u;
    // NOP
    // 0x17bde8: 0x0  nop
    ctx->pc = 0x17bde8u;
    // NOP
    // 0x17bdec: 0x1010  mfhi        $v0
    ctx->pc = 0x17bdecu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17bdf0: 0x14400227  bnez        $v0, . + 4 + (0x227 << 2)
    ctx->pc = 0x17BDF0u;
    {
        const bool branch_taken_0x17bdf0 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17bdf0) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17BDF8u;
    // 0x17bdf8: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17bdf8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bdfc: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17bdfcu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17be00: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17be00u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17be04: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17be04u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17be08: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17be08u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17be0c: 0x0  nop
    ctx->pc = 0x17be0cu;
    // NOP
    // 0x17be10: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17be10u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17be14: 0xc05d080  jal         func_174200
    ctx->pc = 0x17BE14u;
    SET_GPR_U32(ctx, 31, 0x17BE1Cu);
    ctx->pc = 0x17BE18u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BE14u;
            // 0x17be18: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE1Cu; }
        if (ctx->pc != 0x17BE1Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE1Cu; }
        if (ctx->pc != 0x17BE1Cu) { return; }
    }
    ctx->pc = 0x17BE1Cu;
    // 0x17be1c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17be1cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17be20: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17be20u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17be24: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17be24u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17be28: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17be28u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17be2c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17be2cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17be30: 0x0  nop
    ctx->pc = 0x17be30u;
    // NOP
    // 0x17be34: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17be34u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17be38: 0xc05d080  jal         func_174200
    ctx->pc = 0x17BE38u;
    SET_GPR_U32(ctx, 31, 0x17BE40u);
    ctx->pc = 0x17BE3Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BE38u;
            // 0x17be3c: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE40u; }
        if (ctx->pc != 0x17BE40u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE40u; }
        if (ctx->pc != 0x17BE40u) { return; }
    }
    ctx->pc = 0x17BE40u;
    // 0x17be40: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17be40u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17be44: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17be44u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17be48: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17be48u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17be4c: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17BE4Cu;
    SET_GPR_U32(ctx, 31, 0x17BE54u);
    ctx->pc = 0x17BE50u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BE4Cu;
            // 0x17be50: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE54u; }
        if (ctx->pc != 0x17BE54u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE54u; }
        if (ctx->pc != 0x17BE54u) { return; }
    }
    ctx->pc = 0x17BE54u;
    // 0x17be54: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17be54u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17be58: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17be58u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17be5c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17be5cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17be60: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17BE60u;
    SET_GPR_U32(ctx, 31, 0x17BE68u);
    ctx->pc = 0x17BE64u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BE60u;
            // 0x17be64: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE68u; }
        if (ctx->pc != 0x17BE68u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE68u; }
        if (ctx->pc != 0x17BE68u) { return; }
    }
    ctx->pc = 0x17BE68u;
    // 0x17be68: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17be68u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17be6c: 0x24060074  addiu       $a2, $zero, 0x74
    ctx->pc = 0x17be6cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 116));
    // 0x17be70: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17be70u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17be74: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17be74u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17be78: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17BE78u;
    SET_GPR_U32(ctx, 31, 0x17BE80u);
    ctx->pc = 0x17BE7Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BE78u;
            // 0x17be7c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE80u; }
        if (ctx->pc != 0x17BE80u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE80u; }
        if (ctx->pc != 0x17BE80u) { return; }
    }
    ctx->pc = 0x17BE80u;
    // 0x17be80: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17be80u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17be84: 0x24060004  addiu       $a2, $zero, 0x4
    ctx->pc = 0x17be84u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 4));
    // 0x17be88: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17be88u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17be8c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17be8cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17be90: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17BE90u;
    SET_GPR_U32(ctx, 31, 0x17BE98u);
    ctx->pc = 0x17BE94u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BE90u;
            // 0x17be94: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE98u; }
        if (ctx->pc != 0x17BE98u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BE98u; }
        if (ctx->pc != 0x17BE98u) { return; }
    }
    ctx->pc = 0x17BE98u;
    // 0x17be98: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17be98u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17be9c: 0x24060070  addiu       $a2, $zero, 0x70
    ctx->pc = 0x17be9cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 112));
    // 0x17bea0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bea0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bea4: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bea4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bea8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17BEA8u;
    SET_GPR_U32(ctx, 31, 0x17BEB0u);
    ctx->pc = 0x17BEACu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BEA8u;
            // 0x17beac: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BEB0u; }
        if (ctx->pc != 0x17BEB0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BEB0u; }
        if (ctx->pc != 0x17BEB0u) { return; }
    }
    ctx->pc = 0x17BEB0u;
    // 0x17beb0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17beb0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17beb4: 0x24060008  addiu       $a2, $zero, 0x8
    ctx->pc = 0x17beb4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 8));
    // 0x17beb8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17beb8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bebc: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bebcu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bec0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17BEC0u;
    SET_GPR_U32(ctx, 31, 0x17BEC8u);
    ctx->pc = 0x17BEC4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BEC0u;
            // 0x17bec4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BEC8u; }
        if (ctx->pc != 0x17BEC8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BEC8u; }
        if (ctx->pc != 0x17BEC8u) { return; }
    }
    ctx->pc = 0x17BEC8u;
    // 0x17bec8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bec8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17becc: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17beccu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17bed0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bed0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bed4: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bed4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bed8: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17BED8u;
    SET_GPR_U32(ctx, 31, 0x17BEE0u);
    ctx->pc = 0x17BEDCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BED8u;
            // 0x17bedc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BEE0u; }
        if (ctx->pc != 0x17BEE0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BEE0u; }
        if (ctx->pc != 0x17BEE0u) { return; }
    }
    ctx->pc = 0x17BEE0u;
    // 0x17bee0: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bee0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bee4: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17bee4u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17bee8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bee8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17beec: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17beecu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bef0: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17BEF0u;
    SET_GPR_U32(ctx, 31, 0x17BEF8u);
    ctx->pc = 0x17BEF4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BEF0u;
            // 0x17bef4: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BEF8u; }
        if (ctx->pc != 0x17BEF8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BEF8u; }
        if (ctx->pc != 0x17BEF8u) { return; }
    }
    ctx->pc = 0x17BEF8u;
    // 0x17bef8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bef8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17befc: 0x24060068  addiu       $a2, $zero, 0x68
    ctx->pc = 0x17befcu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 104));
    // 0x17bf00: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bf00u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bf04: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bf04u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bf08: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17BF08u;
    SET_GPR_U32(ctx, 31, 0x17BF10u);
    ctx->pc = 0x17BF0Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BF08u;
            // 0x17bf0c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BF10u; }
        if (ctx->pc != 0x17BF10u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BF10u; }
        if (ctx->pc != 0x17BF10u) { return; }
    }
    ctx->pc = 0x17BF10u;
    // 0x17bf10: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bf10u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bf14: 0x24060010  addiu       $a2, $zero, 0x10
    ctx->pc = 0x17bf14u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 16));
    // 0x17bf18: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bf18u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bf1c: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bf1cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bf20: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17BF20u;
    SET_GPR_U32(ctx, 31, 0x17BF28u);
    ctx->pc = 0x17BF24u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BF20u;
            // 0x17bf24: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BF28u; }
        if (ctx->pc != 0x17BF28u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BF28u; }
        if (ctx->pc != 0x17BF28u) { return; }
    }
    ctx->pc = 0x17BF28u;
    // 0x17bf28: 0x100001d9  b           . + 4 + (0x1D9 << 2)
    ctx->pc = 0x17BF28u;
    {
        const bool branch_taken_0x17bf28 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17bf28) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17BF30u;
label_17bf30:
    // 0x17bf30: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17bf30u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17bf34: 0x24020030  addiu       $v0, $zero, 0x30
    ctx->pc = 0x17bf34u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 48));
    // 0x17bf38: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17bf38u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17bf3c: 0x0  nop
    ctx->pc = 0x17bf3cu;
    // NOP
    // 0x17bf40: 0x0  nop
    ctx->pc = 0x17bf40u;
    // NOP
    // 0x17bf44: 0x1010  mfhi        $v0
    ctx->pc = 0x17bf44u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17bf48: 0x1440004d  bnez        $v0, . + 4 + (0x4D << 2)
    ctx->pc = 0x17BF48u;
    {
        const bool branch_taken_0x17bf48 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17bf48) {
            ctx->pc = 0x17C080u;
            goto label_17c080;
        }
    }
    ctx->pc = 0x17BF50u;
    // 0x17bf50: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17bf50u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bf54: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17bf54u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17bf58: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17bf58u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17bf5c: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17bf5cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17bf60: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17bf60u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17bf64: 0x0  nop
    ctx->pc = 0x17bf64u;
    // NOP
    // 0x17bf68: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17bf68u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17bf6c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17BF6Cu;
    SET_GPR_U32(ctx, 31, 0x17BF74u);
    ctx->pc = 0x17BF70u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BF6Cu;
            // 0x17bf70: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BF74u; }
        if (ctx->pc != 0x17BF74u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BF74u; }
        if (ctx->pc != 0x17BF74u) { return; }
    }
    ctx->pc = 0x17BF74u;
    // 0x17bf74: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17bf74u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bf78: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17bf78u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17bf7c: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17bf7cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17bf80: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17bf80u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17bf84: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17bf84u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17bf88: 0x0  nop
    ctx->pc = 0x17bf88u;
    // NOP
    // 0x17bf8c: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17bf8cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17bf90: 0xc05d080  jal         func_174200
    ctx->pc = 0x17BF90u;
    SET_GPR_U32(ctx, 31, 0x17BF98u);
    ctx->pc = 0x17BF94u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BF90u;
            // 0x17bf94: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BF98u; }
        if (ctx->pc != 0x17BF98u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BF98u; }
        if (ctx->pc != 0x17BF98u) { return; }
    }
    ctx->pc = 0x17BF98u;
    // 0x17bf98: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bf98u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bf9c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bf9cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bfa0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bfa0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bfa4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17BFA4u;
    SET_GPR_U32(ctx, 31, 0x17BFACu);
    ctx->pc = 0x17BFA8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BFA4u;
            // 0x17bfa8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BFACu; }
        if (ctx->pc != 0x17BFACu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BFACu; }
        if (ctx->pc != 0x17BFACu) { return; }
    }
    ctx->pc = 0x17BFACu;
    // 0x17bfac: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bfacu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bfb0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bfb0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bfb4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bfb4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bfb8: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17BFB8u;
    SET_GPR_U32(ctx, 31, 0x17BFC0u);
    ctx->pc = 0x17BFBCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BFB8u;
            // 0x17bfbc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BFC0u; }
        if (ctx->pc != 0x17BFC0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BFC0u; }
        if (ctx->pc != 0x17BFC0u) { return; }
    }
    ctx->pc = 0x17BFC0u;
    // 0x17bfc0: 0x3c024000  lui         $v0, 0x4000
    ctx->pc = 0x17bfc0u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16384 << 16));
    // 0x17bfc4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bfc4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bfc8: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bfc8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bfcc: 0x24060008  addiu       $a2, $zero, 0x8
    ctx->pc = 0x17bfccu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 8));
    // 0x17bfd0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bfd0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bfd4: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17bfd4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17bfd8: 0xc065480  jal         func_195200
    ctx->pc = 0x17BFD8u;
    SET_GPR_U32(ctx, 31, 0x17BFE0u);
    ctx->pc = 0x17BFDCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BFD8u;
            // 0x17bfdc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BFE0u; }
        if (ctx->pc != 0x17BFE0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17BFE0u; }
        if (ctx->pc != 0x17BFE0u) { return; }
    }
    ctx->pc = 0x17BFE0u;
    // 0x17bfe0: 0x3c024000  lui         $v0, 0x4000
    ctx->pc = 0x17bfe0u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16384 << 16));
    // 0x17bfe4: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17bfe4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17bfe8: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17bfe8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17bfec: 0x24060070  addiu       $a2, $zero, 0x70
    ctx->pc = 0x17bfecu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 112));
    // 0x17bff0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17bff0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17bff4: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17bff4u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17bff8: 0xc065480  jal         func_195200
    ctx->pc = 0x17BFF8u;
    SET_GPR_U32(ctx, 31, 0x17C000u);
    ctx->pc = 0x17BFFCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17BFF8u;
            // 0x17bffc: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C000u; }
        if (ctx->pc != 0x17C000u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C000u; }
        if (ctx->pc != 0x17C000u) { return; }
    }
    ctx->pc = 0x17C000u;
    // 0x17c000: 0x3c024000  lui         $v0, 0x4000
    ctx->pc = 0x17c000u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16384 << 16));
    // 0x17c004: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17c004u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c008: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17c008u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17c00c: 0x2406000c  addiu       $a2, $zero, 0xC
    ctx->pc = 0x17c00cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17c010: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c010u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c014: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17c014u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17c018: 0xc065480  jal         func_195200
    ctx->pc = 0x17C018u;
    SET_GPR_U32(ctx, 31, 0x17C020u);
    ctx->pc = 0x17C01Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C018u;
            // 0x17c01c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C020u; }
        if (ctx->pc != 0x17C020u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C020u; }
        if (ctx->pc != 0x17C020u) { return; }
    }
    ctx->pc = 0x17C020u;
    // 0x17c020: 0x3c024000  lui         $v0, 0x4000
    ctx->pc = 0x17c020u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16384 << 16));
    // 0x17c024: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17c024u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c028: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17c028u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17c02c: 0x2406006c  addiu       $a2, $zero, 0x6C
    ctx->pc = 0x17c02cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 108));
    // 0x17c030: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c030u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c034: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17c034u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17c038: 0xc065480  jal         func_195200
    ctx->pc = 0x17C038u;
    SET_GPR_U32(ctx, 31, 0x17C040u);
    ctx->pc = 0x17C03Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C038u;
            // 0x17c03c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C040u; }
        if (ctx->pc != 0x17C040u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C040u; }
        if (ctx->pc != 0x17C040u) { return; }
    }
    ctx->pc = 0x17C040u;
    // 0x17c040: 0x3c024000  lui         $v0, 0x4000
    ctx->pc = 0x17c040u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16384 << 16));
    // 0x17c044: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17c044u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c048: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17c048u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17c04c: 0x24060010  addiu       $a2, $zero, 0x10
    ctx->pc = 0x17c04cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 16));
    // 0x17c050: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c050u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c054: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17c054u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17c058: 0xc065480  jal         func_195200
    ctx->pc = 0x17C058u;
    SET_GPR_U32(ctx, 31, 0x17C060u);
    ctx->pc = 0x17C05Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C058u;
            // 0x17c05c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C060u; }
        if (ctx->pc != 0x17C060u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C060u; }
        if (ctx->pc != 0x17C060u) { return; }
    }
    ctx->pc = 0x17C060u;
    // 0x17c060: 0x3c024000  lui         $v0, 0x4000
    ctx->pc = 0x17c060u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16384 << 16));
    // 0x17c064: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17c064u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c068: 0x44826000  mtc1        $v0, $f12
    ctx->pc = 0x17c068u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[12], &bits, sizeof(bits)); }
    // 0x17c06c: 0x24060068  addiu       $a2, $zero, 0x68
    ctx->pc = 0x17c06cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 104));
    // 0x17c070: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c070u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c074: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17c074u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17c078: 0xc065480  jal         func_195200
    ctx->pc = 0x17C078u;
    SET_GPR_U32(ctx, 31, 0x17C080u);
    ctx->pc = 0x17C07Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C078u;
            // 0x17c07c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x195200u;
    if (runtime->hasFunction(0x195200u)) {
        auto targetFn = runtime->lookupFunction(0x195200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C080u; }
        if (ctx->pc != 0x17C080u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Houkou_spd_0x195200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C080u; }
        if (ctx->pc != 0x17C080u) { return; }
    }
    ctx->pc = 0x17C080u;
label_17c080:
    // 0x17c080: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c080u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c084: 0x24020048  addiu       $v0, $zero, 0x48
    ctx->pc = 0x17c084u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 72));
    // 0x17c088: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17c088u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17c08c: 0x0  nop
    ctx->pc = 0x17c08cu;
    // NOP
    // 0x17c090: 0x0  nop
    ctx->pc = 0x17c090u;
    // NOP
    // 0x17c094: 0x1010  mfhi        $v0
    ctx->pc = 0x17c094u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17c098: 0x1440017d  bnez        $v0, . + 4 + (0x17D << 2)
    ctx->pc = 0x17C098u;
    {
        const bool branch_taken_0x17c098 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17c098) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17C0A0u;
    // 0x17c0a0: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c0a0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c0a4: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17c0a4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c0a8: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17c0a8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17c0ac: 0x2442001c  addiu       $v0, $v0, 0x1C
    ctx->pc = 0x17c0acu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 28));
    // 0x17c0b0: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17c0b0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17c0b4: 0x0  nop
    ctx->pc = 0x17c0b4u;
    // NOP
    // 0x17c0b8: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17c0b8u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17c0bc: 0xc05d080  jal         func_174200
    ctx->pc = 0x17C0BCu;
    SET_GPR_U32(ctx, 31, 0x17C0C4u);
    ctx->pc = 0x17C0C0u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C0BCu;
            // 0x17c0c0: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C0C4u; }
        if (ctx->pc != 0x17C0C4u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C0C4u; }
        if (ctx->pc != 0x17C0C4u) { return; }
    }
    ctx->pc = 0x17C0C4u;
    // 0x17c0c4: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c0c4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c0c8: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17c0c8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c0cc: 0x24040026  addiu       $a0, $zero, 0x26
    ctx->pc = 0x17c0ccu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17c0d0: 0x2442ffe4  addiu       $v0, $v0, -0x1C
    ctx->pc = 0x17c0d0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x17c0d4: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17c0d4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17c0d8: 0x0  nop
    ctx->pc = 0x17c0d8u;
    // NOP
    // 0x17c0dc: 0x46800360  cvt.s.w     $f13, $f0
    ctx->pc = 0x17c0dcu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
    // 0x17c0e0: 0xc05d080  jal         func_174200
    ctx->pc = 0x17C0E0u;
    SET_GPR_U32(ctx, 31, 0x17C0E8u);
    ctx->pc = 0x17C0E4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C0E0u;
            // 0x17c0e4: 0x46800b20  cvt.s.w     $f12, $f1 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C0E8u; }
        if (ctx->pc != 0x17C0E8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C0E8u; }
        if (ctx->pc != 0x17C0E8u) { return; }
    }
    ctx->pc = 0x17C0E8u;
    // 0x17c0e8: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17c0e8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c0ec: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c0ecu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c0f0: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17c0f0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17c0f4: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17C0F4u;
    SET_GPR_U32(ctx, 31, 0x17C0FCu);
    ctx->pc = 0x17C0F8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C0F4u;
            // 0x17c0f8: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C0FCu; }
        if (ctx->pc != 0x17C0FCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C0FCu; }
        if (ctx->pc != 0x17C0FCu) { return; }
    }
    ctx->pc = 0x17C0FCu;
    // 0x17c0fc: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17c0fcu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c100: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c100u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c104: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17c104u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17c108: 0xc0655a8  jal         func_1956A0
    ctx->pc = 0x17C108u;
    SET_GPR_U32(ctx, 31, 0x17C110u);
    ctx->pc = 0x17C10Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C108u;
            // 0x17c10c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1956A0u;
    if (runtime->hasFunction(0x1956A0u)) {
        auto targetFn = runtime->lookupFunction(0x1956A0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C110u; }
        if (ctx->pc != 0x17C110u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Mazuru_0x1956a0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C110u; }
        if (ctx->pc != 0x17C110u) { return; }
    }
    ctx->pc = 0x17C110u;
    // 0x17c110: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17c110u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c114: 0x24060074  addiu       $a2, $zero, 0x74
    ctx->pc = 0x17c114u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 116));
    // 0x17c118: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c118u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c11c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17c11cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17c120: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17C120u;
    SET_GPR_U32(ctx, 31, 0x17C128u);
    ctx->pc = 0x17C124u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C120u;
            // 0x17c124: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C128u; }
        if (ctx->pc != 0x17C128u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C128u; }
        if (ctx->pc != 0x17C128u) { return; }
    }
    ctx->pc = 0x17C128u;
    // 0x17c128: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17c128u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c12c: 0x24060004  addiu       $a2, $zero, 0x4
    ctx->pc = 0x17c12cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 4));
    // 0x17c130: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c130u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c134: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17c134u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17c138: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17C138u;
    SET_GPR_U32(ctx, 31, 0x17C140u);
    ctx->pc = 0x17C13Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C138u;
            // 0x17c13c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C140u; }
        if (ctx->pc != 0x17C140u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C140u; }
        if (ctx->pc != 0x17C140u) { return; }
    }
    ctx->pc = 0x17C140u;
    // 0x17c140: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17c140u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c144: 0x24060070  addiu       $a2, $zero, 0x70
    ctx->pc = 0x17c144u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 112));
    // 0x17c148: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c148u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c14c: 0x2464ffe4  addiu       $a0, $v1, -0x1C
    ctx->pc = 0x17c14cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967268));
    // 0x17c150: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17C150u;
    SET_GPR_U32(ctx, 31, 0x17C158u);
    ctx->pc = 0x17C154u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C150u;
            // 0x17c154: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C158u; }
        if (ctx->pc != 0x17C158u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C158u; }
        if (ctx->pc != 0x17C158u) { return; }
    }
    ctx->pc = 0x17C158u;
    // 0x17c158: 0x8fa3003c  lw          $v1, 0x3C($sp)
    ctx->pc = 0x17c158u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c15c: 0x24060008  addiu       $a2, $zero, 0x8
    ctx->pc = 0x17c15cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 0), 8));
    // 0x17c160: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c160u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c164: 0x2464001c  addiu       $a0, $v1, 0x1C
    ctx->pc = 0x17c164u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 3), 28));
    // 0x17c168: 0xc0652b4  jal         func_194AD0
    ctx->pc = 0x17C168u;
    SET_GPR_U32(ctx, 31, 0x17C170u);
    ctx->pc = 0x17C16Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C168u;
            // 0x17c16c: 0x24450004  addiu       $a1, $v0, 0x4 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 2), 4));
        ctx->in_delay_slot = false;
    ctx->pc = 0x194AD0u;
    if (runtime->hasFunction(0x194AD0u)) {
        auto targetFn = runtime->lookupFunction(0x194AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C170u; }
        if (ctx->pc != 0x17C170u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotCreate_Kowase_0x194ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C170u; }
        if (ctx->pc != 0x17C170u) { return; }
    }
    ctx->pc = 0x17C170u;
    // 0x17c170: 0x10000147  b           . + 4 + (0x147 << 2)
    ctx->pc = 0x17C170u;
    {
        const bool branch_taken_0x17c170 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c170) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17C178u;
label_17c178:
    // 0x17c178: 0xc0656b4  jal         func_195AD0
    ctx->pc = 0x17C178u;
    SET_GPR_U32(ctx, 31, 0x17C180u);
    ctx->pc = 0x195AD0u;
    if (runtime->hasFunction(0x195AD0u)) {
        auto targetFn = runtime->lookupFunction(0x195AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C180u; }
        if (ctx->pc != 0x17C180u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotBloadCastDead2_0x195ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C180u; }
        if (ctx->pc != 0x17C180u) { return; }
    }
    ctx->pc = 0x17C180u;
    // 0x17c180: 0x8e220000  lw          $v0, 0x0($s1)
    ctx->pc = 0x17c180u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c184: 0x27a4003c  addiu       $a0, $sp, 0x3C
    ctx->pc = 0x17c184u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 29), 60));
    // 0x17c188: 0xc44c0120  lwc1        $f12, 0x120($v0)
    ctx->pc = 0x17c188u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 288)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[12] = f; }
    // 0x17c18c: 0xc44d0124  lwc1        $f13, 0x124($v0)
    ctx->pc = 0x17c18cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 292)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[13] = f; }
    // 0x17c190: 0xc05f3cc  jal         func_17CF30
    ctx->pc = 0x17C190u;
    SET_GPR_U32(ctx, 31, 0x17C198u);
    ctx->pc = 0x17C194u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C190u;
            // 0x17c194: 0x27a50038  addiu       $a1, $sp, 0x38 (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 29), 56));
        ctx->in_delay_slot = false;
    ctx->pc = 0x17CF30u;
    if (runtime->hasFunction(0x17CF30u)) {
        auto targetFn = runtime->lookupFunction(0x17CF30u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C198u; }
        if (ctx->pc != 0x17C198u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Trans3Dto2D_0x17cf30(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C198u; }
        if (ctx->pc != 0x17C198u) { return; }
    }
    ctx->pc = 0x17C198u;
    // 0x17c198: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c198u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c19c: 0x220202d  daddu       $a0, $s1, $zero
    ctx->pc = 0x17c19cu;
    SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c1a0: 0xae22001c  sw          $v0, 0x1C($s1)
    ctx->pc = 0x17c1a0u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 2));
    // 0x17c1a4: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c1a4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c1a8: 0xc05b978  jal         func_16E5E0
    ctx->pc = 0x17C1A8u;
    SET_GPR_U32(ctx, 31, 0x17C1B0u);
    ctx->pc = 0x17C1ACu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C1A8u;
            // 0x17c1ac: 0xae220020  sw          $v0, 0x20($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
        ctx->in_delay_slot = false;
    ctx->pc = 0x16E5E0u;
    if (runtime->hasFunction(0x16E5E0u)) {
        auto targetFn = runtime->lookupFunction(0x16E5E0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C1B0u; }
        if (ctx->pc != 0x17C1B0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Enemy_BloadCast_Child_Hp0_0x16e5e0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C1B0u; }
        if (ctx->pc != 0x17C1B0u) { return; }
    }
    ctx->pc = 0x17C1B0u;
    // 0x17c1b0: 0xc05b9cc  jal         func_16E730
    ctx->pc = 0x17C1B0u;
    SET_GPR_U32(ctx, 31, 0x17C1B8u);
    ctx->pc = 0x17C1B4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C1B0u;
            // 0x17c1b4: 0x220202d  daddu       $a0, $s1, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x16E730u;
    if (runtime->hasFunction(0x16E730u)) {
        auto targetFn = runtime->lookupFunction(0x16E730u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C1B8u; }
        if (ctx->pc != 0x17C1B8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Enemy_BloadCast_All_Hp0_0x16e730(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C1B8u; }
        if (ctx->pc != 0x17C1B8u) { return; }
    }
    ctx->pc = 0x17C1B8u;
    // 0x17c1b8: 0xc050bb4  jal         func_142ED0
    ctx->pc = 0x17C1B8u;
    SET_GPR_U32(ctx, 31, 0x17C1C0u);
    ctx->pc = 0x142ED0u;
    if (runtime->hasFunction(0x142ED0u)) {
        auto targetFn = runtime->lookupFunction(0x142ED0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C1C0u; }
        if (ctx->pc != 0x17C1C0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsRand_0x142ed0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C1C0u; }
        if (ctx->pc != 0x17C1C0u) { return; }
    }
    ctx->pc = 0x17C1C0u;
    // 0x17c1c0: 0x24030140  addiu       $v1, $zero, 0x140
    ctx->pc = 0x17c1c0u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 0), 320));
    // 0x17c1c4: 0x8e24001c  lw          $a0, 0x1C($s1)
    ctx->pc = 0x17c1c4u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x17c1c8: 0x43001b  divu        $zero, $v0, $v1
    ctx->pc = 0x17c1c8u;
    { uint32_t divisor = GPR_U32(ctx, 3); if (divisor != 0) { ctx->lo = (uint64_t)(int64_t)(int32_t)(GPR_U32(ctx, 2) / divisor); ctx->hi = (uint64_t)(int64_t)(int32_t)(GPR_U32(ctx, 2) % divisor); } else { ctx->lo = 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)(int32_t)GPR_U32(ctx,2); } }
    // 0x17c1cc: 0xc62000d0  lwc1        $f0, 0xD0($s1)
    ctx->pc = 0x17c1ccu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 208)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c1d0: 0xc62d00d4  lwc1        $f13, 0xD4($s1)
    ctx->pc = 0x17c1d0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[13] = f; }
    // 0x17c1d4: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17c1d4u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17c1d8: 0x8e230020  lw          $v1, 0x20($s1)
    ctx->pc = 0x17c1d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x17c1dc: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17c1dcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17c1e0: 0x1010  mfhi        $v0
    ctx->pc = 0x17c1e0u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17c1e4: 0x46000b02  mul.s       $f12, $f1, $f0
    ctx->pc = 0x17c1e4u;
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x17c1e8: 0x821021  addu        $v0, $a0, $v0
    ctx->pc = 0x17c1e8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x17c1ec: 0x2465ffec  addiu       $a1, $v1, -0x14
    ctx->pc = 0x17c1ecu;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967276));
    // 0x17c1f0: 0xc0536d8  jal         func_14DB60
    ctx->pc = 0x17C1F0u;
    SET_GPR_U32(ctx, 31, 0x17C1F8u);
    ctx->pc = 0x17C1F4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C1F0u;
            // 0x17c1f4: 0x2444ff60  addiu       $a0, $v0, -0xA0 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967136));
        ctx->in_delay_slot = false;
    ctx->pc = 0x14DB60u;
    if (runtime->hasFunction(0x14DB60u)) {
        auto targetFn = runtime->lookupFunction(0x14DB60u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C1F8u; }
        if (ctx->pc != 0x17C1F8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CreateExplosionKemuri_0x14db60(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C1F8u; }
        if (ctx->pc != 0x17C1F8u) { return; }
    }
    ctx->pc = 0x17C1F8u;
    // 0x17c1f8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c1f8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c1fc: 0x24020006  addiu       $v0, $zero, 0x6
    ctx->pc = 0x17c1fcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 6));
    // 0x17c200: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17c200u;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17c204: 0x0  nop
    ctx->pc = 0x17c204u;
    // NOP
    // 0x17c208: 0x0  nop
    ctx->pc = 0x17c208u;
    // NOP
    // 0x17c20c: 0x1010  mfhi        $v0
    ctx->pc = 0x17c20cu;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17c210: 0x1440005d  bnez        $v0, . + 4 + (0x5D << 2)
    ctx->pc = 0x17C210u;
    {
        const bool branch_taken_0x17c210 = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17c210) {
            ctx->pc = 0x17C388u;
            goto label_17c388;
        }
    }
    ctx->pc = 0x17C218u;
    // 0x17c218: 0xc050bb4  jal         func_142ED0
    ctx->pc = 0x17C218u;
    SET_GPR_U32(ctx, 31, 0x17C220u);
    ctx->pc = 0x142ED0u;
    if (runtime->hasFunction(0x142ED0u)) {
        auto targetFn = runtime->lookupFunction(0x142ED0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C220u; }
        if (ctx->pc != 0x17C220u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsRand_0x142ed0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C220u; }
        if (ctx->pc != 0x17C220u) { return; }
    }
    ctx->pc = 0x17C220u;
    // 0x17c220: 0x24030140  addiu       $v1, $zero, 0x140
    ctx->pc = 0x17c220u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 0), 320));
    // 0x17c224: 0x8e24001c  lw          $a0, 0x1C($s1)
    ctx->pc = 0x17c224u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x17c228: 0x43001b  divu        $zero, $v0, $v1
    ctx->pc = 0x17c228u;
    { uint32_t divisor = GPR_U32(ctx, 3); if (divisor != 0) { ctx->lo = (uint64_t)(int64_t)(int32_t)(GPR_U32(ctx, 2) / divisor); ctx->hi = (uint64_t)(int64_t)(int32_t)(GPR_U32(ctx, 2) % divisor); } else { ctx->lo = 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)(int32_t)GPR_U32(ctx,2); } }
    // 0x17c22c: 0xc62000d0  lwc1        $f0, 0xD0($s1)
    ctx->pc = 0x17c22cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 208)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c230: 0xc62d00d4  lwc1        $f13, 0xD4($s1)
    ctx->pc = 0x17c230u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[13] = f; }
    // 0x17c234: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17c234u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17c238: 0x8e230020  lw          $v1, 0x20($s1)
    ctx->pc = 0x17c238u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x17c23c: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17c23cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17c240: 0x8010  mfhi        $s0
    ctx->pc = 0x17c240u;
    SET_GPR_U64(ctx, 16, ctx->hi);
    // 0x17c244: 0x46000b02  mul.s       $f12, $f1, $f0
    ctx->pc = 0x17c244u;
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x17c248: 0x901021  addu        $v0, $a0, $s0
    ctx->pc = 0x17c248u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 16)));
    // 0x17c24c: 0x2465ffe7  addiu       $a1, $v1, -0x19
    ctx->pc = 0x17c24cu;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967271));
    // 0x17c250: 0xc053740  jal         func_14DD00
    ctx->pc = 0x17C250u;
    SET_GPR_U32(ctx, 31, 0x17C258u);
    ctx->pc = 0x17C254u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C250u;
            // 0x17c254: 0x2444ff60  addiu       $a0, $v0, -0xA0 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967136));
        ctx->in_delay_slot = false;
    ctx->pc = 0x14DD00u;
    if (runtime->hasFunction(0x14DD00u)) {
        auto targetFn = runtime->lookupFunction(0x14DD00u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C258u; }
        if (ctx->pc != 0x17C258u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CreateExplosion_0x14dd00(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C258u; }
        if (ctx->pc != 0x17C258u) { return; }
    }
    ctx->pc = 0x17C258u;
    // 0x17c258: 0x8e23001c  lw          $v1, 0x1C($s1)
    ctx->pc = 0x17c258u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x17c25c: 0x24040022  addiu       $a0, $zero, 0x22
    ctx->pc = 0x17c25cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 34));
    // 0x17c260: 0x8e220020  lw          $v0, 0x20($s1)
    ctx->pc = 0x17c260u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x17c264: 0x701821  addu        $v1, $v1, $s0
    ctx->pc = 0x17c264u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x17c268: 0x2463ff60  addiu       $v1, $v1, -0xA0
    ctx->pc = 0x17c268u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967136));
    // 0x17c26c: 0x2442ffe7  addiu       $v0, $v0, -0x19
    ctx->pc = 0x17c26cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967271));
    // 0x17c270: 0x44830800  mtc1        $v1, $f1
    ctx->pc = 0x17c270u;
    { uint32_t bits = GPR_U32(ctx, 3); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17c274: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c274u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c278: 0x0  nop
    ctx->pc = 0x17c278u;
    // NOP
    // 0x17c27c: 0x46800b20  cvt.s.w     $f12, $f1
    ctx->pc = 0x17c27cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
    // 0x17c280: 0xc05d080  jal         func_174200
    ctx->pc = 0x17C280u;
    SET_GPR_U32(ctx, 31, 0x17C288u);
    ctx->pc = 0x17C284u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C280u;
            // 0x17c284: 0x46800360  cvt.s.w     $f13, $f0 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C288u; }
        if (ctx->pc != 0x17C288u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C288u; }
        if (ctx->pc != 0x17C288u) { return; }
    }
    ctx->pc = 0x17C288u;
    // 0x17c288: 0xc050bb4  jal         func_142ED0
    ctx->pc = 0x17C288u;
    SET_GPR_U32(ctx, 31, 0x17C290u);
    ctx->pc = 0x142ED0u;
    if (runtime->hasFunction(0x142ED0u)) {
        auto targetFn = runtime->lookupFunction(0x142ED0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C290u; }
        if (ctx->pc != 0x17C290u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsRand_0x142ed0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C290u; }
        if (ctx->pc != 0x17C290u) { return; }
    }
    ctx->pc = 0x17C290u;
    // 0x17c290: 0x30420001  andi        $v0, $v0, 0x1
    ctx->pc = 0x17c290u;
    SET_GPR_VEC(ctx, 2, PS2_PAND(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)1u)));
    // 0x17c294: 0x1040000e  beqz        $v0, . + 4 + (0xE << 2)
    ctx->pc = 0x17C294u;
    {
        const bool branch_taken_0x17c294 = (GPR_U64(ctx, 2) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c294) {
            ctx->pc = 0x17C2D0u;
            goto label_17c2d0;
        }
    }
    ctx->pc = 0x17C29Cu;
    // 0x17c29c: 0x8e23001c  lw          $v1, 0x1C($s1)
    ctx->pc = 0x17c29cu;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x17c2a0: 0x24040023  addiu       $a0, $zero, 0x23
    ctx->pc = 0x17c2a0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 35));
    // 0x17c2a4: 0x8e220020  lw          $v0, 0x20($s1)
    ctx->pc = 0x17c2a4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x17c2a8: 0x701821  addu        $v1, $v1, $s0
    ctx->pc = 0x17c2a8u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x17c2ac: 0x2463ff60  addiu       $v1, $v1, -0xA0
    ctx->pc = 0x17c2acu;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967136));
    // 0x17c2b0: 0x2442ffe7  addiu       $v0, $v0, -0x19
    ctx->pc = 0x17c2b0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967271));
    // 0x17c2b4: 0x44830800  mtc1        $v1, $f1
    ctx->pc = 0x17c2b4u;
    { uint32_t bits = GPR_U32(ctx, 3); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17c2b8: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c2b8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c2bc: 0x0  nop
    ctx->pc = 0x17c2bcu;
    // NOP
    // 0x17c2c0: 0x46800b20  cvt.s.w     $f12, $f1
    ctx->pc = 0x17c2c0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
    // 0x17c2c4: 0xc05d080  jal         func_174200
    ctx->pc = 0x17C2C4u;
    SET_GPR_U32(ctx, 31, 0x17C2CCu);
    ctx->pc = 0x17C2C8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C2C4u;
            // 0x17c2c8: 0x46800360  cvt.s.w     $f13, $f0 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C2CCu; }
        if (ctx->pc != 0x17C2CCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C2CCu; }
        if (ctx->pc != 0x17C2CCu) { return; }
    }
    ctx->pc = 0x17C2CCu;
    // 0x17c2cc: 0x0  nop
    ctx->pc = 0x17c2ccu;
    // NOP
label_17c2d0:
    // 0x17c2d0: 0xc050bb4  jal         func_142ED0
    ctx->pc = 0x17C2D0u;
    SET_GPR_U32(ctx, 31, 0x17C2D8u);
    ctx->pc = 0x142ED0u;
    if (runtime->hasFunction(0x142ED0u)) {
        auto targetFn = runtime->lookupFunction(0x142ED0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C2D8u; }
        if (ctx->pc != 0x17C2D8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsRand_0x142ed0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C2D8u; }
        if (ctx->pc != 0x17C2D8u) { return; }
    }
    ctx->pc = 0x17C2D8u;
    // 0x17c2d8: 0x30420001  andi        $v0, $v0, 0x1
    ctx->pc = 0x17c2d8u;
    SET_GPR_VEC(ctx, 2, PS2_PAND(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)1u)));
    // 0x17c2dc: 0x1040000e  beqz        $v0, . + 4 + (0xE << 2)
    ctx->pc = 0x17C2DCu;
    {
        const bool branch_taken_0x17c2dc = (GPR_U64(ctx, 2) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c2dc) {
            ctx->pc = 0x17C318u;
            goto label_17c318;
        }
    }
    ctx->pc = 0x17C2E4u;
    // 0x17c2e4: 0x8e23001c  lw          $v1, 0x1C($s1)
    ctx->pc = 0x17c2e4u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x17c2e8: 0x24040024  addiu       $a0, $zero, 0x24
    ctx->pc = 0x17c2e8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 36));
    // 0x17c2ec: 0x8e220020  lw          $v0, 0x20($s1)
    ctx->pc = 0x17c2ecu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x17c2f0: 0x701821  addu        $v1, $v1, $s0
    ctx->pc = 0x17c2f0u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x17c2f4: 0x2463ff60  addiu       $v1, $v1, -0xA0
    ctx->pc = 0x17c2f4u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967136));
    // 0x17c2f8: 0x2442ffe7  addiu       $v0, $v0, -0x19
    ctx->pc = 0x17c2f8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967271));
    // 0x17c2fc: 0x44830800  mtc1        $v1, $f1
    ctx->pc = 0x17c2fcu;
    { uint32_t bits = GPR_U32(ctx, 3); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17c300: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c300u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c304: 0x0  nop
    ctx->pc = 0x17c304u;
    // NOP
    // 0x17c308: 0x46800b20  cvt.s.w     $f12, $f1
    ctx->pc = 0x17c308u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[1], sizeof(tmp)); ctx->f[12] = FPU_CVT_S_W(tmp); }
    // 0x17c30c: 0xc05d080  jal         func_174200
    ctx->pc = 0x17C30Cu;
    SET_GPR_U32(ctx, 31, 0x17C314u);
    ctx->pc = 0x17C310u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C30Cu;
            // 0x17c310: 0x46800360  cvt.s.w     $f13, $f0 (Delay Slot)
        { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[13] = FPU_CVT_S_W(tmp); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x174200u;
    if (runtime->hasFunction(0x174200u)) {
        auto targetFn = runtime->lookupFunction(0x174200u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C314u; }
        if (ctx->pc != 0x17C314u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_abs_0x174200(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C314u; }
        if (ctx->pc != 0x17C314u) { return; }
    }
    ctx->pc = 0x17C314u;
    // 0x17c314: 0x0  nop
    ctx->pc = 0x17c314u;
    // NOP
label_17c318:
    // 0x17c318: 0xc056f84  jal         func_15BE10
    ctx->pc = 0x17C318u;
    SET_GPR_U32(ctx, 31, 0x17C320u);
    ctx->pc = 0x17C31Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C318u;
            // 0x17c31c: 0x202d  daddu       $a0, $zero, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x15BE10u;
    if (runtime->hasFunction(0x15BE10u)) {
        auto targetFn = runtime->lookupFunction(0x15BE10u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C320u; }
        if (ctx->pc != 0x17C320u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        IsGamePlayerAvtive_0x15be10(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C320u; }
        if (ctx->pc != 0x17C320u) { return; }
    }
    ctx->pc = 0x17C320u;
    // 0x17c320: 0x1040000b  beqz        $v0, . + 4 + (0xB << 2)
    ctx->pc = 0x17C320u;
    {
        const bool branch_taken_0x17c320 = (GPR_U64(ctx, 2) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c320) {
            ctx->pc = 0x17C350u;
            goto label_17c350;
        }
    }
    ctx->pc = 0x17C328u;
    // 0x17c328: 0xc050bb4  jal         func_142ED0
    ctx->pc = 0x17C328u;
    SET_GPR_U32(ctx, 31, 0x17C330u);
    ctx->pc = 0x142ED0u;
    if (runtime->hasFunction(0x142ED0u)) {
        auto targetFn = runtime->lookupFunction(0x142ED0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C330u; }
        if (ctx->pc != 0x17C330u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsRand_0x142ed0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C330u; }
        if (ctx->pc != 0x17C330u) { return; }
    }
    ctx->pc = 0x17C330u;
    // 0x17c330: 0x2403000c  addiu       $v1, $zero, 0xC
    ctx->pc = 0x17c330u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17c334: 0x43001b  divu        $zero, $v0, $v1
    ctx->pc = 0x17c334u;
    { uint32_t divisor = GPR_U32(ctx, 3); if (divisor != 0) { ctx->lo = (uint64_t)(int64_t)(int32_t)(GPR_U32(ctx, 2) / divisor); ctx->hi = (uint64_t)(int64_t)(int32_t)(GPR_U32(ctx, 2) % divisor); } else { ctx->lo = 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)(int32_t)GPR_U32(ctx,2); } }
    // 0x17c338: 0x0  nop
    ctx->pc = 0x17c338u;
    // NOP
    // 0x17c33c: 0x0  nop
    ctx->pc = 0x17c33cu;
    // NOP
    // 0x17c340: 0x2810  mfhi        $a1
    ctx->pc = 0x17c340u;
    SET_GPR_U64(ctx, 5, ctx->hi);
    // 0x17c344: 0xc055124  jal         func_154490
    ctx->pc = 0x17C344u;
    SET_GPR_U32(ctx, 31, 0x17C34Cu);
    ctx->pc = 0x17C348u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C344u;
            // 0x17c348: 0x202d  daddu       $a0, $zero, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x154490u;
    if (runtime->hasFunction(0x154490u)) {
        auto targetFn = runtime->lookupFunction(0x154490u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C34Cu; }
        if (ctx->pc != 0x17C34Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsDualShock_0x154490(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C34Cu; }
        if (ctx->pc != 0x17C34Cu) { return; }
    }
    ctx->pc = 0x17C34Cu;
    // 0x17c34c: 0x0  nop
    ctx->pc = 0x17c34cu;
    // NOP
label_17c350:
    // 0x17c350: 0xc056f84  jal         func_15BE10
    ctx->pc = 0x17C350u;
    SET_GPR_U32(ctx, 31, 0x17C358u);
    ctx->pc = 0x17C354u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C350u;
            // 0x17c354: 0x24040001  addiu       $a0, $zero, 0x1 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
        ctx->in_delay_slot = false;
    ctx->pc = 0x15BE10u;
    if (runtime->hasFunction(0x15BE10u)) {
        auto targetFn = runtime->lookupFunction(0x15BE10u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C358u; }
        if (ctx->pc != 0x17C358u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        IsGamePlayerAvtive_0x15be10(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C358u; }
        if (ctx->pc != 0x17C358u) { return; }
    }
    ctx->pc = 0x17C358u;
    // 0x17c358: 0x1040000b  beqz        $v0, . + 4 + (0xB << 2)
    ctx->pc = 0x17C358u;
    {
        const bool branch_taken_0x17c358 = (GPR_U64(ctx, 2) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c358) {
            ctx->pc = 0x17C388u;
            goto label_17c388;
        }
    }
    ctx->pc = 0x17C360u;
    // 0x17c360: 0xc050bb4  jal         func_142ED0
    ctx->pc = 0x17C360u;
    SET_GPR_U32(ctx, 31, 0x17C368u);
    ctx->pc = 0x142ED0u;
    if (runtime->hasFunction(0x142ED0u)) {
        auto targetFn = runtime->lookupFunction(0x142ED0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C368u; }
        if (ctx->pc != 0x17C368u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsRand_0x142ed0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C368u; }
        if (ctx->pc != 0x17C368u) { return; }
    }
    ctx->pc = 0x17C368u;
    // 0x17c368: 0x2403000c  addiu       $v1, $zero, 0xC
    ctx->pc = 0x17c368u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 0), 12));
    // 0x17c36c: 0x43001b  divu        $zero, $v0, $v1
    ctx->pc = 0x17c36cu;
    { uint32_t divisor = GPR_U32(ctx, 3); if (divisor != 0) { ctx->lo = (uint64_t)(int64_t)(int32_t)(GPR_U32(ctx, 2) / divisor); ctx->hi = (uint64_t)(int64_t)(int32_t)(GPR_U32(ctx, 2) % divisor); } else { ctx->lo = 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)(int32_t)GPR_U32(ctx,2); } }
    // 0x17c370: 0x0  nop
    ctx->pc = 0x17c370u;
    // NOP
    // 0x17c374: 0x0  nop
    ctx->pc = 0x17c374u;
    // NOP
    // 0x17c378: 0x2810  mfhi        $a1
    ctx->pc = 0x17c378u;
    SET_GPR_U64(ctx, 5, ctx->hi);
    // 0x17c37c: 0xc055124  jal         func_154490
    ctx->pc = 0x17C37Cu;
    SET_GPR_U32(ctx, 31, 0x17C384u);
    ctx->pc = 0x17C380u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C37Cu;
            // 0x17c380: 0x24040001  addiu       $a0, $zero, 0x1 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
        ctx->in_delay_slot = false;
    ctx->pc = 0x154490u;
    if (runtime->hasFunction(0x154490u)) {
        auto targetFn = runtime->lookupFunction(0x154490u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C384u; }
        if (ctx->pc != 0x17C384u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsDualShock_0x154490(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C384u; }
        if (ctx->pc != 0x17C384u) { return; }
    }
    ctx->pc = 0x17C384u;
    // 0x17c384: 0x0  nop
    ctx->pc = 0x17c384u;
    // NOP
label_17c388:
    // 0x17c388: 0x8e240000  lw          $a0, 0x0($s1)
    ctx->pc = 0x17c388u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c38c: 0x3c0242f0  lui         $v0, 0x42F0
    ctx->pc = 0x17c38cu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)17136 << 16));
    // 0x17c390: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c390u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c394: 0xc4810124  lwc1        $f1, 0x124($a0)
    ctx->pc = 0x17c394u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 4), 292)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x17c398: 0x46000834  c.lt.s      $f1, $f0
    ctx->pc = 0x17c398u;
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17c39c: 0x45000020  bc1f        . + 4 + (0x20 << 2)
    ctx->pc = 0x17C39Cu;
    {
        const bool branch_taken_0x17c39c = (!(ctx->fcr31 & 0x800000));
        if (branch_taken_0x17c39c) {
            ctx->pc = 0x17C420u;
            goto label_17c420;
        }
    }
    ctx->pc = 0x17C3A4u;
    // 0x17c3a4: 0xc4830118  lwc1        $f3, 0x118($a0)
    ctx->pc = 0x17c3a4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 4), 280)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[3] = f; }
    // 0x17c3a8: 0x3c023a83  lui         $v0, 0x3A83
    ctx->pc = 0x17c3a8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)14979 << 16));
    // 0x17c3ac: 0x3443126f  ori         $v1, $v0, 0x126F
    ctx->pc = 0x17c3acu;
    SET_GPR_VEC(ctx, 3, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)4719u)));
    // 0x17c3b0: 0x3c023ba3  lui         $v0, 0x3BA3
    ctx->pc = 0x17c3b0u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)15267 << 16));
    // 0x17c3b4: 0x44830800  mtc1        $v1, $f1
    ctx->pc = 0x17c3b4u;
    { uint32_t bits = GPR_U32(ctx, 3); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17c3b8: 0x3442d70a  ori         $v0, $v0, 0xD70A
    ctx->pc = 0x17c3b8u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)55050u)));
    // 0x17c3bc: 0x44821000  mtc1        $v0, $f2
    ctx->pc = 0x17c3bcu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[2], &bits, sizeof(bits)); }
    // 0x17c3c0: 0x0  nop
    ctx->pc = 0x17c3c0u;
    // NOP
    // 0x17c3c4: 0x46011841  sub.s       $f1, $f3, $f1
    ctx->pc = 0x17c3c4u;
    ctx->f[1] = FPU_SUB_S(ctx->f[3], ctx->f[1]);
    // 0x17c3c8: 0x3c023b44  lui         $v0, 0x3B44
    ctx->pc = 0x17c3c8u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)15172 << 16));
    // 0x17c3cc: 0x34429ba6  ori         $v0, $v0, 0x9BA6
    ctx->pc = 0x17c3ccu;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)39846u)));
    // 0x17c3d0: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c3d0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c3d4: 0x0  nop
    ctx->pc = 0x17c3d4u;
    // NOP
    // 0x17c3d8: 0xe4810118  swc1        $f1, 0x118($a0)
    ctx->pc = 0x17c3d8u;
    { float f = ctx->f[1]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 4), 280), bits); }
    // 0x17c3dc: 0x8e220000  lw          $v0, 0x0($s1)
    ctx->pc = 0x17c3dcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c3e0: 0xc4410114  lwc1        $f1, 0x114($v0)
    ctx->pc = 0x17c3e0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 276)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x17c3e4: 0x46020841  sub.s       $f1, $f1, $f2
    ctx->pc = 0x17c3e4u;
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x17c3e8: 0xe4410114  swc1        $f1, 0x114($v0)
    ctx->pc = 0x17c3e8u;
    { float f = ctx->f[1]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 2), 276), bits); }
    // 0x17c3ec: 0x8e220000  lw          $v0, 0x0($s1)
    ctx->pc = 0x17c3ecu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c3f0: 0xc4410110  lwc1        $f1, 0x110($v0)
    ctx->pc = 0x17c3f0u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 272)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x17c3f4: 0x46000801  sub.s       $f0, $f1, $f0
    ctx->pc = 0x17c3f4u;
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x17c3f8: 0xe4400110  swc1        $f0, 0x110($v0)
    ctx->pc = 0x17c3f8u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 2), 272), bits); }
    // 0x17c3fc: 0x8e220000  lw          $v0, 0x0($s1)
    ctx->pc = 0x17c3fcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c400: 0xc62100d4  lwc1        $f1, 0xD4($s1)
    ctx->pc = 0x17c400u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x17c404: 0xc4400124  lwc1        $f0, 0x124($v0)
    ctx->pc = 0x17c404u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 2), 292)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c408: 0x46010000  add.s       $f0, $f0, $f1
    ctx->pc = 0x17c408u;
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17c40c: 0xe4400124  swc1        $f0, 0x124($v0)
    ctx->pc = 0x17c40cu;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 2), 292), bits); }
    // 0x17c410: 0xc62000d4  lwc1        $f0, 0xD4($s1)
    ctx->pc = 0x17c410u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c414: 0x46020000  add.s       $f0, $f0, $f2
    ctx->pc = 0x17c414u;
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x17c418: 0x1000009d  b           . + 4 + (0x9D << 2)
    ctx->pc = 0x17C418u;
    {
        const bool branch_taken_0x17c418 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x17C41Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C418u;
            // 0x17c41c: 0xe62000d4  swc1        $f0, 0xD4($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 212), bits); }
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c418) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17C420u;
label_17c420:
    // 0x17c420: 0xae2000d0  sw          $zero, 0xD0($s1)
    ctx->pc = 0x17c420u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 208), GPR_U32(ctx, 0));
    // 0x17c424: 0x3c024040  lui         $v0, 0x4040
    ctx->pc = 0x17c424u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)16448 << 16));
    // 0x17c428: 0x8e230020  lw          $v1, 0x20($s1)
    ctx->pc = 0x17c428u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x17c42c: 0x44821800  mtc1        $v0, $f3
    ctx->pc = 0x17c42cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[3], &bits, sizeof(bits)); }
    // 0x17c430: 0x8e24001c  lw          $a0, 0x1C($s1)
    ctx->pc = 0x17c430u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x17c434: 0xc62200d0  lwc1        $f2, 0xD0($s1)
    ctx->pc = 0x17c434u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 208)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[2] = f; }
    // 0x17c438: 0x3c02c040  lui         $v0, 0xC040
    ctx->pc = 0x17c438u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)49216 << 16));
    // 0x17c43c: 0xc62000d4  lwc1        $f0, 0xD4($s1)
    ctx->pc = 0x17c43cu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c440: 0x44820800  mtc1        $v0, $f1
    ctx->pc = 0x17c440u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[1], &bits, sizeof(bits)); }
    // 0x17c444: 0x2465fe0c  addiu       $a1, $v1, -0x1F4
    ctx->pc = 0x17c444u;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 3), 4294966796));
    // 0x17c448: 0x46021b02  mul.s       $f12, $f3, $f2
    ctx->pc = 0x17c448u;
    ctx->f[12] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    // 0x17c44c: 0xc053740  jal         func_14DD00
    ctx->pc = 0x17C44Cu;
    SET_GPR_U32(ctx, 31, 0x17C454u);
    ctx->pc = 0x17C450u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C44Cu;
            // 0x17c450: 0x46000b42  mul.s       $f13, $f1, $f0 (Delay Slot)
        ctx->f[13] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
        ctx->in_delay_slot = false;
    ctx->pc = 0x14DD00u;
    if (runtime->hasFunction(0x14DD00u)) {
        auto targetFn = runtime->lookupFunction(0x14DD00u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C454u; }
        if (ctx->pc != 0x17C454u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CreateExplosion_0x14dd00(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C454u; }
        if (ctx->pc != 0x17C454u) { return; }
    }
    ctx->pc = 0x17C454u;
    // 0x17c454: 0x24030007  addiu       $v1, $zero, 0x7
    ctx->pc = 0x17c454u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 0), 7));
    // 0x17c458: 0x3402ffff  ori         $v0, $zero, 0xFFFF
    ctx->pc = 0x17c458u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 0), _mm_cvtsi32_si128((int)65535u)));
    // 0x17c45c: 0xae230028  sw          $v1, 0x28($s1)
    ctx->pc = 0x17c45cu;
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 3));
    // 0x17c460: 0xae220008  sw          $v0, 0x8($s1)
    ctx->pc = 0x17c460u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x17c464: 0x1000008a  b           . + 4 + (0x8A << 2)
    ctx->pc = 0x17C464u;
    {
        const bool branch_taken_0x17c464 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x17C468u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C464u;
            // 0x17c468: 0xae200024  sw          $zero, 0x24($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c464) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17C46Cu;
    // 0x17c46c: 0x0  nop
    ctx->pc = 0x17c46cu;
    // NOP
label_17c470:
    // 0x17c470: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c470u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c474: 0x24020001  addiu       $v0, $zero, 0x1
    ctx->pc = 0x17c474u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
    // 0x17c478: 0x1462000d  bne         $v1, $v0, . + 4 + (0xD << 2)
    ctx->pc = 0x17C478u;
    {
        const bool branch_taken_0x17c478 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C47Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C478u;
            // 0x17c47c: 0x202d  daddu       $a0, $zero, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c478) {
            ctx->pc = 0x17C4B0u;
            goto label_17c4b0;
        }
    }
    ctx->pc = 0x17C480u;
    // 0x17c480: 0xc056f84  jal         func_15BE10
    ctx->pc = 0x17C480u;
    SET_GPR_U32(ctx, 31, 0x17C488u);
    ctx->pc = 0x15BE10u;
    if (runtime->hasFunction(0x15BE10u)) {
        auto targetFn = runtime->lookupFunction(0x15BE10u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C488u; }
        if (ctx->pc != 0x17C488u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        IsGamePlayerAvtive_0x15be10(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C488u; }
        if (ctx->pc != 0x17C488u) { return; }
    }
    ctx->pc = 0x17C488u;
    // 0x17c488: 0x10400003  beqz        $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C488u;
    {
        const bool branch_taken_0x17c488 = (GPR_U64(ctx, 2) == GPR_U64(ctx, 0));
        ctx->pc = 0x17C48Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C488u;
            // 0x17c48c: 0x202d  daddu       $a0, $zero, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c488) {
            ctx->pc = 0x17C498u;
            goto label_17c498;
        }
    }
    ctx->pc = 0x17C490u;
    // 0x17c490: 0xc055124  jal         func_154490
    ctx->pc = 0x17C490u;
    SET_GPR_U32(ctx, 31, 0x17C498u);
    ctx->pc = 0x17C494u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C490u;
            // 0x17c494: 0x2405000d  addiu       $a1, $zero, 0xD (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 0), 13));
        ctx->in_delay_slot = false;
    ctx->pc = 0x154490u;
    if (runtime->hasFunction(0x154490u)) {
        auto targetFn = runtime->lookupFunction(0x154490u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C498u; }
        if (ctx->pc != 0x17C498u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsDualShock_0x154490(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C498u; }
        if (ctx->pc != 0x17C498u) { return; }
    }
    ctx->pc = 0x17C498u;
label_17c498:
    // 0x17c498: 0xc056f84  jal         func_15BE10
    ctx->pc = 0x17C498u;
    SET_GPR_U32(ctx, 31, 0x17C4A0u);
    ctx->pc = 0x17C49Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C498u;
            // 0x17c49c: 0x24040001  addiu       $a0, $zero, 0x1 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
        ctx->in_delay_slot = false;
    ctx->pc = 0x15BE10u;
    if (runtime->hasFunction(0x15BE10u)) {
        auto targetFn = runtime->lookupFunction(0x15BE10u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C4A0u; }
        if (ctx->pc != 0x17C4A0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        IsGamePlayerAvtive_0x15be10(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C4A0u; }
        if (ctx->pc != 0x17C4A0u) { return; }
    }
    ctx->pc = 0x17C4A0u;
    // 0x17c4a0: 0x10400003  beqz        $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C4A0u;
    {
        const bool branch_taken_0x17c4a0 = (GPR_U64(ctx, 2) == GPR_U64(ctx, 0));
        ctx->pc = 0x17C4A4u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C4A0u;
            // 0x17c4a4: 0x24040001  addiu       $a0, $zero, 0x1 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c4a0) {
            ctx->pc = 0x17C4B0u;
            goto label_17c4b0;
        }
    }
    ctx->pc = 0x17C4A8u;
    // 0x17c4a8: 0xc055124  jal         func_154490
    ctx->pc = 0x17C4A8u;
    SET_GPR_U32(ctx, 31, 0x17C4B0u);
    ctx->pc = 0x17C4ACu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C4A8u;
            // 0x17c4ac: 0x2405000d  addiu       $a1, $zero, 0xD (Delay Slot)
        SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 0), 13));
        ctx->in_delay_slot = false;
    ctx->pc = 0x154490u;
    if (runtime->hasFunction(0x154490u)) {
        auto targetFn = runtime->lookupFunction(0x154490u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C4B0u; }
        if (ctx->pc != 0x17C4B0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        wrsDualShock_0x154490(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C4B0u; }
        if (ctx->pc != 0x17C4B0u) { return; }
    }
    ctx->pc = 0x17C4B0u;
label_17c4b0:
    // 0x17c4b0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c4b0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c4b4: 0x2402001e  addiu       $v0, $zero, 0x1E
    ctx->pc = 0x17c4b4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 30));
    // 0x17c4b8: 0x14620003  bne         $v1, $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C4B8u;
    {
        const bool branch_taken_0x17c4b8 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C4BCu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C4B8u;
            // 0x17c4bc: 0x24040001  addiu       $a0, $zero, 0x1 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c4b8) {
            ctx->pc = 0x17C4C8u;
            goto label_17c4c8;
        }
    }
    ctx->pc = 0x17C4C0u;
    // 0x17c4c0: 0xc060718  jal         func_181C60
    ctx->pc = 0x17C4C0u;
    SET_GPR_U32(ctx, 31, 0x17C4C8u);
    ctx->pc = 0x181C60u;
    if (runtime->hasFunction(0x181C60u)) {
        auto targetFn = runtime->lookupFunction(0x181C60u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C4C8u; }
        if (ctx->pc != 0x17C4C8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        FaderFuncSet_0x181c60(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C4C8u; }
        if (ctx->pc != 0x17C4C8u) { return; }
    }
    ctx->pc = 0x17C4C8u;
label_17c4c8:
    // 0x17c4c8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c4c8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c4cc: 0x2402001e  addiu       $v0, $zero, 0x1E
    ctx->pc = 0x17c4ccu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 30));
    // 0x17c4d0: 0x14620003  bne         $v1, $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C4D0u;
    {
        const bool branch_taken_0x17c4d0 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C4D4u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C4D0u;
            // 0x17c4d4: 0x24040024  addiu       $a0, $zero, 0x24 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 36));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c4d0) {
            ctx->pc = 0x17C4E0u;
            goto label_17c4e0;
        }
    }
    ctx->pc = 0x17C4D8u;
    // 0x17c4d8: 0xc05d110  jal         func_174440
    ctx->pc = 0x17C4D8u;
    SET_GPR_U32(ctx, 31, 0x17C4E0u);
    ctx->pc = 0x174440u;
    if (runtime->hasFunction(0x174440u)) {
        auto targetFn = runtime->lookupFunction(0x174440u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C4E0u; }
        if (ctx->pc != 0x17C4E0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_0x174440(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C4E0u; }
        if (ctx->pc != 0x17C4E0u) { return; }
    }
    ctx->pc = 0x17C4E0u;
label_17c4e0:
    // 0x17c4e0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c4e0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c4e4: 0x2402001f  addiu       $v0, $zero, 0x1F
    ctx->pc = 0x17c4e4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 31));
    // 0x17c4e8: 0x14620003  bne         $v1, $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C4E8u;
    {
        const bool branch_taken_0x17c4e8 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C4ECu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C4E8u;
            // 0x17c4ec: 0x24040023  addiu       $a0, $zero, 0x23 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 35));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c4e8) {
            ctx->pc = 0x17C4F8u;
            goto label_17c4f8;
        }
    }
    ctx->pc = 0x17C4F0u;
    // 0x17c4f0: 0xc05d110  jal         func_174440
    ctx->pc = 0x17C4F0u;
    SET_GPR_U32(ctx, 31, 0x17C4F8u);
    ctx->pc = 0x174440u;
    if (runtime->hasFunction(0x174440u)) {
        auto targetFn = runtime->lookupFunction(0x174440u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C4F8u; }
        if (ctx->pc != 0x17C4F8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_0x174440(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C4F8u; }
        if (ctx->pc != 0x17C4F8u) { return; }
    }
    ctx->pc = 0x17C4F8u;
label_17c4f8:
    // 0x17c4f8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c4f8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c4fc: 0x24020020  addiu       $v0, $zero, 0x20
    ctx->pc = 0x17c4fcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 32));
    // 0x17c500: 0x14620003  bne         $v1, $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C500u;
    {
        const bool branch_taken_0x17c500 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C504u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C500u;
            // 0x17c504: 0x24040022  addiu       $a0, $zero, 0x22 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 34));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c500) {
            ctx->pc = 0x17C510u;
            goto label_17c510;
        }
    }
    ctx->pc = 0x17C508u;
    // 0x17c508: 0xc05d110  jal         func_174440
    ctx->pc = 0x17C508u;
    SET_GPR_U32(ctx, 31, 0x17C510u);
    ctx->pc = 0x174440u;
    if (runtime->hasFunction(0x174440u)) {
        auto targetFn = runtime->lookupFunction(0x174440u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C510u; }
        if (ctx->pc != 0x17C510u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_0x174440(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C510u; }
        if (ctx->pc != 0x17C510u) { return; }
    }
    ctx->pc = 0x17C510u;
label_17c510:
    // 0x17c510: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c510u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c514: 0x24020021  addiu       $v0, $zero, 0x21
    ctx->pc = 0x17c514u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 33));
    // 0x17c518: 0x14620003  bne         $v1, $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C518u;
    {
        const bool branch_taken_0x17c518 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C51Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C518u;
            // 0x17c51c: 0x24040020  addiu       $a0, $zero, 0x20 (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 32));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c518) {
            ctx->pc = 0x17C528u;
            goto label_17c528;
        }
    }
    ctx->pc = 0x17C520u;
    // 0x17c520: 0xc05d110  jal         func_174440
    ctx->pc = 0x17C520u;
    SET_GPR_U32(ctx, 31, 0x17C528u);
    ctx->pc = 0x174440u;
    if (runtime->hasFunction(0x174440u)) {
        auto targetFn = runtime->lookupFunction(0x174440u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C528u; }
        if (ctx->pc != 0x17C528u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_0x174440(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C528u; }
        if (ctx->pc != 0x17C528u) { return; }
    }
    ctx->pc = 0x17C528u;
label_17c528:
    // 0x17c528: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c528u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c52c: 0x24020022  addiu       $v0, $zero, 0x22
    ctx->pc = 0x17c52cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 34));
    // 0x17c530: 0x14620003  bne         $v1, $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C530u;
    {
        const bool branch_taken_0x17c530 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C534u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C530u;
            // 0x17c534: 0x2404001f  addiu       $a0, $zero, 0x1F (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 31));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c530) {
            ctx->pc = 0x17C540u;
            goto label_17c540;
        }
    }
    ctx->pc = 0x17C538u;
    // 0x17c538: 0xc05d110  jal         func_174440
    ctx->pc = 0x17C538u;
    SET_GPR_U32(ctx, 31, 0x17C540u);
    ctx->pc = 0x174440u;
    if (runtime->hasFunction(0x174440u)) {
        auto targetFn = runtime->lookupFunction(0x174440u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C540u; }
        if (ctx->pc != 0x17C540u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_0x174440(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C540u; }
        if (ctx->pc != 0x17C540u) { return; }
    }
    ctx->pc = 0x17C540u;
label_17c540:
    // 0x17c540: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c540u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c544: 0x24020023  addiu       $v0, $zero, 0x23
    ctx->pc = 0x17c544u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 35));
    // 0x17c548: 0x14620003  bne         $v1, $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C548u;
    {
        const bool branch_taken_0x17c548 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C54Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C548u;
            // 0x17c54c: 0x2404001e  addiu       $a0, $zero, 0x1E (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 30));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c548) {
            ctx->pc = 0x17C558u;
            goto label_17c558;
        }
    }
    ctx->pc = 0x17C550u;
    // 0x17c550: 0xc05d110  jal         func_174440
    ctx->pc = 0x17C550u;
    SET_GPR_U32(ctx, 31, 0x17C558u);
    ctx->pc = 0x174440u;
    if (runtime->hasFunction(0x174440u)) {
        auto targetFn = runtime->lookupFunction(0x174440u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C558u; }
        if (ctx->pc != 0x17C558u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_0x174440(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C558u; }
        if (ctx->pc != 0x17C558u) { return; }
    }
    ctx->pc = 0x17C558u;
label_17c558:
    // 0x17c558: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c558u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c55c: 0x24020024  addiu       $v0, $zero, 0x24
    ctx->pc = 0x17c55cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 36));
    // 0x17c560: 0x14620003  bne         $v1, $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C560u;
    {
        const bool branch_taken_0x17c560 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C564u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C560u;
            // 0x17c564: 0x2404001c  addiu       $a0, $zero, 0x1C (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 28));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c560) {
            ctx->pc = 0x17C570u;
            goto label_17c570;
        }
    }
    ctx->pc = 0x17C568u;
    // 0x17c568: 0xc05d110  jal         func_174440
    ctx->pc = 0x17C568u;
    SET_GPR_U32(ctx, 31, 0x17C570u);
    ctx->pc = 0x174440u;
    if (runtime->hasFunction(0x174440u)) {
        auto targetFn = runtime->lookupFunction(0x174440u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C570u; }
        if (ctx->pc != 0x17C570u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_0x174440(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C570u; }
        if (ctx->pc != 0x17C570u) { return; }
    }
    ctx->pc = 0x17C570u;
label_17c570:
    // 0x17c570: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c570u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c574: 0x24020025  addiu       $v0, $zero, 0x25
    ctx->pc = 0x17c574u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 37));
    // 0x17c578: 0x14620003  bne         $v1, $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C578u;
    {
        const bool branch_taken_0x17c578 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C57Cu;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C578u;
            // 0x17c57c: 0x2404001b  addiu       $a0, $zero, 0x1B (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 27));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c578) {
            ctx->pc = 0x17C588u;
            goto label_17c588;
        }
    }
    ctx->pc = 0x17C580u;
    // 0x17c580: 0xc05d110  jal         func_174440
    ctx->pc = 0x17C580u;
    SET_GPR_U32(ctx, 31, 0x17C588u);
    ctx->pc = 0x174440u;
    if (runtime->hasFunction(0x174440u)) {
        auto targetFn = runtime->lookupFunction(0x174440u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C588u; }
        if (ctx->pc != 0x17C588u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_0x174440(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C588u; }
        if (ctx->pc != 0x17C588u) { return; }
    }
    ctx->pc = 0x17C588u;
label_17c588:
    // 0x17c588: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c588u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c58c: 0x24020026  addiu       $v0, $zero, 0x26
    ctx->pc = 0x17c58cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 38));
    // 0x17c590: 0x14620003  bne         $v1, $v0, . + 4 + (0x3 << 2)
    ctx->pc = 0x17C590u;
    {
        const bool branch_taken_0x17c590 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        ctx->pc = 0x17C594u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C590u;
            // 0x17c594: 0x2404001a  addiu       $a0, $zero, 0x1A (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 26));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c590) {
            ctx->pc = 0x17C5A0u;
            goto label_17c5a0;
        }
    }
    ctx->pc = 0x17C598u;
    // 0x17c598: 0xc05d110  jal         func_174440
    ctx->pc = 0x17C598u;
    SET_GPR_U32(ctx, 31, 0x17C5A0u);
    ctx->pc = 0x174440u;
    if (runtime->hasFunction(0x174440u)) {
        auto targetFn = runtime->lookupFunction(0x174440u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5A0u; }
        if (ctx->pc != 0x17C5A0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        play_se_0x174440(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5A0u; }
        if (ctx->pc != 0x17C5A0u) { return; }
    }
    ctx->pc = 0x17C5A0u;
label_17c5a0:
    // 0x17c5a0: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c5a0u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c5a4: 0x24020027  addiu       $v0, $zero, 0x27
    ctx->pc = 0x17c5a4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 39));
    // 0x17c5a8: 0x14620039  bne         $v1, $v0, . + 4 + (0x39 << 2)
    ctx->pc = 0x17C5A8u;
    {
        const bool branch_taken_0x17c5a8 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        if (branch_taken_0x17c5a8) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17C5B0u;
    // 0x17c5b0: 0xc056054  jal         func_158150
    ctx->pc = 0x17C5B0u;
    SET_GPR_U32(ctx, 31, 0x17C5B8u);
    ctx->pc = 0x158150u;
    if (runtime->hasFunction(0x158150u)) {
        auto targetFn = runtime->lookupFunction(0x158150u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5B8u; }
        if (ctx->pc != 0x17C5B8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        RnnyuNo_0x158150(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5B8u; }
        if (ctx->pc != 0x17C5B8u) { return; }
    }
    ctx->pc = 0x17C5B8u;
    // 0x17c5b8: 0xc05656c  jal         func_1595B0
    ctx->pc = 0x17C5B8u;
    SET_GPR_U32(ctx, 31, 0x17C5C0u);
    ctx->pc = 0x1595B0u;
    if (runtime->hasFunction(0x1595B0u)) {
        auto targetFn = runtime->lookupFunction(0x1595B0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5C0u; }
        if (ctx->pc != 0x17C5C0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        ResultStepInit_0x1595b0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5C0u; }
        if (ctx->pc != 0x17C5C0u) { return; }
    }
    ctx->pc = 0x17C5C0u;
    // 0x17c5c0: 0xc056530  jal         func_1594C0
    ctx->pc = 0x17C5C0u;
    SET_GPR_U32(ctx, 31, 0x17C5C8u);
    ctx->pc = 0x17C5C4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C5C0u;
            // 0x17c5c4: 0x8e240014  lw          $a0, 0x14($s1) (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1594C0u;
    if (runtime->hasFunction(0x1594C0u)) {
        auto targetFn = runtime->lookupFunction(0x1594C0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5C8u; }
        if (ctx->pc != 0x17C5C8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        BossResultSet_0x1594c0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5C8u; }
        if (ctx->pc != 0x17C5C8u) { return; }
    }
    ctx->pc = 0x17C5C8u;
    // 0x17c5c8: 0xc05886c  jal         func_1621B0
    ctx->pc = 0x17C5C8u;
    SET_GPR_U32(ctx, 31, 0x17C5D0u);
    ctx->pc = 0x17C5CCu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C5C8u;
            // 0x17c5cc: 0x202d  daddu       $a0, $zero, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1621B0u;
    if (runtime->hasFunction(0x1621B0u)) {
        auto targetFn = runtime->lookupFunction(0x1621B0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5D0u; }
        if (ctx->pc != 0x17C5D0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        bossStateSet_0x1621b0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5D0u; }
        if (ctx->pc != 0x17C5D0u) { return; }
    }
    ctx->pc = 0x17C5D0u;
    // 0x17c5d0: 0xc05b984  jal         func_16E610
    ctx->pc = 0x17C5D0u;
    SET_GPR_U32(ctx, 31, 0x17C5D8u);
    ctx->pc = 0x17C5D4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C5D0u;
            // 0x17c5d4: 0x220202d  daddu       $a0, $s1, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x16E610u;
    if (runtime->hasFunction(0x16E610u)) {
        auto targetFn = runtime->lookupFunction(0x16E610u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5D8u; }
        if (ctx->pc != 0x17C5D8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Enemy_BloadCast_Child_Dead_0x16e610(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5D8u; }
        if (ctx->pc != 0x17C5D8u) { return; }
    }
    ctx->pc = 0x17C5D8u;
    // 0x17c5d8: 0x1000017b  b           . + 4 + (0x17B << 2)
    ctx->pc = 0x17C5D8u;
    {
        const bool branch_taken_0x17c5d8 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c5d8) {
            ctx->pc = 0x17CBC8u;
            goto label_17cbc8;
        }
    }
    ctx->pc = 0x17C5E0u;
label_17c5e0:
    // 0x17c5e0: 0xc0656b4  jal         func_195AD0
    ctx->pc = 0x17C5E0u;
    SET_GPR_U32(ctx, 31, 0x17C5E8u);
    ctx->pc = 0x195AD0u;
    if (runtime->hasFunction(0x195AD0u)) {
        auto targetFn = runtime->lookupFunction(0x195AD0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5E8u; }
        if (ctx->pc != 0x17C5E8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        EnemyShotBloadCastDead2_0x195ad0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C5E8u; }
        if (ctx->pc != 0x17C5E8u) { return; }
    }
    ctx->pc = 0x17C5E8u;
    // 0x17c5e8: 0x8e230000  lw          $v1, 0x0($s1)
    ctx->pc = 0x17c5e8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c5ec: 0x3c02c396  lui         $v0, 0xC396
    ctx->pc = 0x17c5ecu;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)50070 << 16));
    // 0x17c5f0: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c5f0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c5f4: 0xc4610124  lwc1        $f1, 0x124($v1)
    ctx->pc = 0x17c5f4u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 3), 292)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x17c5f8: 0x46000836  c.le.s      $f1, $f0
    ctx->pc = 0x17c5f8u;
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17c5fc: 0x4501000a  bc1t        . + 4 + (0xA << 2)
    ctx->pc = 0x17C5FCu;
    {
        const bool branch_taken_0x17c5fc = ((ctx->fcr31 & 0x800000));
        ctx->pc = 0x17C600u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C5FCu;
            // 0x17c600: 0x24620124  addiu       $v0, $v1, 0x124 (Delay Slot)
        SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 3), 292));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c5fc) {
            ctx->pc = 0x17C628u;
            goto label_17c628;
        }
    }
    ctx->pc = 0x17C604u;
    // 0x17c604: 0xc62100d4  lwc1        $f1, 0xD4($s1)
    ctx->pc = 0x17c604u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 17), 212)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[1] = f; }
    // 0x17c608: 0x3c023cf5  lui         $v0, 0x3CF5
    ctx->pc = 0x17c608u;
    SET_GPR_S32(ctx, 2, (int32_t)((uint32_t)15605 << 16));
    // 0x17c60c: 0x3442c28f  ori         $v0, $v0, 0xC28F
    ctx->pc = 0x17c60cu;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 2), _mm_cvtsi32_si128((int)49807u)));
    // 0x17c610: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c610u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c614: 0x0  nop
    ctx->pc = 0x17c614u;
    // NOP
    // 0x17c618: 0x46000801  sub.s       $f0, $f1, $f0
    ctx->pc = 0x17c618u;
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x17c61c: 0x1000001c  b           . + 4 + (0x1C << 2)
    ctx->pc = 0x17C61Cu;
    {
        const bool branch_taken_0x17c61c = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x17C620u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C61Cu;
            // 0x17c620: 0xe62000d4  swc1        $f0, 0xD4($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 212), bits); }
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c61c) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17C624u;
    // 0x17c624: 0x0  nop
    ctx->pc = 0x17c624u;
    // NOP
label_17c628:
    // 0x17c628: 0x24030009  addiu       $v1, $zero, 0x9
    ctx->pc = 0x17c628u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 0), 9));
    // 0x17c62c: 0xe4400000  swc1        $f0, 0x0($v0)
    ctx->pc = 0x17c62cu;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 2), 0), bits); }
    // 0x17c630: 0xae2000d0  sw          $zero, 0xD0($s1)
    ctx->pc = 0x17c630u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 208), GPR_U32(ctx, 0));
    // 0x17c634: 0x3402ffff  ori         $v0, $zero, 0xFFFF
    ctx->pc = 0x17c634u;
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 0), _mm_cvtsi32_si128((int)65535u)));
    // 0x17c638: 0xae2000d4  sw          $zero, 0xD4($s1)
    ctx->pc = 0x17c638u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 212), GPR_U32(ctx, 0));
    // 0x17c63c: 0xae230028  sw          $v1, 0x28($s1)
    ctx->pc = 0x17c63cu;
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 3));
    // 0x17c640: 0xae220008  sw          $v0, 0x8($s1)
    ctx->pc = 0x17c640u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x17c644: 0x10000012  b           . + 4 + (0x12 << 2)
    ctx->pc = 0x17C644u;
    {
        const bool branch_taken_0x17c644 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x17C648u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C644u;
            // 0x17c648: 0xae200024  sw          $zero, 0x24($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c644) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17C64Cu;
    // 0x17c64c: 0x0  nop
    ctx->pc = 0x17c64cu;
    // NOP
label_17c650:
    // 0x17c650: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c650u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c654: 0x24020028  addiu       $v0, $zero, 0x28
    ctx->pc = 0x17c654u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 40));
    // 0x17c658: 0x1462000d  bne         $v1, $v0, . + 4 + (0xD << 2)
    ctx->pc = 0x17C658u;
    {
        const bool branch_taken_0x17c658 = (GPR_U64(ctx, 3) != GPR_U64(ctx, 2));
        if (branch_taken_0x17c658) {
            ctx->pc = 0x17C690u;
            goto label_17c690;
        }
    }
    ctx->pc = 0x17C660u;
    // 0x17c660: 0xc056054  jal         func_158150
    ctx->pc = 0x17C660u;
    SET_GPR_U32(ctx, 31, 0x17C668u);
    ctx->pc = 0x158150u;
    if (runtime->hasFunction(0x158150u)) {
        auto targetFn = runtime->lookupFunction(0x158150u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C668u; }
        if (ctx->pc != 0x17C668u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        RnnyuNo_0x158150(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C668u; }
        if (ctx->pc != 0x17C668u) { return; }
    }
    ctx->pc = 0x17C668u;
    // 0x17c668: 0xc05656c  jal         func_1595B0
    ctx->pc = 0x17C668u;
    SET_GPR_U32(ctx, 31, 0x17C670u);
    ctx->pc = 0x1595B0u;
    if (runtime->hasFunction(0x1595B0u)) {
        auto targetFn = runtime->lookupFunction(0x1595B0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C670u; }
        if (ctx->pc != 0x17C670u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        ResultStepInit_0x1595b0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C670u; }
        if (ctx->pc != 0x17C670u) { return; }
    }
    ctx->pc = 0x17C670u;
    // 0x17c670: 0xc056530  jal         func_1594C0
    ctx->pc = 0x17C670u;
    SET_GPR_U32(ctx, 31, 0x17C678u);
    ctx->pc = 0x17C674u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C670u;
            // 0x17c674: 0x8e240014  lw          $a0, 0x14($s1) (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1594C0u;
    if (runtime->hasFunction(0x1594C0u)) {
        auto targetFn = runtime->lookupFunction(0x1594C0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C678u; }
        if (ctx->pc != 0x17C678u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        BossResultSet_0x1594c0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C678u; }
        if (ctx->pc != 0x17C678u) { return; }
    }
    ctx->pc = 0x17C678u;
    // 0x17c678: 0xc05886c  jal         func_1621B0
    ctx->pc = 0x17C678u;
    SET_GPR_U32(ctx, 31, 0x17C680u);
    ctx->pc = 0x17C67Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C678u;
            // 0x17c67c: 0x202d  daddu       $a0, $zero, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 0) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1621B0u;
    if (runtime->hasFunction(0x1621B0u)) {
        auto targetFn = runtime->lookupFunction(0x1621B0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C680u; }
        if (ctx->pc != 0x17C680u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        bossStateSet_0x1621b0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C680u; }
        if (ctx->pc != 0x17C680u) { return; }
    }
    ctx->pc = 0x17C680u;
    // 0x17c680: 0xc05b984  jal         func_16E610
    ctx->pc = 0x17C680u;
    SET_GPR_U32(ctx, 31, 0x17C688u);
    ctx->pc = 0x17C684u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C680u;
            // 0x17c684: 0x220202d  daddu       $a0, $s1, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x16E610u;
    if (runtime->hasFunction(0x16E610u)) {
        auto targetFn = runtime->lookupFunction(0x16E610u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C688u; }
        if (ctx->pc != 0x17C688u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Enemy_BloadCast_Child_Dead_0x16e610(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C688u; }
        if (ctx->pc != 0x17C688u) { return; }
    }
    ctx->pc = 0x17C688u;
    // 0x17c688: 0x1000014f  b           . + 4 + (0x14F << 2)
    ctx->pc = 0x17C688u;
    {
        const bool branch_taken_0x17c688 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c688) {
            ctx->pc = 0x17CBC8u;
            goto label_17cbc8;
        }
    }
    ctx->pc = 0x17C690u;
label_17c690:
    // 0x17c690: 0xc05b9ac  jal         func_16E6B0
    ctx->pc = 0x17C690u;
    SET_GPR_U32(ctx, 31, 0x17C698u);
    ctx->pc = 0x17C694u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C690u;
            // 0x17c694: 0x220202d  daddu       $a0, $s1, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x16E6B0u;
    if (runtime->hasFunction(0x16E6B0u)) {
        auto targetFn = runtime->lookupFunction(0x16E6B0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C698u; }
        if (ctx->pc != 0x17C698u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Enemy_BloadCast_Child_Vector_0x16e6b0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C698u; }
        if (ctx->pc != 0x17C698u) { return; }
    }
    ctx->pc = 0x17C698u;
    // 0x17c698: 0xc05b9a0  jal         func_16E680
    ctx->pc = 0x17C698u;
    SET_GPR_U32(ctx, 31, 0x17C6A0u);
    ctx->pc = 0x17C69Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C698u;
            // 0x17c69c: 0x220202d  daddu       $a0, $s1, $zero (Delay Slot)
        SET_GPR_U64(ctx, 4, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x16E680u;
    if (runtime->hasFunction(0x16E680u)) {
        auto targetFn = runtime->lookupFunction(0x16E680u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6A0u; }
        if (ctx->pc != 0x17C6A0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        Enemy_BloadCast_Child_State_0x16e680(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6A0u; }
        if (ctx->pc != 0x17C6A0u) { return; }
    }
    ctx->pc = 0x17C6A0u;
    // 0x17c6a0: 0xc04b788  jal         func_12DE20
    ctx->pc = 0x17C6A0u;
    SET_GPR_U32(ctx, 31, 0x17C6A8u);
    ctx->pc = 0x17C6A4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C6A0u;
            // 0x17c6a4: 0x8e240000  lw          $a0, 0x0($s1) (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->in_delay_slot = false;
    ctx->pc = 0x12DE20u;
    if (runtime->hasFunction(0x12DE20u)) {
        auto targetFn = runtime->lookupFunction(0x12DE20u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6A8u; }
        if (ctx->pc != 0x17C6A8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        sceVu0UnitMatrix_0x12de20(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6A8u; }
        if (ctx->pc != 0x17C6A8u) { return; }
    }
    ctx->pc = 0x17C6A8u;
    // 0x17c6a8: 0x8e240000  lw          $a0, 0x0($s1)
    ctx->pc = 0x17c6a8u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c6ac: 0xc48c0110  lwc1        $f12, 0x110($a0)
    ctx->pc = 0x17c6acu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 4), 272)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[12] = f; }
    // 0x17c6b0: 0xc04b7da  jal         func_12DF68
    ctx->pc = 0x17C6B0u;
    SET_GPR_U32(ctx, 31, 0x17C6B8u);
    ctx->pc = 0x17C6B4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C6B0u;
            // 0x17c6b4: 0x80282d  daddu       $a1, $a0, $zero (Delay Slot)
        SET_GPR_U64(ctx, 5, (uint64_t)GPR_U64(ctx, 4) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x12DF68u;
    if (runtime->hasFunction(0x12DF68u)) {
        auto targetFn = runtime->lookupFunction(0x12DF68u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6B8u; }
        if (ctx->pc != 0x17C6B8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        sceVu0RotMatrixX_0x12df68(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6B8u; }
        if (ctx->pc != 0x17C6B8u) { return; }
    }
    ctx->pc = 0x17C6B8u;
    // 0x17c6b8: 0x8e240000  lw          $a0, 0x0($s1)
    ctx->pc = 0x17c6b8u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c6bc: 0xc48c0114  lwc1        $f12, 0x114($a0)
    ctx->pc = 0x17c6bcu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 4), 276)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[12] = f; }
    // 0x17c6c0: 0xc04b804  jal         func_12E010
    ctx->pc = 0x17C6C0u;
    SET_GPR_U32(ctx, 31, 0x17C6C8u);
    ctx->pc = 0x17C6C4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C6C0u;
            // 0x17c6c4: 0x80282d  daddu       $a1, $a0, $zero (Delay Slot)
        SET_GPR_U64(ctx, 5, (uint64_t)GPR_U64(ctx, 4) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x12E010u;
    if (runtime->hasFunction(0x12E010u)) {
        auto targetFn = runtime->lookupFunction(0x12E010u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6C8u; }
        if (ctx->pc != 0x17C6C8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        sceVu0RotMatrixY_0x12e010(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6C8u; }
        if (ctx->pc != 0x17C6C8u) { return; }
    }
    ctx->pc = 0x17C6C8u;
    // 0x17c6c8: 0x8e240000  lw          $a0, 0x0($s1)
    ctx->pc = 0x17c6c8u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c6cc: 0xc48c0118  lwc1        $f12, 0x118($a0)
    ctx->pc = 0x17c6ccu;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 4), 280)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[12] = f; }
    // 0x17c6d0: 0xc04b7b0  jal         func_12DEC0
    ctx->pc = 0x17C6D0u;
    SET_GPR_U32(ctx, 31, 0x17C6D8u);
    ctx->pc = 0x17C6D4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C6D0u;
            // 0x17c6d4: 0x80282d  daddu       $a1, $a0, $zero (Delay Slot)
        SET_GPR_U64(ctx, 5, (uint64_t)GPR_U64(ctx, 4) + (uint64_t)GPR_U64(ctx, 0));
        ctx->in_delay_slot = false;
    ctx->pc = 0x12DEC0u;
    if (runtime->hasFunction(0x12DEC0u)) {
        auto targetFn = runtime->lookupFunction(0x12DEC0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6D8u; }
        if (ctx->pc != 0x17C6D8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        sceVu0RotMatrixZ_0x12dec0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6D8u; }
        if (ctx->pc != 0x17C6D8u) { return; }
    }
    ctx->pc = 0x17C6D8u;
    // 0x17c6d8: 0x8e240000  lw          $a0, 0x0($s1)
    ctx->pc = 0x17c6d8u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c6dc: 0x80282d  daddu       $a1, $a0, $zero
    ctx->pc = 0x17c6dcu;
    SET_GPR_U64(ctx, 5, (uint64_t)GPR_U64(ctx, 4) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c6e0: 0xc04b75e  jal         func_12DD78
    ctx->pc = 0x17C6E0u;
    SET_GPR_U32(ctx, 31, 0x17C6E8u);
    ctx->pc = 0x17C6E4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C6E0u;
            // 0x17c6e4: 0x24860120  addiu       $a2, $a0, 0x120 (Delay Slot)
        SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 4), 288));
        ctx->in_delay_slot = false;
    ctx->pc = 0x12DD78u;
    if (runtime->hasFunction(0x12DD78u)) {
        auto targetFn = runtime->lookupFunction(0x12DD78u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6E8u; }
        if (ctx->pc != 0x17C6E8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        sceVu0TransMatrix_0x12dd78(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C6E8u; }
        if (ctx->pc != 0x17C6E8u) { return; }
    }
    ctx->pc = 0x17C6E8u;
    // 0x17c6e8: 0x8e230008  lw          $v1, 0x8($s1)
    ctx->pc = 0x17c6e8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x17c6ec: 0x8e22000c  lw          $v0, 0xC($s1)
    ctx->pc = 0x17c6ecu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x17c6f0: 0x62082a  slt         $at, $v1, $v0
    ctx->pc = 0x17c6f0u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 3) < (int64_t)GPR_S64(ctx, 2)) ? 1 : 0);
    // 0x17c6f4: 0x10200014  beqz        $at, . + 4 + (0x14 << 2)
    ctx->pc = 0x17C6F4u;
    {
        const bool branch_taken_0x17c6f4 = (GPR_U64(ctx, 1) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c6f4) {
            ctx->pc = 0x17C748u;
            goto label_17c748;
        }
    }
    ctx->pc = 0x17C6FCu;
    // 0x17c6fc: 0x8e22010c  lw          $v0, 0x10C($s1)
    ctx->pc = 0x17c6fcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 268)));
    // 0x17c700: 0x10400005  beqz        $v0, . + 4 + (0x5 << 2)
    ctx->pc = 0x17C700u;
    {
        const bool branch_taken_0x17c700 = (GPR_U64(ctx, 2) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c700) {
            ctx->pc = 0x17C718u;
            goto label_17c718;
        }
    }
    ctx->pc = 0x17C708u;
    // 0x17c708: 0xc0604f0  jal         func_1813C0
    ctx->pc = 0x17C708u;
    SET_GPR_U32(ctx, 31, 0x17C710u);
    ctx->pc = 0x17C70Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C708u;
            // 0x17c70c: 0x8e240000  lw          $a0, 0x0($s1) (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1813C0u;
    if (runtime->hasFunction(0x1813C0u)) {
        auto targetFn = runtime->lookupFunction(0x1813C0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C710u; }
        if (ctx->pc != 0x17C710u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CloneFlashColor_0x1813c0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C710u; }
        if (ctx->pc != 0x17C710u) { return; }
    }
    ctx->pc = 0x17C710u;
    // 0x17c710: 0x10000003  b           . + 4 + (0x3 << 2)
    ctx->pc = 0x17C710u;
    {
        const bool branch_taken_0x17c710 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c710) {
            ctx->pc = 0x17C720u;
            goto label_17c720;
        }
    }
    ctx->pc = 0x17C718u;
label_17c718:
    // 0x17c718: 0xc0604dc  jal         func_181370
    ctx->pc = 0x17C718u;
    SET_GPR_U32(ctx, 31, 0x17C720u);
    ctx->pc = 0x17C71Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C718u;
            // 0x17c71c: 0x8e240000  lw          $a0, 0x0($s1) (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->in_delay_slot = false;
    ctx->pc = 0x181370u;
    if (runtime->hasFunction(0x181370u)) {
        auto targetFn = runtime->lookupFunction(0x181370u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C720u; }
        if (ctx->pc != 0x17C720u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CloneStdColor_0x181370(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C720u; }
        if (ctx->pc != 0x17C720u) { return; }
    }
    ctx->pc = 0x17C720u;
label_17c720:
    // 0x17c720: 0x8e23010c  lw          $v1, 0x10C($s1)
    ctx->pc = 0x17c720u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 268)));
    // 0x17c724: 0x10600004  beqz        $v1, . + 4 + (0x4 << 2)
    ctx->pc = 0x17C724u;
    {
        const bool branch_taken_0x17c724 = (GPR_U64(ctx, 3) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c724) {
            ctx->pc = 0x17C738u;
            goto label_17c738;
        }
    }
    ctx->pc = 0x17C72Cu;
    // 0x17c72c: 0x1000001a  b           . + 4 + (0x1A << 2)
    ctx->pc = 0x17C72Cu;
    {
        const bool branch_taken_0x17c72c = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x17C730u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C72Cu;
            // 0x17c730: 0xae20010c  sw          $zero, 0x10C($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 268), GPR_U32(ctx, 0));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c72c) {
            ctx->pc = 0x17C798u;
            goto label_17c798;
        }
    }
    ctx->pc = 0x17C734u;
    // 0x17c734: 0x0  nop
    ctx->pc = 0x17c734u;
    // NOP
label_17c738:
    // 0x17c738: 0x24030001  addiu       $v1, $zero, 0x1
    ctx->pc = 0x17c738u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
    // 0x17c73c: 0x10000016  b           . + 4 + (0x16 << 2)
    ctx->pc = 0x17C73Cu;
    {
        const bool branch_taken_0x17c73c = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x17C740u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C73Cu;
            // 0x17c740: 0xae23010c  sw          $v1, 0x10C($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 268), GPR_U32(ctx, 3));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c73c) {
            ctx->pc = 0x17C798u;
            goto label_17c798;
        }
    }
    ctx->pc = 0x17C744u;
    // 0x17c744: 0x0  nop
    ctx->pc = 0x17c744u;
    // NOP
label_17c748:
    // 0x17c748: 0x286102bc  slti        $at, $v1, 0x2BC
    ctx->pc = 0x17c748u;
    SET_GPR_U64(ctx, 1, ((int64_t)GPR_S64(ctx, 3) < (int64_t)(int32_t)700) ? 1 : 0);
    // 0x17c74c: 0x1020000e  beqz        $at, . + 4 + (0xE << 2)
    ctx->pc = 0x17C74Cu;
    {
        const bool branch_taken_0x17c74c = (GPR_U64(ctx, 1) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c74c) {
            ctx->pc = 0x17C788u;
            goto label_17c788;
        }
    }
    ctx->pc = 0x17C754u;
    // 0x17c754: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17c754u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17c758: 0x2402000a  addiu       $v0, $zero, 0xA
    ctx->pc = 0x17c758u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 10));
    // 0x17c75c: 0x62001a  div         $zero, $v1, $v0
    ctx->pc = 0x17c75cu;
    { int32_t divisor = GPR_S32(ctx, 2);    int32_t dividend = GPR_S32(ctx, 3);    if (divisor != 0) {        if (divisor == -1 && dividend == INT32_MIN) {            ctx->lo = (uint64_t)(int64_t)INT32_MIN; ctx->hi = 0;        } else {            ctx->lo = (uint64_t)(int64_t)(dividend / divisor);            ctx->hi = (uint64_t)(int64_t)(dividend % divisor);        }    } else {        ctx->lo = (dividend < 0) ? 1ull : 0xFFFFFFFFFFFFFFFFull; ctx->hi = (uint64_t)(int64_t)dividend;    } }
    // 0x17c760: 0x0  nop
    ctx->pc = 0x17c760u;
    // NOP
    // 0x17c764: 0x0  nop
    ctx->pc = 0x17c764u;
    // NOP
    // 0x17c768: 0x1010  mfhi        $v0
    ctx->pc = 0x17c768u;
    SET_GPR_U64(ctx, 2, ctx->hi);
    // 0x17c76c: 0x14400006  bnez        $v0, . + 4 + (0x6 << 2)
    ctx->pc = 0x17C76Cu;
    {
        const bool branch_taken_0x17c76c = (GPR_U64(ctx, 2) != GPR_U64(ctx, 0));
        if (branch_taken_0x17c76c) {
            ctx->pc = 0x17C788u;
            goto label_17c788;
        }
    }
    ctx->pc = 0x17C774u;
    // 0x17c774: 0xc060500  jal         func_181400
    ctx->pc = 0x17C774u;
    SET_GPR_U32(ctx, 31, 0x17C77Cu);
    ctx->pc = 0x17C778u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C774u;
            // 0x17c778: 0x8e240000  lw          $a0, 0x0($s1) (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->in_delay_slot = false;
    ctx->pc = 0x181400u;
    if (runtime->hasFunction(0x181400u)) {
        auto targetFn = runtime->lookupFunction(0x181400u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C77Cu; }
        if (ctx->pc != 0x17C77Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CloneRedColor_0x181400(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C77Cu; }
        if (ctx->pc != 0x17C77Cu) { return; }
    }
    ctx->pc = 0x17C77Cu;
    // 0x17c77c: 0x10000004  b           . + 4 + (0x4 << 2)
    ctx->pc = 0x17C77Cu;
    {
        const bool branch_taken_0x17c77c = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c77c) {
            ctx->pc = 0x17C790u;
            goto label_17c790;
        }
    }
    ctx->pc = 0x17C784u;
    // 0x17c784: 0x0  nop
    ctx->pc = 0x17c784u;
    // NOP
label_17c788:
    // 0x17c788: 0xc0604dc  jal         func_181370
    ctx->pc = 0x17C788u;
    SET_GPR_U32(ctx, 31, 0x17C790u);
    ctx->pc = 0x17C78Cu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C788u;
            // 0x17c78c: 0x8e240000  lw          $a0, 0x0($s1) (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->in_delay_slot = false;
    ctx->pc = 0x181370u;
    if (runtime->hasFunction(0x181370u)) {
        auto targetFn = runtime->lookupFunction(0x181370u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C790u; }
        if (ctx->pc != 0x17C790u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CloneStdColor_0x181370(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C790u; }
        if (ctx->pc != 0x17C790u) { return; }
    }
    ctx->pc = 0x17C790u;
label_17c790:
    // 0x17c790: 0x24030001  addiu       $v1, $zero, 0x1
    ctx->pc = 0x17c790u;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 0), 1));
    // 0x17c794: 0xae23010c  sw          $v1, 0x10C($s1)
    ctx->pc = 0x17c794u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 268), GPR_U32(ctx, 3));
label_17c798:
    // 0x17c798: 0x8e230008  lw          $v1, 0x8($s1)
    ctx->pc = 0x17c798u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x17c79c: 0xae23000c  sw          $v1, 0xC($s1)
    ctx->pc = 0x17c79cu;
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 3));
    // 0x17c7a0: 0x8e240008  lw          $a0, 0x8($s1)
    ctx->pc = 0x17c7a0u;
    SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x17c7a4: 0x1c80000c  bgtz        $a0, . + 4 + (0xC << 2)
    ctx->pc = 0x17C7A4u;
    {
        const bool branch_taken_0x17c7a4 = (GPR_S32(ctx, 4) > 0);
        if (branch_taken_0x17c7a4) {
            ctx->pc = 0x17C7D8u;
            goto label_17c7d8;
        }
    }
    ctx->pc = 0x17C7ACu;
    // 0x17c7ac: 0x24020006  addiu       $v0, $zero, 0x6
    ctx->pc = 0x17c7acu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 0), 6));
    // 0x17c7b0: 0xae220028  sw          $v0, 0x28($s1)
    ctx->pc = 0x17c7b0u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 2));
    // 0x17c7b4: 0x8e220120  lw          $v0, 0x120($s1)
    ctx->pc = 0x17c7b4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x17c7b8: 0x24420001  addiu       $v0, $v0, 0x1
    ctx->pc = 0x17c7b8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 1));
    // 0x17c7bc: 0xae220120  sw          $v0, 0x120($s1)
    ctx->pc = 0x17c7bcu;
    WRITE32(ADD32(GPR_U32(ctx, 17), 288), GPR_U32(ctx, 2));
    // 0x17c7c0: 0x8e250120  lw          $a1, 0x120($s1)
    ctx->pc = 0x17c7c0u;
    SET_GPR_S32(ctx, 5, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x17c7c4: 0xc0604b0  jal         func_1812C0
    ctx->pc = 0x17C7C4u;
    SET_GPR_U32(ctx, 31, 0x17C7CCu);
    ctx->pc = 0x17C7C8u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C7C4u;
            // 0x17c7c8: 0x8e240000  lw          $a0, 0x0($s1) (Delay Slot)
        SET_GPR_S32(ctx, 4, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->in_delay_slot = false;
    ctx->pc = 0x1812C0u;
    if (runtime->hasFunction(0x1812C0u)) {
        auto targetFn = runtime->lookupFunction(0x1812C0u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C7CCu; }
        if (ctx->pc != 0x17C7CCu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CloneStdColorToRed_0x1812c0(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C7CCu; }
        if (ctx->pc != 0x17C7CCu) { return; }
    }
    ctx->pc = 0x17C7CCu;
    // 0x17c7cc: 0x100000fa  b           . + 4 + (0xFA << 2)
    ctx->pc = 0x17C7CCu;
    {
        const bool branch_taken_0x17c7cc = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        if (branch_taken_0x17c7cc) {
            ctx->pc = 0x17CBB8u;
            goto label_17cbb8;
        }
    }
    ctx->pc = 0x17C7D4u;
    // 0x17c7d4: 0x0  nop
    ctx->pc = 0x17c7d4u;
    // NOP
label_17c7d8:
    // 0x17c7d8: 0x8e230014  lw          $v1, 0x14($s1)
    ctx->pc = 0x17c7d8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x17c7dc: 0x4610006  bgez        $v1, . + 4 + (0x6 << 2)
    ctx->pc = 0x17C7DCu;
    {
        const bool branch_taken_0x17c7dc = (GPR_S32(ctx, 3) >= 0);
        ctx->pc = 0x17C7E0u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C7DCu;
            // 0x17c7e0: 0x3403ffff  ori         $v1, $zero, 0xFFFF (Delay Slot)
        SET_GPR_VEC(ctx, 3, PS2_POR(GPR_VEC(ctx, 0), _mm_cvtsi32_si128((int)65535u)));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c7dc) {
            ctx->pc = 0x17C7F8u;
            goto label_17c7f8;
        }
    }
    ctx->pc = 0x17C7E4u;
    // 0x17c7e4: 0x10830004  beq         $a0, $v1, . + 4 + (0x4 << 2)
    ctx->pc = 0x17C7E4u;
    {
        const bool branch_taken_0x17c7e4 = (GPR_U64(ctx, 4) == GPR_U64(ctx, 3));
        if (branch_taken_0x17c7e4) {
            ctx->pc = 0x17C7F8u;
            goto label_17c7f8;
        }
    }
    ctx->pc = 0x17C7ECu;
    // 0x17c7ec: 0x24030008  addiu       $v1, $zero, 0x8
    ctx->pc = 0x17c7ecu;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 0), 8));
    // 0x17c7f0: 0x100000f1  b           . + 4 + (0xF1 << 2)
    ctx->pc = 0x17C7F0u;
    {
        const bool branch_taken_0x17c7f0 = (GPR_U64(ctx, 0) == GPR_U64(ctx, 0));
        ctx->pc = 0x17C7F4u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17C7F0u;
            // 0x17c7f4: 0xae230028  sw          $v1, 0x28($s1) (Delay Slot)
        WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 3));
        ctx->in_delay_slot = false;
        if (branch_taken_0x17c7f0) {
            ctx->pc = 0x17CBB8u;
            goto label_17cbb8;
        }
    }
    ctx->pc = 0x17C7F8u;
label_17c7f8:
    // 0x17c7f8: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c7f8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c7fc: 0x3c060017  lui         $a2, 0x17
    ctx->pc = 0x17c7fcu;
    SET_GPR_S32(ctx, 6, (int32_t)((uint32_t)23 << 16));
    // 0x17c800: 0x24040003  addiu       $a0, $zero, 0x3
    ctx->pc = 0x17c800u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
    // 0x17c804: 0x2625002c  addiu       $a1, $s1, 0x2C
    ctx->pc = 0x17c804u;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 17), 44));
    // 0x17c808: 0x24c650d0  addiu       $a2, $a2, 0x50D0
    ctx->pc = 0x17c808u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 6), 20688));
    // 0x17c80c: 0x220382d  daddu       $a3, $s1, $zero
    ctx->pc = 0x17c80cu;
    SET_GPR_U64(ctx, 7, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c810: 0x220402d  daddu       $t0, $s1, $zero
    ctx->pc = 0x17c810u;
    SET_GPR_U64(ctx, 8, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c814: 0x2442ffda  addiu       $v0, $v0, -0x26
    ctx->pc = 0x17c814u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967258));
    // 0x17c818: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c818u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c81c: 0x0  nop
    ctx->pc = 0x17c81cu;
    // NOP
    // 0x17c820: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c820u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c824: 0xe620002c  swc1        $f0, 0x2C($s1)
    ctx->pc = 0x17c824u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 44), bits); }
    // 0x17c828: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c828u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c82c: 0x2442ffc0  addiu       $v0, $v0, -0x40
    ctx->pc = 0x17c82cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967232));
    // 0x17c830: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c830u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c834: 0x0  nop
    ctx->pc = 0x17c834u;
    // NOP
    // 0x17c838: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c838u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c83c: 0xe6200030  swc1        $f0, 0x30($s1)
    ctx->pc = 0x17c83cu;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 48), bits); }
    // 0x17c840: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c840u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c844: 0x24420026  addiu       $v0, $v0, 0x26
    ctx->pc = 0x17c844u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 38));
    // 0x17c848: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c848u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c84c: 0x0  nop
    ctx->pc = 0x17c84cu;
    // NOP
    // 0x17c850: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c850u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c854: 0xe6200034  swc1        $f0, 0x34($s1)
    ctx->pc = 0x17c854u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 52), bits); }
    // 0x17c858: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17c858u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c85c: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c85cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c860: 0xc053ca4  jal         func_14F290
    ctx->pc = 0x17C860u;
    SET_GPR_U32(ctx, 31, 0x17C868u);
    ctx->pc = 0x17C864u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C860u;
            // 0x17c864: 0xe6200038  swc1        $f0, 0x38($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 56), bits); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x14F290u;
    if (runtime->hasFunction(0x14F290u)) {
        auto targetFn = runtime->lookupFunction(0x14F290u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C868u; }
        if (ctx->pc != 0x17C868u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CollisionADD_Dist_0x14f290(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C868u; }
        if (ctx->pc != 0x17C868u) { return; }
    }
    ctx->pc = 0x17C868u;
    // 0x17c868: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c868u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c86c: 0x3c060017  lui         $a2, 0x17
    ctx->pc = 0x17c86cu;
    SET_GPR_S32(ctx, 6, (int32_t)((uint32_t)23 << 16));
    // 0x17c870: 0x24040003  addiu       $a0, $zero, 0x3
    ctx->pc = 0x17c870u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
    // 0x17c874: 0x2625003c  addiu       $a1, $s1, 0x3C
    ctx->pc = 0x17c874u;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 17), 60));
    // 0x17c878: 0x24c650d0  addiu       $a2, $a2, 0x50D0
    ctx->pc = 0x17c878u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 6), 20688));
    // 0x17c87c: 0x220382d  daddu       $a3, $s1, $zero
    ctx->pc = 0x17c87cu;
    SET_GPR_U64(ctx, 7, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c880: 0x220402d  daddu       $t0, $s1, $zero
    ctx->pc = 0x17c880u;
    SET_GPR_U64(ctx, 8, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c884: 0x2442ffee  addiu       $v0, $v0, -0x12
    ctx->pc = 0x17c884u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967278));
    // 0x17c888: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c888u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c88c: 0x0  nop
    ctx->pc = 0x17c88cu;
    // NOP
    // 0x17c890: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c890u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c894: 0xe620003c  swc1        $f0, 0x3C($s1)
    ctx->pc = 0x17c894u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 60), bits); }
    // 0x17c898: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17c898u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c89c: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c89cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c8a0: 0xe6200040  swc1        $f0, 0x40($s1)
    ctx->pc = 0x17c8a0u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 64), bits); }
    // 0x17c8a4: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c8a4u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c8a8: 0x24420012  addiu       $v0, $v0, 0x12
    ctx->pc = 0x17c8a8u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 18));
    // 0x17c8ac: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c8acu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c8b0: 0x0  nop
    ctx->pc = 0x17c8b0u;
    // NOP
    // 0x17c8b4: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c8b4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c8b8: 0xe6200044  swc1        $f0, 0x44($s1)
    ctx->pc = 0x17c8b8u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 68), bits); }
    // 0x17c8bc: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c8bcu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c8c0: 0x2442001e  addiu       $v0, $v0, 0x1E
    ctx->pc = 0x17c8c0u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 30));
    // 0x17c8c4: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c8c4u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c8c8: 0x0  nop
    ctx->pc = 0x17c8c8u;
    // NOP
    // 0x17c8cc: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c8ccu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c8d0: 0xc053ca4  jal         func_14F290
    ctx->pc = 0x17C8D0u;
    SET_GPR_U32(ctx, 31, 0x17C8D8u);
    ctx->pc = 0x17C8D4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C8D0u;
            // 0x17c8d4: 0xe6200048  swc1        $f0, 0x48($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 72), bits); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x14F290u;
    if (runtime->hasFunction(0x14F290u)) {
        auto targetFn = runtime->lookupFunction(0x14F290u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C8D8u; }
        if (ctx->pc != 0x17C8D8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CollisionADD_Dist_0x14f290(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C8D8u; }
        if (ctx->pc != 0x17C8D8u) { return; }
    }
    ctx->pc = 0x17C8D8u;
    // 0x17c8d8: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c8d8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c8dc: 0x3c060017  lui         $a2, 0x17
    ctx->pc = 0x17c8dcu;
    SET_GPR_S32(ctx, 6, (int32_t)((uint32_t)23 << 16));
    // 0x17c8e0: 0x24040003  addiu       $a0, $zero, 0x3
    ctx->pc = 0x17c8e0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
    // 0x17c8e4: 0x2625004c  addiu       $a1, $s1, 0x4C
    ctx->pc = 0x17c8e4u;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 17), 76));
    // 0x17c8e8: 0x24c650d0  addiu       $a2, $a2, 0x50D0
    ctx->pc = 0x17c8e8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 6), 20688));
    // 0x17c8ec: 0x220382d  daddu       $a3, $s1, $zero
    ctx->pc = 0x17c8ecu;
    SET_GPR_U64(ctx, 7, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c8f0: 0x220402d  daddu       $t0, $s1, $zero
    ctx->pc = 0x17c8f0u;
    SET_GPR_U64(ctx, 8, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c8f4: 0x2442ffba  addiu       $v0, $v0, -0x46
    ctx->pc = 0x17c8f4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967226));
    // 0x17c8f8: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c8f8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c8fc: 0x0  nop
    ctx->pc = 0x17c8fcu;
    // NOP
    // 0x17c900: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c900u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c904: 0xe620004c  swc1        $f0, 0x4C($s1)
    ctx->pc = 0x17c904u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 76), bits); }
    // 0x17c908: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c908u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c90c: 0x2442ffd8  addiu       $v0, $v0, -0x28
    ctx->pc = 0x17c90cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967256));
    // 0x17c910: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c910u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c914: 0x0  nop
    ctx->pc = 0x17c914u;
    // NOP
    // 0x17c918: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c918u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c91c: 0xe6200050  swc1        $f0, 0x50($s1)
    ctx->pc = 0x17c91cu;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 80), bits); }
    // 0x17c920: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c920u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c924: 0x2442ffda  addiu       $v0, $v0, -0x26
    ctx->pc = 0x17c924u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967258));
    // 0x17c928: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c928u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c92c: 0x0  nop
    ctx->pc = 0x17c92cu;
    // NOP
    // 0x17c930: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c930u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c934: 0xe6200054  swc1        $f0, 0x54($s1)
    ctx->pc = 0x17c934u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 84), bits); }
    // 0x17c938: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17c938u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c93c: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c93cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c940: 0xc053ca4  jal         func_14F290
    ctx->pc = 0x17C940u;
    SET_GPR_U32(ctx, 31, 0x17C948u);
    ctx->pc = 0x17C944u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C940u;
            // 0x17c944: 0xe6200058  swc1        $f0, 0x58($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 88), bits); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x14F290u;
    if (runtime->hasFunction(0x14F290u)) {
        auto targetFn = runtime->lookupFunction(0x14F290u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C948u; }
        if (ctx->pc != 0x17C948u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CollisionADD_Dist_0x14f290(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C948u; }
        if (ctx->pc != 0x17C948u) { return; }
    }
    ctx->pc = 0x17C948u;
    // 0x17c948: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c948u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c94c: 0x3c060017  lui         $a2, 0x17
    ctx->pc = 0x17c94cu;
    SET_GPR_S32(ctx, 6, (int32_t)((uint32_t)23 << 16));
    // 0x17c950: 0x24040003  addiu       $a0, $zero, 0x3
    ctx->pc = 0x17c950u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
    // 0x17c954: 0x2625005c  addiu       $a1, $s1, 0x5C
    ctx->pc = 0x17c954u;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 17), 92));
    // 0x17c958: 0x24c650d0  addiu       $a2, $a2, 0x50D0
    ctx->pc = 0x17c958u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 6), 20688));
    // 0x17c95c: 0x220382d  daddu       $a3, $s1, $zero
    ctx->pc = 0x17c95cu;
    SET_GPR_U64(ctx, 7, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c960: 0x220402d  daddu       $t0, $s1, $zero
    ctx->pc = 0x17c960u;
    SET_GPR_U64(ctx, 8, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c964: 0x24420026  addiu       $v0, $v0, 0x26
    ctx->pc = 0x17c964u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 38));
    // 0x17c968: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c968u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c96c: 0x0  nop
    ctx->pc = 0x17c96cu;
    // NOP
    // 0x17c970: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c970u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c974: 0xe620005c  swc1        $f0, 0x5C($s1)
    ctx->pc = 0x17c974u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 92), bits); }
    // 0x17c978: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c978u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c97c: 0x2442ffd8  addiu       $v0, $v0, -0x28
    ctx->pc = 0x17c97cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967256));
    // 0x17c980: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c980u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c984: 0x0  nop
    ctx->pc = 0x17c984u;
    // NOP
    // 0x17c988: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c988u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c98c: 0xe6200060  swc1        $f0, 0x60($s1)
    ctx->pc = 0x17c98cu;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 96), bits); }
    // 0x17c990: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c990u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c994: 0x24420046  addiu       $v0, $v0, 0x46
    ctx->pc = 0x17c994u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 70));
    // 0x17c998: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c998u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c99c: 0x0  nop
    ctx->pc = 0x17c99cu;
    // NOP
    // 0x17c9a0: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c9a0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c9a4: 0xe6200064  swc1        $f0, 0x64($s1)
    ctx->pc = 0x17c9a4u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 100), bits); }
    // 0x17c9a8: 0xc7a00038  lwc1        $f0, 0x38($sp)
    ctx->pc = 0x17c9a8u;
    { uint32_t bits = READ32(ADD32(GPR_U32(ctx, 29), 56)); float f; std::memcpy(&f, &bits, sizeof(f)); ctx->f[0] = f; }
    // 0x17c9ac: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c9acu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c9b0: 0xc053ca4  jal         func_14F290
    ctx->pc = 0x17C9B0u;
    SET_GPR_U32(ctx, 31, 0x17C9B8u);
    ctx->pc = 0x17C9B4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17C9B0u;
            // 0x17c9b4: 0xe6200068  swc1        $f0, 0x68($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 104), bits); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x14F290u;
    if (runtime->hasFunction(0x14F290u)) {
        auto targetFn = runtime->lookupFunction(0x14F290u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C9B8u; }
        if (ctx->pc != 0x17C9B8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CollisionADD_Dist_0x14f290(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17C9B8u; }
        if (ctx->pc != 0x17C9B8u) { return; }
    }
    ctx->pc = 0x17C9B8u;
    // 0x17c9b8: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17c9b8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17c9bc: 0x3c060017  lui         $a2, 0x17
    ctx->pc = 0x17c9bcu;
    SET_GPR_S32(ctx, 6, (int32_t)((uint32_t)23 << 16));
    // 0x17c9c0: 0x24040003  addiu       $a0, $zero, 0x3
    ctx->pc = 0x17c9c0u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
    // 0x17c9c4: 0x2625006c  addiu       $a1, $s1, 0x6C
    ctx->pc = 0x17c9c4u;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 17), 108));
    // 0x17c9c8: 0x24c650d0  addiu       $a2, $a2, 0x50D0
    ctx->pc = 0x17c9c8u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 6), 20688));
    // 0x17c9cc: 0x220382d  daddu       $a3, $s1, $zero
    ctx->pc = 0x17c9ccu;
    SET_GPR_U64(ctx, 7, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c9d0: 0x220402d  daddu       $t0, $s1, $zero
    ctx->pc = 0x17c9d0u;
    SET_GPR_U64(ctx, 8, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17c9d4: 0x2442ff96  addiu       $v0, $v0, -0x6A
    ctx->pc = 0x17c9d4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967190));
    // 0x17c9d8: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c9d8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c9dc: 0x0  nop
    ctx->pc = 0x17c9dcu;
    // NOP
    // 0x17c9e0: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c9e0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c9e4: 0xe620006c  swc1        $f0, 0x6C($s1)
    ctx->pc = 0x17c9e4u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 108), bits); }
    // 0x17c9e8: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17c9e8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17c9ec: 0x2442fefc  addiu       $v0, $v0, -0x104
    ctx->pc = 0x17c9ecu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967036));
    // 0x17c9f0: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17c9f0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17c9f4: 0x0  nop
    ctx->pc = 0x17c9f4u;
    // NOP
    // 0x17c9f8: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17c9f8u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17c9fc: 0xe6200070  swc1        $f0, 0x70($s1)
    ctx->pc = 0x17c9fcu;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 112), bits); }
    // 0x17ca00: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17ca00u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ca04: 0x2442ffba  addiu       $v0, $v0, -0x46
    ctx->pc = 0x17ca04u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967226));
    // 0x17ca08: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17ca08u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17ca0c: 0x0  nop
    ctx->pc = 0x17ca0cu;
    // NOP
    // 0x17ca10: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17ca10u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17ca14: 0xe6200074  swc1        $f0, 0x74($s1)
    ctx->pc = 0x17ca14u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 116), bits); }
    // 0x17ca18: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ca18u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ca1c: 0x2442ffd8  addiu       $v0, $v0, -0x28
    ctx->pc = 0x17ca1cu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967256));
    // 0x17ca20: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17ca20u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17ca24: 0x0  nop
    ctx->pc = 0x17ca24u;
    // NOP
    // 0x17ca28: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17ca28u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17ca2c: 0xc053ca4  jal         func_14F290
    ctx->pc = 0x17CA2Cu;
    SET_GPR_U32(ctx, 31, 0x17CA34u);
    ctx->pc = 0x17CA30u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17CA2Cu;
            // 0x17ca30: 0xe6200078  swc1        $f0, 0x78($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 120), bits); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x14F290u;
    if (runtime->hasFunction(0x14F290u)) {
        auto targetFn = runtime->lookupFunction(0x14F290u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17CA34u; }
        if (ctx->pc != 0x17CA34u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CollisionADD_Dist_0x14f290(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17CA34u; }
        if (ctx->pc != 0x17CA34u) { return; }
    }
    ctx->pc = 0x17CA34u;
    // 0x17ca34: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17ca34u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ca38: 0x3c060017  lui         $a2, 0x17
    ctx->pc = 0x17ca38u;
    SET_GPR_S32(ctx, 6, (int32_t)((uint32_t)23 << 16));
    // 0x17ca3c: 0x24040003  addiu       $a0, $zero, 0x3
    ctx->pc = 0x17ca3cu;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
    // 0x17ca40: 0x2625007c  addiu       $a1, $s1, 0x7C
    ctx->pc = 0x17ca40u;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 17), 124));
    // 0x17ca44: 0x24c650d0  addiu       $a2, $a2, 0x50D0
    ctx->pc = 0x17ca44u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 6), 20688));
    // 0x17ca48: 0x220382d  daddu       $a3, $s1, $zero
    ctx->pc = 0x17ca48u;
    SET_GPR_U64(ctx, 7, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17ca4c: 0x220402d  daddu       $t0, $s1, $zero
    ctx->pc = 0x17ca4cu;
    SET_GPR_U64(ctx, 8, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17ca50: 0x24420046  addiu       $v0, $v0, 0x46
    ctx->pc = 0x17ca50u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 70));
    // 0x17ca54: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17ca54u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17ca58: 0x0  nop
    ctx->pc = 0x17ca58u;
    // NOP
    // 0x17ca5c: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17ca5cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17ca60: 0xe620007c  swc1        $f0, 0x7C($s1)
    ctx->pc = 0x17ca60u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 124), bits); }
    // 0x17ca64: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ca64u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ca68: 0x2442fefc  addiu       $v0, $v0, -0x104
    ctx->pc = 0x17ca68u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967036));
    // 0x17ca6c: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17ca6cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17ca70: 0x0  nop
    ctx->pc = 0x17ca70u;
    // NOP
    // 0x17ca74: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17ca74u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17ca78: 0xe6200080  swc1        $f0, 0x80($s1)
    ctx->pc = 0x17ca78u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 128), bits); }
    // 0x17ca7c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17ca7cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17ca80: 0x2442006a  addiu       $v0, $v0, 0x6A
    ctx->pc = 0x17ca80u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 106));
    // 0x17ca84: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17ca84u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17ca88: 0x0  nop
    ctx->pc = 0x17ca88u;
    // NOP
    // 0x17ca8c: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17ca8cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17ca90: 0xe6200084  swc1        $f0, 0x84($s1)
    ctx->pc = 0x17ca90u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 132), bits); }
    // 0x17ca94: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17ca94u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17ca98: 0x2442ffd8  addiu       $v0, $v0, -0x28
    ctx->pc = 0x17ca98u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967256));
    // 0x17ca9c: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17ca9cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17caa0: 0x0  nop
    ctx->pc = 0x17caa0u;
    // NOP
    // 0x17caa4: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17caa4u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17caa8: 0xc053ca4  jal         func_14F290
    ctx->pc = 0x17CAA8u;
    SET_GPR_U32(ctx, 31, 0x17CAB0u);
    ctx->pc = 0x17CAACu;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17CAA8u;
            // 0x17caac: 0xe6200088  swc1        $f0, 0x88($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 136), bits); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x14F290u;
    if (runtime->hasFunction(0x14F290u)) {
        auto targetFn = runtime->lookupFunction(0x14F290u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17CAB0u; }
        if (ctx->pc != 0x17CAB0u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CollisionADD_Dist_0x14f290(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17CAB0u; }
        if (ctx->pc != 0x17CAB0u) { return; }
    }
    ctx->pc = 0x17CAB0u;
    // 0x17cab0: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17cab0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17cab4: 0x3c060017  lui         $a2, 0x17
    ctx->pc = 0x17cab4u;
    SET_GPR_S32(ctx, 6, (int32_t)((uint32_t)23 << 16));
    // 0x17cab8: 0x24040003  addiu       $a0, $zero, 0x3
    ctx->pc = 0x17cab8u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
    // 0x17cabc: 0x2625008c  addiu       $a1, $s1, 0x8C
    ctx->pc = 0x17cabcu;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 17), 140));
    // 0x17cac0: 0x24c650d0  addiu       $a2, $a2, 0x50D0
    ctx->pc = 0x17cac0u;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 6), 20688));
    // 0x17cac4: 0x220382d  daddu       $a3, $s1, $zero
    ctx->pc = 0x17cac4u;
    SET_GPR_U64(ctx, 7, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17cac8: 0x220402d  daddu       $t0, $s1, $zero
    ctx->pc = 0x17cac8u;
    SET_GPR_U64(ctx, 8, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17cacc: 0x2442ff7e  addiu       $v0, $v0, -0x82
    ctx->pc = 0x17caccu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967166));
    // 0x17cad0: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17cad0u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17cad4: 0x0  nop
    ctx->pc = 0x17cad4u;
    // NOP
    // 0x17cad8: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17cad8u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17cadc: 0xe620008c  swc1        $f0, 0x8C($s1)
    ctx->pc = 0x17cadcu;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 140), bits); }
    // 0x17cae0: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17cae0u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17cae4: 0x2442fefc  addiu       $v0, $v0, -0x104
    ctx->pc = 0x17cae4u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967036));
    // 0x17cae8: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17cae8u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17caec: 0x0  nop
    ctx->pc = 0x17caecu;
    // NOP
    // 0x17caf0: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17caf0u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17caf4: 0xe6200090  swc1        $f0, 0x90($s1)
    ctx->pc = 0x17caf4u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 144), bits); }
    // 0x17caf8: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17caf8u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17cafc: 0x2442ff96  addiu       $v0, $v0, -0x6A
    ctx->pc = 0x17cafcu;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967190));
    // 0x17cb00: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17cb00u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17cb04: 0x0  nop
    ctx->pc = 0x17cb04u;
    // NOP
    // 0x17cb08: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17cb08u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17cb0c: 0xe6200094  swc1        $f0, 0x94($s1)
    ctx->pc = 0x17cb0cu;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 148), bits); }
    // 0x17cb10: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17cb10u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17cb14: 0x2442ff88  addiu       $v0, $v0, -0x78
    ctx->pc = 0x17cb14u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967176));
    // 0x17cb18: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17cb18u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17cb1c: 0x0  nop
    ctx->pc = 0x17cb1cu;
    // NOP
    // 0x17cb20: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17cb20u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17cb24: 0xc053ca4  jal         func_14F290
    ctx->pc = 0x17CB24u;
    SET_GPR_U32(ctx, 31, 0x17CB2Cu);
    ctx->pc = 0x17CB28u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17CB24u;
            // 0x17cb28: 0xe6200098  swc1        $f0, 0x98($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 152), bits); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x14F290u;
    if (runtime->hasFunction(0x14F290u)) {
        auto targetFn = runtime->lookupFunction(0x14F290u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17CB2Cu; }
        if (ctx->pc != 0x17CB2Cu) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CollisionADD_Dist_0x14f290(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17CB2Cu; }
        if (ctx->pc != 0x17CB2Cu) { return; }
    }
    ctx->pc = 0x17CB2Cu;
    // 0x17cb2c: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17cb2cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17cb30: 0x3c060017  lui         $a2, 0x17
    ctx->pc = 0x17cb30u;
    SET_GPR_S32(ctx, 6, (int32_t)((uint32_t)23 << 16));
    // 0x17cb34: 0x24040003  addiu       $a0, $zero, 0x3
    ctx->pc = 0x17cb34u;
    SET_GPR_S32(ctx, 4, (int32_t)ADD32(GPR_U32(ctx, 0), 3));
    // 0x17cb38: 0x2625009c  addiu       $a1, $s1, 0x9C
    ctx->pc = 0x17cb38u;
    SET_GPR_S32(ctx, 5, (int32_t)ADD32(GPR_U32(ctx, 17), 156));
    // 0x17cb3c: 0x24c650d0  addiu       $a2, $a2, 0x50D0
    ctx->pc = 0x17cb3cu;
    SET_GPR_S32(ctx, 6, (int32_t)ADD32(GPR_U32(ctx, 6), 20688));
    // 0x17cb40: 0x220382d  daddu       $a3, $s1, $zero
    ctx->pc = 0x17cb40u;
    SET_GPR_U64(ctx, 7, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17cb44: 0x220402d  daddu       $t0, $s1, $zero
    ctx->pc = 0x17cb44u;
    SET_GPR_U64(ctx, 8, (uint64_t)GPR_U64(ctx, 17) + (uint64_t)GPR_U64(ctx, 0));
    // 0x17cb48: 0x2442006a  addiu       $v0, $v0, 0x6A
    ctx->pc = 0x17cb48u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 106));
    // 0x17cb4c: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17cb4cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17cb50: 0x0  nop
    ctx->pc = 0x17cb50u;
    // NOP
    // 0x17cb54: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17cb54u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17cb58: 0xe620009c  swc1        $f0, 0x9C($s1)
    ctx->pc = 0x17cb58u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 156), bits); }
    // 0x17cb5c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17cb5cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17cb60: 0x2442fefc  addiu       $v0, $v0, -0x104
    ctx->pc = 0x17cb60u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967036));
    // 0x17cb64: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17cb64u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17cb68: 0x0  nop
    ctx->pc = 0x17cb68u;
    // NOP
    // 0x17cb6c: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17cb6cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17cb70: 0xe62000a0  swc1        $f0, 0xA0($s1)
    ctx->pc = 0x17cb70u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 160), bits); }
    // 0x17cb74: 0x8fa2003c  lw          $v0, 0x3C($sp)
    ctx->pc = 0x17cb74u;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x17cb78: 0x24420082  addiu       $v0, $v0, 0x82
    ctx->pc = 0x17cb78u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 130));
    // 0x17cb7c: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17cb7cu;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17cb80: 0x0  nop
    ctx->pc = 0x17cb80u;
    // NOP
    // 0x17cb84: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17cb84u;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17cb88: 0xe62000a4  swc1        $f0, 0xA4($s1)
    ctx->pc = 0x17cb88u;
    { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 164), bits); }
    // 0x17cb8c: 0x8fa20038  lw          $v0, 0x38($sp)
    ctx->pc = 0x17cb8cu;
    SET_GPR_S32(ctx, 2, (int32_t)READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x17cb90: 0x2442ff88  addiu       $v0, $v0, -0x78
    ctx->pc = 0x17cb90u;
    SET_GPR_S32(ctx, 2, (int32_t)ADD32(GPR_U32(ctx, 2), 4294967176));
    // 0x17cb94: 0x44820000  mtc1        $v0, $f0
    ctx->pc = 0x17cb94u;
    { uint32_t bits = GPR_U32(ctx, 2); std::memcpy(&ctx->f[0], &bits, sizeof(bits)); }
    // 0x17cb98: 0x0  nop
    ctx->pc = 0x17cb98u;
    // NOP
    // 0x17cb9c: 0x46800020  cvt.s.w     $f0, $f0
    ctx->pc = 0x17cb9cu;
    { int32_t tmp; std::memcpy(&tmp, &ctx->f[0], sizeof(tmp)); ctx->f[0] = FPU_CVT_S_W(tmp); }
    // 0x17cba0: 0xc053ca4  jal         func_14F290
    ctx->pc = 0x17CBA0u;
    SET_GPR_U32(ctx, 31, 0x17CBA8u);
    ctx->pc = 0x17CBA4u;
    ctx->in_delay_slot = true; ctx->branch_pc = 0x17CBA0u;
            // 0x17cba4: 0xe62000a8  swc1        $f0, 0xA8($s1) (Delay Slot)
        { float f = ctx->f[0]; uint32_t bits; std::memcpy(&bits, &f, sizeof(bits)); WRITE32(ADD32(GPR_U32(ctx, 17), 168), bits); }
        ctx->in_delay_slot = false;
    ctx->pc = 0x14F290u;
    if (runtime->hasFunction(0x14F290u)) {
        auto targetFn = runtime->lookupFunction(0x14F290u);
        const uint32_t __entryPc = ctx->pc;
        targetFn(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17CBA8u; }
        if (ctx->pc != 0x17CBA8u) { return; }
    } else {
        const uint32_t __entryPc = ctx->pc;
        CollisionADD_Dist_0x14f290(rdram, ctx, runtime);
        if (ctx->pc == __entryPc) { ctx->pc = 0x17CBA8u; }
        if (ctx->pc != 0x17CBA8u) { return; }
    }
    ctx->pc = 0x17CBA8u;
    // 0x17cba8: 0x8e230014  lw          $v1, 0x14($s1)
    ctx->pc = 0x17cba8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x17cbac: 0x2463ffff  addiu       $v1, $v1, -0x1
    ctx->pc = 0x17cbacu;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x17cbb0: 0xae230014  sw          $v1, 0x14($s1)
    ctx->pc = 0x17cbb0u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 3));
    // 0x17cbb4: 0x0  nop
    ctx->pc = 0x17cbb4u;
    // NOP
label_17cbb8:
    // 0x17cbb8: 0x8e230024  lw          $v1, 0x24($s1)
    ctx->pc = 0x17cbb8u;
    SET_GPR_S32(ctx, 3, (int32_t)READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x17cbbc: 0x24630001  addiu       $v1, $v1, 0x1
    ctx->pc = 0x17cbbcu;
    SET_GPR_S32(ctx, 3, (int32_t)ADD32(GPR_U32(ctx, 3), 1));
    // 0x17cbc0: 0xae230024  sw          $v1, 0x24($s1)
    ctx->pc = 0x17cbc0u;
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 3));
    // 0x17cbc4: 0x0  nop
    ctx->pc = 0x17cbc4u;
    // NOP
label_17cbc8:
    // 0x17cbc8: 0xdfbf0020  ld          $ra, 0x20($sp)
    ctx->pc = 0x17cbc8u;
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17cbcc: 0x7bb10010  lq          $s1, 0x10($sp)
    ctx->pc = 0x17cbccu;
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17cbd0: 0x7bb00000  lq          $s0, 0x0($sp)
    ctx->pc = 0x17cbd0u;
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17cbd4: 0x3e00008  jr          $ra
    ctx->pc = 0x17CBD4u;
    {
        uint32_t jumpTarget = GPR_U32(ctx, 31);
        ctx->pc = 0x17CBD8u;
        ctx->in_delay_slot = true; ctx->branch_pc = 0x17CBD4u;
            // 0x17cbd8: 0x27bd0040  addiu       $sp, $sp, 0x40 (Delay Slot)
        SET_GPR_S32(ctx, 29, (int32_t)ADD32(GPR_U32(ctx, 29), 64));
        ctx->in_delay_slot = false;
        ctx->pc = jumpTarget;
        switch (jumpTarget) {
            case 0x177D60u: goto label_177d60;
            case 0x177D98u: goto label_177d98;
            case 0x177DD0u: goto label_177dd0;
            case 0x177E08u: goto label_177e08;
            case 0x177E58u: goto label_177e58;
            case 0x177E90u: goto label_177e90;
            case 0x177EA0u: goto label_177ea0;
            case 0x177ED8u: goto label_177ed8;
            case 0x177F38u: goto label_177f38;
            case 0x177F90u: goto label_177f90;
            case 0x177FD8u: goto label_177fd8;
            case 0x178000u: goto label_178000;
            case 0x178050u: goto label_178050;
            case 0x178158u: goto label_178158;
            case 0x178220u: goto label_178220;
            case 0x178298u: goto label_178298;
            case 0x178398u: goto label_178398;
            case 0x178460u: goto label_178460;
            case 0x1784D8u: goto label_1784d8;
            case 0x178550u: goto label_178550;
            case 0x178658u: goto label_178658;
            case 0x178720u: goto label_178720;
            case 0x1787E8u: goto label_1787e8;
            case 0x1788B0u: goto label_1788b0;
            case 0x178928u: goto label_178928;
            case 0x178A28u: goto label_178a28;
            case 0x178AF0u: goto label_178af0;
            case 0x178BB8u: goto label_178bb8;
            case 0x178C30u: goto label_178c30;
            case 0x178D20u: goto label_178d20;
            case 0x178DE8u: goto label_178de8;
            case 0x178EB0u: goto label_178eb0;
            case 0x178F28u: goto label_178f28;
            case 0x179030u: goto label_179030;
            case 0x1790F8u: goto label_1790f8;
            case 0x1791C0u: goto label_1791c0;
            case 0x179288u: goto label_179288;
            case 0x179350u: goto label_179350;
            case 0x1793C8u: goto label_1793c8;
            case 0x1794C8u: goto label_1794c8;
            case 0x179590u: goto label_179590;
            case 0x179658u: goto label_179658;
            case 0x1796D0u: goto label_1796d0;
            case 0x1797C0u: goto label_1797c0;
            case 0x179888u: goto label_179888;
            case 0x179950u: goto label_179950;
            case 0x1799C8u: goto label_1799c8;
            case 0x179AD0u: goto label_179ad0;
            case 0x179B98u: goto label_179b98;
            case 0x179C60u: goto label_179c60;
            case 0x179D28u: goto label_179d28;
            case 0x179DF0u: goto label_179df0;
            case 0x179EB8u: goto label_179eb8;
            case 0x179F30u: goto label_179f30;
            case 0x17A030u: goto label_17a030;
            case 0x17A0F8u: goto label_17a0f8;
            case 0x17A1C0u: goto label_17a1c0;
            case 0x17A288u: goto label_17a288;
            case 0x17A300u: goto label_17a300;
            case 0x17A3F0u: goto label_17a3f0;
            case 0x17A4B8u: goto label_17a4b8;
            case 0x17A580u: goto label_17a580;
            case 0x17A5F0u: goto label_17a5f0;
            case 0x17A618u: goto label_17a618;
            case 0x17A648u: goto label_17a648;
            case 0x17A670u: goto label_17a670;
            case 0x17A6C8u: goto label_17a6c8;
            case 0x17A7A8u: goto label_17a7a8;
            case 0x17A838u: goto label_17a838;
            case 0x17A8B8u: goto label_17a8b8;
            case 0x17A9C8u: goto label_17a9c8;
            case 0x17AA88u: goto label_17aa88;
            case 0x17AB08u: goto label_17ab08;
            case 0x17AC70u: goto label_17ac70;
            case 0x17AD98u: goto label_17ad98;
            case 0x17AEF8u: goto label_17aef8;
            case 0x17AFD8u: goto label_17afd8;
            case 0x17B0A8u: goto label_17b0a8;
            case 0x17B128u: goto label_17b128;
            case 0x17B2D0u: goto label_17b2d0;
            case 0x17B428u: goto label_17b428;
            case 0x17B588u: goto label_17b588;
            case 0x17B668u: goto label_17b668;
            case 0x17B778u: goto label_17b778;
            case 0x17B828u: goto label_17b828;
            case 0x17B854u: goto label_17b854;
            case 0x17BA10u: goto label_17ba10;
            case 0x17BBF8u: goto label_17bbf8;
            case 0x17BDD8u: goto label_17bdd8;
            case 0x17BF30u: goto label_17bf30;
            case 0x17C080u: goto label_17c080;
            case 0x17C178u: goto label_17c178;
            case 0x17C2D0u: goto label_17c2d0;
            case 0x17C318u: goto label_17c318;
            case 0x17C350u: goto label_17c350;
            case 0x17C388u: goto label_17c388;
            case 0x17C420u: goto label_17c420;
            case 0x17C470u: goto label_17c470;
            case 0x17C498u: goto label_17c498;
            case 0x17C4B0u: goto label_17c4b0;
            case 0x17C4C8u: goto label_17c4c8;
            case 0x17C4E0u: goto label_17c4e0;
            case 0x17C4F8u: goto label_17c4f8;
            case 0x17C510u: goto label_17c510;
            case 0x17C528u: goto label_17c528;
            case 0x17C540u: goto label_17c540;
            case 0x17C558u: goto label_17c558;
            case 0x17C570u: goto label_17c570;
            case 0x17C588u: goto label_17c588;
            case 0x17C5A0u: goto label_17c5a0;
            case 0x17C5E0u: goto label_17c5e0;
            case 0x17C628u: goto label_17c628;
            case 0x17C650u: goto label_17c650;
            case 0x17C690u: goto label_17c690;
            case 0x17C718u: goto label_17c718;
            case 0x17C720u: goto label_17c720;
            case 0x17C738u: goto label_17c738;
            case 0x17C748u: goto label_17c748;
            case 0x17C788u: goto label_17c788;
            case 0x17C790u: goto label_17c790;
            case 0x17C798u: goto label_17c798;
            case 0x17C7D8u: goto label_17c7d8;
            case 0x17C7F8u: goto label_17c7f8;
            case 0x17CBB8u: goto label_17cbb8;
            case 0x17CBC8u: goto label_17cbc8;
            default: break;
        }
        return;
    }
    ctx->pc = 0x17CBDCu;
}
